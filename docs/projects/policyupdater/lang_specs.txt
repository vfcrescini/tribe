Language LT

1. Components

  1.1. Identifiers

    1.1.1. Literal Identifiers

      1.1.1.1. Entity Literals

        [a-z]([a-zA-Z0-9_]{0,127})

        1.1.1.1.1. Single Subject
          
        1.1.1.1.2. Group Subject
          
        1.1.1.1.3. Single Access Right
          
        1.1.1.1.4. Group Access Right
          
        1.1.1.1.5. Single Object
          
        1.1.1.1.6. Group Object

      1.1.1.2. Temporal Interval Literals

        Positive intergers. Meaning of scale is defined by application.

        \[([0-9]{6}) - ([0-9]{6})\]

        i.e. [<int> - <int>]

    1.1.2. Variable Indentifiers

      1.1.2.1. Entity Variables
      
        1.1.2.1.1. Subject Variables

          S([0-9]{6})

          1.1.2.1.1.1. Single Subject

            SS([0-9]{6})

          1.1.2.1.1.2. Group Subject

            SG([0-9]{6})

        1.1.2.1.2. Access Right Variables

          A([0-9]{6})

          1.1.2.1.2.1. Single Access Right

            AS([0-9]{6})

          1.1.2.1.2.2. Group Access Right

            AG([0-9]{6})

        1.1.2.1.3. Object Variables

          O([0-9]{6})

          1.1.2.1.3.1. Single Object

            OS([0-9]{6})

          1.1.2.1.3.2. Group Object

            OG([0-9]{6})

      1.1.2.2. Temporal Interval Variables

        A temporal interval variable represents a single unknown temporal
        interval quantity.

        I([0-9]{6})

    1.1.3. Policy Update Identifiers

      These types of indentifiers are used as labels for policy updates.

      Because policy update identifiers occupy a different namespace from
      entity identifiers, they share the same syntax:

      [a-z]([a-zA-Z0-9_]){0,127}

  1.2. Atoms

    An atom may be one of the following:

    1.2.1. Holds

      holds(
        <subject_single> | <subject_group>,
        <access_right_single> | <access_right_group>,
        <object_single> | <object_group>,
        <interval>
      )
  
    1.2.2. Membership

      memb(<subject_single>, <subject_group>, <interval>) |
      memb(<access_right_single>, <access_right_group>, <interval>) |
      memb(<object_single>, <object_group>, <interval>)
  
    1.2.3. Subset

      subst(<subject_group>, <subject_group>, <interval>) |
      subst(<access_right_group>, <access_right_group>, <interval>) |
      subst(object_group>, <object_group>, <interval>)
  
  1.3. Facts

    1.3.1 Positive Facts

      <atom>
  
    1.3.2 Negative Facts

      !<atom>

  1.4. Expressions

    <fact1> [&& <fact2> [ && ...]]

2. Definitions

  2.1. Entity Literal Declarations

    entity sub|acc|obj[-grp] <entity1> [, <entity2>, [, ...]]

    (Difference from original language: note the change from the keyword
    "ident" to "entity" -- changed for clarity as intervals and variables are
    identifiers too)

  2.2. Temporal Interval Relation Declaration

    interval 
      equals(<int1>, <int2>) |
      before(<int1>, <int2>) |
      meets(<int1>, <int2>) |
      overlaps(<int1>, <int2>) |
      during(<int1>, <int2>) |
      starts(<int1>, <int2>) |
      ends(<int1>, <int2>);

    - "intx" can be either an interval literal or an interval variable.

  2.3. Initial Expression Declaration

    initially <ground expression>;

  2.4. Constraint Declaration

    always <exp1> implied by <exp2> with absence <exp3>;

  2.5. Policy Update Declaration

    <update_id>([<var_id>[, ...]]) causes <vexp1> if <vexp2>;

    where <vexp1> and <vexp2> are expressions containing atoms that may
    contain variables.

3. Directives

  3.1. Query Directive

    query <expression>;

  3.2. Compute Directive

    compute;

  3.3. Policy Update Sequence Directives

    3.3.1. Add

      seq add <update_id>([<id>[, ...]]);

      where <id> may be entity or interval identifiers.

    3.3.2. Delete

      seq del <n>;

    3.3.3. List

      seq list;

4. Translation

  4,1, Initial Expression Rules

  4.2. Constraint Rules

  4.3. Policy Update Rules

  4.4. Inheritance Rules

    4.4.1. Membership Inheritance

    4.4.2. Subset Interhitance

  4.5. Transitivity Rules

  4.6. Inertial Rules
