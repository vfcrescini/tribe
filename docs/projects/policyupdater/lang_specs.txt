Language LT

1. Components

  1.1. Identifiers

    1.1.1. Literal Identifiers

      1.1.1.1. Entity Literals

        [a-z]([a-zA-Z0-9_]{0,127})

        1.1.1.1.1. Single Subject
          
        1.1.1.1.2. Group Subject
          
        1.1.1.1.3. Single Access Right
          
        1.1.1.1.4. Group Access Right
          
        1.1.1.1.5. Single Object
          
        1.1.1.1.6. Group Object

      1.1.1.2. Temporal Interval Literals

        Positive intergers. Meaning of scale is defined by application.

        \[([0-9]{6}) - ([0-9]{6})\]

        i.e. [<int> - <int>]

    1.1.2. Variable Indentifiers

      1.1.2.1. Entity Variables
      
        1.1.2.1.1. Subject Variables

          S([0-9]{6})

          1.1.2.1.1.1. Single Subject

            SS([0-9]{6})

          1.1.2.1.1.2. Group Subject

            SG([0-9]{6})

        1.1.2.1.2. Access Right Variables

          A([0-9]{6})

          1.1.2.1.2.1. Single Access Right

            AS([0-9]{6})

          1.1.2.1.2.2. Group Access Right

            AG([0-9]{6})

        1.1.2.1.3. Object Variables

          O([0-9]{6})

          1.1.2.1.3.1. Single Object

            OS([0-9]{6})

          1.1.2.1.3.2. Group Object

            OG([0-9]{6})

      1.1.2.2. Temporal Interval Variables

        A temporal interval variable represents a single unknown temporal
        interval quantity.

        I([0-9]{6})

    1.1.3. Policy Update Identifiers

      These types of indentifiers are used as labels for policy updates.

      Because policy update identifiers occupy a different namespace from
      entity identifiers, they share the same syntax:

      [a-z]([a-zA-Z0-9_]){0,127}

  1.2. Atoms

    An atom may be one of the following:

    1.2.1. Holds

      holds(
        <subject_single> | <subject_group>,
        <access_right_single> | <access_right_group>,
        <object_single> | <object_group>,
        <interval>
      )
  
    1.2.2. Membership

      memb(<subject_single>, <subject_group>, <interval>) |
      memb(<access_right_single>, <access_right_group>, <interval>) |
      memb(<object_single>, <object_group>, <interval>)
  
    1.2.3. Subset

      subst(<subject_group>, <subject_group>, <interval>) |
      subst(<access_right_group>, <access_right_group>, <interval>) |
      subst(object_group>, <object_group>, <interval>)

    Atoms that do not contain entity variables are called ground atoms, while
    atoms that do contain entity variables are called non-ground atoms. Note
    that ground atoms may contain temporal interval variables.
  
  1.3. Facts

    Facts composed entirely of ground atoms are called ground facts, while
    facts that have non-ground atoms are called non-ground facts.

    1.3.1 Positive Facts

      <atom>
  
    1.3.2 Negative Facts

      !<atom>

  1.4. Expressions

    Ground expressions are expressions that are composed entirely of ground
    facts, while non-ground expressions contain at least one non-ground fact.

    <fact1> [, <fact2> [, ...]]

    (Difference from original language: the original conjunction symbol was
    the double ampersand characters "&&". In this language, the comma "," is
    used for simplicity).

2. Definitions

  2.1. Entity Literal Definitions

    entity sub|acc|obj[-grp] <entity1> [, <entity2>, [, ...]]

    (Difference from original language: note the change from the keyword
    "ident" to "entity" -- changed for clarity as intervals and variables are
    identifiers too)

  2.2. Temporal Interval Relation Definition

    This definition statements allow temporal intervals (literals and
    variables) to be "bound" to each other with any of the 7 interval relations
    below:

      - Equals
      - Before
      - Meets
      - Overlaps
      - During
      - Starts
      - Finishes

    A temporal interval relation defined by this statement asserts that the
    relation between the two intervals holds globally for the lifetime of
    the program.

    interval 
      equals(<int1>, <int2>) |
      before(<int1>, <int2>) |
      meets(<int1>, <int2>) |
      overlaps(<int1>, <int2>) |
      during(<int1>, <int2>) |
      starts(<int1>, <int2>) |
      finishes(<int1>, <int2>);

    where "intx" can be either an interval literal or an interval variable.

  2.3. Initial Expression Definition

    Initial expressions hold only until a policy update overrides them.

    initially <ground-expression>;

  2.4. Constraint Definition

    Constraints hold even after policy updates are applied.

    always <expression1>
      implied by <expression2>
      with absence <expression3>;

    Note that the expressions that make up constraints may be non-ground. This
    means that an entity variable may occur within them.

    The scope of the entity variables that may occur in the expressions in a
    constraint definition statement is limited to that definition statement
    only.

  2.5. Policy Update Definition

    <update_id>([<var_id>[, ...]])
      causes <expression1>
      if <expression2>;

    where <expression1> and <expression2> are composed of atoms that may
    contain entity variables listed in variable list (<var_id>, ...).

    As with constraints, policy update definition exressions may be non-ground.

3. Directives

  3.1. Query Directive

    This directive may be used to query the system whether a given ground
    expression holds while the given interval relations hold. The directive
    returns one of the following replies:

      - TRUE
      - FALSE
      - UNKNOWN

    Syntax:

      query <ground-expression> [where <interval-relation>[, ...]];

    In each of the atoms in the expression, a temporal interval variable
    may occur. These existentially qualifed temporal variables are used for
    the sole purpose of representing temporal interval relations between any
    two facts occuring in the given query expression. As such, the scope of
    these temporal interval variables are limited to the query directive
    statement that contain them.

    Valid Query Examples:

      - Does s0 hold access right a0 for object o0 from time index 9 to time
        index 17?

        query holds(s0, a0, o0, [9-17]);

      - Does s0 hold access right a0 for object o0 at any time between time
        index 5 to time index 10?

        query holds(s0, a0, o0, I0) where during(I0, [5-10]);

      - Does s0 hold access right a0 for object o0 at any time before s1 holds
        access right a1 for object o1?

        query holds(s0, a0, o0, I0), holds(s1, a1, o1, I1)
        where before(i0, I1);

    Invalid Query Examples:

      The following are invalid because the given information are insufficient
      to ground the given temporal interval variables:

      - query holds(s0, a0, o0, I0); 

      - query holds(s0, a0, o0, I0), holds(s1, a1, o1, I1);

      - query holds(s0, a0, o0, I0) where meets(i0, I1);

      - query holds(s0, a0, o0, I0), holds(s1, a1, o1, I1)
        where overlaps(I0, I2), equals(I1, I3);

  3.2. Compute Directive

    compute;

  3.3. Policy Update Sequence Directives

    3.3.1. Add

      seq add <update_id>([<id>[, ...]]);

      where <id> may be entity or interval identifiers.

    3.3.2. Delete

      seq del <n>;

    3.3.3. List

      seq list;

4. Evaluation

  4.1. Data Structures

    The evaluation process needs some data structures defined. 

    4.1.1. Entity Table

      This table holds all the defined literal entities.

    4.1.2. Temporal Interval Relations Table

  4.2. Translation of Statements to Normal Logic Rules

    4.2.1. Initial Expression Rules

    4.2.2. Constraint Rules

      4.2.2.1. Grounding of Variables

    4.2.3. Policy Update Rules

    4.2.4. Other Rules

      4.2.4.1. Inheritance Rules

        4.2.4.1.1. Membership Inheritance

        4.2.4.1.2. Subset Interhitance

      4.2.4.2. Transitivity Rules

      4.2.4.3. Inertial Rules
