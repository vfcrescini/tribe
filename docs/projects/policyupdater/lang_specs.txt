Language LT

1. Components

  1.1. Identifiers

    1.1.1. Literal Identifiers

      1.1.1.1. Entity Literals

        [a-z]([a-zA-Z0-9_]{0,127})

        1.1.1.1.1. Single Subject
          
        1.1.1.1.2. Group Subject
          
        1.1.1.1.3. Single Access Right
          
        1.1.1.1.4. Group Access Right
          
        1.1.1.1.5. Single Object
          
        1.1.1.1.6. Group Object

      1.1.1.2. Temporal Interval Literals

        Positive intergers. Meaning of scale is defined by application.

        \[([0-9]{6}) - ([0-9]{6})\]

        i.e. [<int> - <int>]

    1.1.2. Variable Indentifiers

      1.1.2.1. Entity Variables
      
        1.1.2.1.1. Subject Variables

          S([0-9]{6})

          1.1.2.1.1.1. Single Subject

            SS([0-9]{6})

          1.1.2.1.1.2. Group Subject

            SG([0-9]{6})

        1.1.2.1.2. Access Right Variables

          A([0-9]{6})

          1.1.2.1.2.1. Single Access Right

            AS([0-9]{6})

          1.1.2.1.2.2. Group Access Right

            AG([0-9]{6})

        1.1.2.1.3. Object Variables

          O([0-9]{6})

          1.1.2.1.3.1. Single Object

            OS([0-9]{6})

          1.1.2.1.3.2. Group Object

            OG([0-9]{6})

      1.1.2.2. Temporal Interval Variables

        A temporal interval variable represents a single unknown temporal
        interval quantity.

        I([0-9]{6})

    1.1.3. Policy Update Identifiers

      These types of indentifiers are used as labels for policy updates.

      Because policy update identifiers occupy a different namespace from
      entity identifiers, they share the same syntax:

      [a-z]([a-zA-Z0-9_]){0,127}

  1.2. Atoms

    An atom may be one of the following:

    1.2.1. Holds

      holds(
        <subject_single> | <subject_group>,
        <access_right_single> | <access_right_group>,
        <object_single> | <object_group>,
        <interval>
      )
  
    1.2.2. Membership

      memb(<subject_single>, <subject_group>, <interval>) |
      memb(<access_right_single>, <access_right_group>, <interval>) |
      memb(<object_single>, <object_group>, <interval>)
  
    1.2.3. Subset

      subst(<subject_group>, <subject_group>, <interval>) |
      subst(<access_right_group>, <access_right_group>, <interval>) |
      subst(object_group>, <object_group>, <interval>)

    Atoms that do not contain entity variables are called ground atoms, while
    atoms that do contain entity variables are called non-ground atoms. Note
    that ground atoms may contain temporal interval variables.
  
  1.3. Facts

    Facts composed entirely of ground atoms are called ground facts, while
    facts that have non-ground atoms are called non-ground facts.

    1.3.1 Positive Facts

      <atom>
  
    1.3.2 Negative Facts

      !<atom>

  1.4. Expressions

    Ground expressions are expressions that are composed entirely of ground
    facts, while non-ground expressions contain at least one non-ground fact.

    <fact1> [, <fact2> [, ...]]

    (Difference from original language: the original conjunction symbol was
    the double ampersand characters "&&". In this language, the comma "," is
    used for simplicity).

2. Definitions

  2.1. Entity Literal Definitions

    entity sub|acc|obj[-grp] <entity1> [, <entity2>, [, ...]]

    (Difference from original language: note the change from the keyword
    "ident" to "entity" -- changed for clarity as intervals and variables are
    identifiers too)

  2.2. Temporal Interval Relation Definition

    This definition statements allow temporal intervals (literals and
    variables) to be "bound" to each other with any of the 7 interval relations
    below:

      - Equals
      - Before
      - Meets
      - Overlaps
      - During
      - Starts
      - Finishes

    A temporal interval relation defined by this statement asserts that the
    relation between the two intervals holds globally for the lifetime of
    the program.

    interval 
      equals(<int1>, <int2>) |
      before(<int1>, <int2>) |
      meets(<int1>, <int2>) |
      overlaps(<int1>, <int2>) |
      during(<int1>, <int2>) |
      starts(<int1>, <int2>) |
      finishes(<int1>, <int2>);

    - "intx" can be either an interval literal or an interval variable.

  2.3. Initial Expression Definition

    Initial expressions hold only until a policy update overrides them.

    initially <ground-expression>;

  2.4. Constraint Definition

    Constraints hold even after policy updates are applied.

    always <expression1>
      implied by <expression2>
      with absence <expression3>;

    The scope of the entity variables that may occur in the expressions in a
    constraint definition statement is limited to that definition statement
    only.

  2.5. Policy Update Definition

    <update_id>([<var_id>[, ...]])
      causes <expression1>
      if <expression2>;

    where <expression1> and <expression2> are composed of atoms that may
    contain entity variables listed in variable list (<var_id>, ...).

3. Directives

  3.1. Query Directive

    query <expression> [where <interval-relation>[, ...]];

  3.2. Compute Directive

    compute;

  3.3. Policy Update Sequence Directives

    3.3.1. Add

      seq add <update_id>([<id>[, ...]]);

      where <id> may be entity or interval identifiers.

    3.3.2. Delete

      seq del <n>;

    3.3.3. List

      seq list;

4. Translation

  4.1. Initial Expression Rules

  4.2. Constraint Rules

  4.3. Policy Update Rules

  4.4. Inheritance Rules

    4.4.1. Membership Inheritance

    4.4.2. Subset Interhitance

  4.5. Transitivity Rules

  4.6. Inertial Rules

5. Evaluation
