% Vino Crescini  <jcrescin@cit.uws.edu.au>

\documentclass[a4paper,draft]{article}
\usepackage[light]{draftcopy}
\usepackage{moreverb}
\author{Vino Fernando Crescini\\jcrescin@cit.uws.edu.au\\\\Intelligent Systems Laboratory\\School of Computing and Information Technology\\University of Western Sydney}
\title{Implementing a High-Level Description Language for a Sequence of Transformations of Authorisation Policies}
\date{17/03/2003}
\begin{document}
  \maketitle
  \section{Introduction}

    Authorisation policies are a collection of rules and constraints that 
    limits accesses to different resources within a system. Such policies may 
    be as simple as assigning read, write or execute permissions on specific 
    files, but some policies can be as high-level and abstract as to reflect 
    the organisational hierarchy of the system. For example, high-level 
    authorisation policies might include the following:

    \begin{itemize}
      \item
        Regional Managers have read and write access to the regional database.
      \item
        Branch Managers have no read and write access to the regional database.
      \item 
        Branch Managers have read and write access to their branch database.
      \item 
         If the branch manager is also a regional manager then he has read
         but not write access to the regional database.
    \end{itemize}

    \subsection{Background}

      Typically, in an access control system, authorisation policies are stored
      into a policy database or policy base. Another entity, the authorisation
      agent (or enforcer agent) ensures that the policies in the policy base
      are enforced. 

      At its simplest form, a policy base may be implemented as an access
      control matrix where the rows represent the subjects, the columns
      represent the objects or resources and each cell contains the access
      permissions. However, the access control matrix approach is limited in
      such a way that it lacks scalability and flexibility. The size of the
      access control matrix is directly proportional to the size of the objects
      times the number of subjects. It is not difficult to see that as the
      system gets larger, any authorisation policy mechanism that uses the
      access control matrix will get progressively slower and less efficient.

      A much better approach is the logic-based system where instead of
      storing each individual rules into a database, a generalised set of
      facts and constraints are stored into the policy base. There have been
      quite a few developments in this field. In their paper, Woo and Lam
      \cite{WL} describes a logic-based specification for policy bases. Bai and
      Varadharajan \cite{BV1} went a few steps further by developing a
      high-level language for the transformation of the policy base from one
      state to another. A transformation, in this sense, is the process of
      adding, removing or modifying a rule in the policy base. Their approach
      also handles conflict resolution within a transformation. In another
      paper, Bai and Varadharajan \cite{BV2} developed another language
      specification to handle sequences of transformations.

    \subsection{Problem}

    \subsection{Plan}

    \subsection{Organisation of this Paper}

    \pagebreak

  \section{A Formal Authorisation Language}

    \subsection{Properties}

      The proposed logic-based authorisation language has one main purpose:
      to provide a simple but expressive interface between the enforcer
      agent and the knowledge base. To achieve this purpose, the authorisation
      language must possess the following properties:

      \begin{itemize}
        \item
          Standardised Syntax

          The language provides high-level semantics to allow logic-based
          operations and at the same time syntactically concise to allow
          parser-level implementation.

        \item
          Provision for Knowledge Base Initialisation

          The language includes provisions for setting logical facts into
          the knowledge base before any operation is performed.

        \item
          Mechanism for Transformations

          The language has the means to modify the preset facts in the
          knowledge base. Such operations or transformations may be to add 
          new facts, or if the fact happens to be contrary to an existing
          fact, to delete existing ones.

        \item
          Ability to Express Default Propositions

          In addition to the ability to transform the knowledge base, the 
          language also possess the ability to express constraints or default
          propositions. Constraints are logical rules or facts that must hold 
          even after transformations.

        \item
          Ability to Express both Classical Negation and Negation as Failure

          Classical negation \emph{$\lnot$} means that a proposition is
          false, explicitly. Negation as failure \emph{not}, on the other 
          hand, simply means that a proposition is assumed to be false if
          there is no evidence that the proposition is true. \cite{GV}

          The language uses \emph{not}, or symbolically, \emph{!} as classical
          negation. Negation as failure is achieved by the \emph{with absence}
          clause of the constraint statement.

        \item
          Query Functionality

          The language of course allows the knowledge base to be queried by
          providing the ability to check whether a given proposition or fact
          holds in the knowledge base.
          
      \end{itemize}

    \subsection{Definitions}

      Before the language may be completely defined, the following components 
      must first be formalised:
 
      \subsubsection{Identifiers}

        An identifier is an alphanumeric string whose first character is an
        alpha character. The formal regular expression specifications of an
        identifier is:

\begin{verbatim}
[a-zA-Z][a-zA-Z0-9_]*
\end{verbatim}

        Identifiers are literal representations of any of the three possible
        conceptual disjoint types:

        \begin{itemize}
          \item Subject (e.g. user1, alice, bob)
          \item Access (e.g. read, write, execute)
          \item Object (e.g. file1, database4)
        \end{itemize}

        In addition to the above types, identifiers may also be used to
        represent a group of identifiers of the same type.

        \begin{itemize}
          \item Subject Group
          \item Access Group
          \item Object Group
        \end{itemize}

      \subsubsection{Variables}

        Variables are identifier place holders that may be used to represent a
        specific literal or all literals of a specific type. Like an identifier,
        the regular expression of a variable is:

\begin{verbatim}
[a-zA-Z][a-zA-Z0-9_]*
\end{verbatim}

      \subsubsection{Atoms}

        Atoms are composed of a relation and two or more literals to represent
        a logical fact or predicate. The three relations, and therefore, three
        types of atoms are as follows:

        \begin{itemize}

          \item holds(S, A, O)

            An atom of this type states that the subject S holds the
            access-right A for object O.

          \item memb(E, G)

          This atom states that the non-group literal E is an element of the
          group literal G, where E and G are of the same literal type.
          E $\in$ G.

          \item subst(G$_{1}$, G$_{2}$)

          This atom states that the group literal G$_{1}$ is a proper
          subset of the group literal G$_{2}$, where G$_{1}$ and G$_{2}$
          are of the same literal type. G$_{1}$ $\subseteq$ G$_{2}$.

        \end{itemize}

        An atom may also be negated by the \emph{not} ! operator. (e.g.
        !holds(S, A, O))

        In addition to the three types of atoms, two special constant atom are
        also defined in this language: \emph{true} and \emph{false}.

      \subsubsection{Expressions}

        An expression is simply a conjunction of atoms. In this language,
        disjunctions are not allowed. The conjunction \emph{and} is 
        represented by the symbol \&\&. For example, holds(S, A, O) \&\& 
        !memb(E, G) \&\& subst(G$_{1}$, G$_{2}$) is interpreted as
        holds(S, A, O) $\land$ (not E $\in$ G) $\land$ (G$_{1}$
        $\subseteq$ G$_{2}$).

        Since negated expressions yield a disjunction of atoms, only
        atoms are allowed to be negated. To illustrate: De Morgan's Law
        states that \emph{not} (holds(S$_{1}$, A$_{1}$, O$_{1}$) $\land$
        holds(S$_{2}$, A$_{2}$, O$_{2}$)) is equivalent to (\emph{not} 
        holds(S$_{1}$, A$_{1}$, O$_{1}$)) $\lor$ (\emph{not} holds(S$_{2}$, 
        A$_{2}$, O$_{2}$)). As a consequence, parentheses are allowed only
        to enclose literals within atoms but not to group atoms together. 

        Because the constants \emph{true} and \emph{false} are atoms, they may 
        appear within expressions as well. However, the constants are more
        useful without any other atoms within the same expression, as an
        expression added with the constant \emph{true} will have no effect
        and an expression added with the constant \emph{false} will set the
        entire expression to false.

    \subsection{Syntax and Semantics}

      The language is structured into 5 different ordered sections where each
      section is a set of statements native to that section.  Each statement
      will be terminated by a semicolon ; to mark the end of that statement.

      \subsubsection{Identifier Declarations}

        All identifiers, except transformation identifiers, must first be 
        declared in this section before any proposition, constraint, 
        transformation or query statements are declared.

        This section must contain one or more identifier declaration
        statements. However, more than one identifier of one type may be 
        declared in each identifier declaration statement.

\begin{verbatim}
ident <type> <identifier>[,<identifier2>[,...]]
\end{verbatim}

        where type is one of the following: \emph{sub}, \emph{acc}, \emph{obj},
        \emph{sub-grp}, \emph{acc-grp} or \emph{obj-grp}.

        Example:

\begin{verbatim}
ident sub s1, s2;
ident acc read, write, execute;
ident obj file1, file2;
\end{verbatim}

      \subsubsection{Initial State Definition}

        Before transformations or constraints can be applied or even defined,
        the initial state must first be defined. This section will contain
        one or more definition statements of the form:

\begin{verbatim}
initially <expression>
\end{verbatim}

      \subsubsection{Constraint Statements}

        This section allows constrains or default propositions to be defined.
        Naturally, constraints will have to be defined first before
        transformations.

        The most general form is:

\begin{verbatim}
<expression1> implies <expression2> with absence <expression3>
\end{verbatim}

        The statement above says that if expression1 is true in the current
        state, and that it cannot be proven that expression3 is true in
        the current state, then expression1 is inferred to be true.

        If the "with absence" clause is omitted, then expression2 is applied
        if and only if expression1 is true:

\begin{verbatim}
<expression1> implies <expression2>
\end{verbatim}

        A special case of the above statement is when expression1 is the
        constant \emph{true}. In this case, expression2 is always applied
        to the current state. The statement below:

\begin{verbatim}
always <expression2>
\end{verbatim}

        is equivalent to:

\begin{verbatim}
true implies <expression2>
\end{verbatim}

      \subsubsection{Transformation Statements}

        A transformation definition statement must be defined in the following
        syntax:

\begin{verbatim}
<trans-identifier>([<var1>[,<var2>][,...]]])
causes <post-condition-expression>
if <pre-condition-expression>
\end{verbatim}

        where:

        \begin{itemize}
          \item
            trans-identifier is the name of this transformation.
          \item
            post-condition-expression an expression that will be true in the
            resulting state after the transformation is applied.
          \item
            pre-condition-expression an expression that must be true in the
            current state before the transformation may be applied.
        \end{itemize}


        Transformation statements may also contain variables:

\begin{verbatim}
delete_write(SUBJECT, OBJECT)
causes !holds(SUBJECT, a_write, OBJECT)
if holds(SUBJECT, a_write, OBJECT)
\end{verbatim}
        this means

\begin{verbatim}
delete_write(subject1, object1)
\end{verbatim}

        and

\begin{verbatim}
delete_write(subject2, object2)
\end{verbatim}

        will cause

\begin{verbatim}
!holds(subject1, a_write, object1)
\end{verbatim}

        and

\begin{verbatim}
!holds(subject2, a_write, object2)
\end{verbatim}

        if subject1 and subject2 had write access rights to object1 and
        object2, respectively. The case where the pre-condition is an
        empty set (i.e. the transformation has no pre-condition) does not 
        have to be a special case:

\begin{verbatim}
<trans-identifier>()
causes <post-condition-expression>
\end{verbatim}

        is equivalent to:

\begin{verbatim}
<trans-identifier>()
causes <post-condition-expression>
if true
\end{verbatim}

      \subsubsection{Query Statements}

        The general form is:

\begin{verbatim}
is <policy-exp> [after <trans-ident1>([ident1[,...]])[,...]]
\end{verbatim}

        where:

        \begin{itemize}
          \item
            policy-exp is the expression that will be tested.
          \item
            trans-idents are the names of the transformations that will
            be applied in series before the query is performed.
          \item
            idents are the names of the literals that will be used in
            place of the variables used in the transformation declarations.
        \end{itemize}

    The statement will return one of the following: \emph{true}, \emph{false}
    or \emph{?}.

    \pagebreak

  \section{Translation into a Logic Program}

    \subsection{Conversion to Extended Logic Program: Flattening the States}

      Extended logic programs are \emph{flat} or stateless. The proposed
      language, however, is composed of logic facts that have a states as
      a result of the transformation property. Formally, a state represents
      a transition of facts as a result of the application of a transformation.
      As a consequence, the number of states is equal to the number of
      transformations plus 1 (the initial state, before any transformations
      are applied).

      Translating the proposed language into an extended logic program requires
      a stateless set of axioms and propositions. The first step involved in
      the translation is to reduce every atom, which is composed of two to
      three parameters, into a single proposition. This procedure, although
      does not seem necessary is to allow us to have a simplified
      representation of propositions. For example, the atoms holds(s1, a1, 
      o$_{1}$) and memb(e1, g1) can be reduced to propositions A and B,
      respectively.

      \subsubsection{Adding a State Parameter to the Atoms}

        The next step is to add a state parameter into the definition of an
        atom. This procedure will allow us to differentiate between atoms of
        the same value but on different states. For example, atom A in 
        the initial state S$_0$ can be represented as holds(A, S$_0$),
        likewise, the same atom A in state S$_1$ will be represented as
        holds(A, S$_1$).

      \subsubsection{Handling States in Transformations}

        To express transformation from one state to another in an extended
        logic program, each atom that is involved in a transformation must
        be flattened.

        Let:
  
        \begin{list}{}{}
          \item T = transformation
          \item S$^{'}$ = state before T is applied
          \item S$^{''}$ = state after T is applied
        \end{list}
  
        Then we can define the Res as the function that applies a 
        transformation onto a state:
  
        \begin{list}{}{}
          \item S$^{''}$ = Res(T, S$^{'}$)
        \end{list}
  
        Disregarding the place holder variables and a conjunction of atoms, 
        a transformation T in its simplest form:
  
        \begin{list}{}{}
          \item T causes A if B
        \end{list}
  
        Therefore, a transformation may be represented in an extended logic
        program as an implication:
 
        \begin{list}{}{}
          \item holds(A, Res(T, S)) $\leftarrow$ holds(B, S)
        \end{list}

        where S is the state before transformation T is applied.

      \subsubsection{Handling States in Constraints}

        Converting constraints into an extended logic program is somewhat
        simpler than converting transformations. Since constraints must hold
        for all states in the domain, the following constraints:

      \begin{list}{}{}
        \item A implies B with absence C
        \item A provokes B
        \item always A
      \end{list}

        can be expressed by the following implications:

        \begin{list}{}{}
          \item 
            holds(B, S) $\leftarrow$ holds(A, S) $\land$ not holds(C, S)
          \item 
            holds(B, S) $\leftarrow$ holds(A, S)
          \item 
            holds(A, S) $\leftarrow$
        \end{list}

        for all states S in the domain.

      \subsubsection{Inertial Rules}

        Intuitively, one would expect that after a transformation, every fact
        in the previous state that was not affected by the transformation
        should in fact be carried over into the next state. The following
        implications are added to ensure that this property is held:

        \begin{list}{}{}
          \item
            holds(A, Res(T, S)) $\leftarrow$ holds(A, S) $\land$ not $\lnot$ 
            holds(A, Res(T, S))
          \item 
            $\lnot$ holds(A, Res(T, S)) $\leftarrow$ $\lnot$ holds(A, S) 
            $\land$ not holds(A, Res(T, S))
        \end{list}

        $\forall$(S, T, A $\mid$ S $\in$ $\sigma$, T $\in$ $\theta$, A $\in$ 
        $\alpha$)

        where: 

        \begin{itemize}
          \item $\sigma$ = set of all states in the domain
          \item $\theta$ = set of all transformations in the domain
          \item $\alpha$ = set of all atoms in the domain
        \end{itemize}

    \subsection{Conversion to General Logic Program: Removal of Classical Negation}

      Translation to from extended logic program to general logic program 
      requires one more additional step: to remove all instances of classical 
      negation. The easiest way to achieve this is to add yet another parameter
      into each of the atoms to indicate its truth value in the classical
      negation sense. To briefly illustrate, the atoms:

      \begin{list}{}{}
        \item holds(A, S)
        \item $\lnot$ holds(A, S)
        \item not holds(A, S)
        \item not $\lnot$ holds(A, S)
      \end{list}

      can be represented as

      \begin{list}{}{}
        \item holds(A, S, T)
        \item holds(A, S, F)
        \item not holds(A, S, T)
        \item not holds(A, S, F)
      \end{list}

      where T and F are the parameters that indicate whether an atom is
      classically negated or not, respectively.

      In addition to the extra parameter, a new implication must be added
      to indicate that the atoms that differ only by their third parameter
      are complementary:

      \begin{list}{}{}
        \item false $\leftarrow$ holds(A, S, T) $\land$ holds(A, S, F)
      \end{list}

      $\forall$ (A, S $\mid$ A $\in$ $\alpha$, S $\in$ $\sigma$)

      where

      \begin{itemize}
        \item $\alpha$ = set of all atoms in the domain
        \item $\sigma$ = set of all states in the domain
      \end{itemize}

    \subsection{Example}

      The following lists a small program written in the proposed language:

      \begin{verbatim}
initially holds(s, a, o1), !holds(s, a, o2), !holds(s, a, o3);
holds(s, a, o2) implies holds(s, a, o3);
trans causes holds(s, a, o3) if !holds(s, a, o2);
      \end{verbatim}

      First we represent the atoms with simple propositions:

      \begin{list}{}{}
        \item A = holds(s, a, o$_{1}$)
        \item B = holds(s, a, o$_{2}$)
        \item C = holds(s, a, o$_{3}$)
      \end{list}

      \subsubsection{Extended Logic Program}

        \begin{list}{}{Initial State}
          \item holds(A, S$_{0}$)
          \item $\lnot$ holds(B, S$_{0}$)
          \item $\lnot$ holds(C, S$_{0}$)
        \end{list}

        \begin{list}{}{Constraint}
          \item holds(C, S$_{0}$) $\leftarrow$ holds(B, S$_{0}$)
          \item holds(C, S$_{1}$) $\leftarrow$ holds(B, S$_{1}$)
        \end{list}

        \begin{list}{}{Transformation}
          \item holds(B, S$_{1}$) $\leftarrow$ $\lnot$ holds(B, S$_{0}$)
        \end{list}

        \begin{list}{}{Inertial Rules}
          \item
            holds(A, S$_{1}$) $\leftarrow$ holds(A, S$_{0}$) $\land$ not
            $\lnot$ holds(A, S$_{1}$)
          \item
            $\lnot$ holds(A, S$_{1}$) $\leftarrow$ $\lnot$ holds(A, S$_{0}$) 
            $\land$ not holds(A, S$_{1}$)
          \item
            holds(B, S$_{1}$) $\leftarrow$ holds(B, S$_{0}$) $\land$ not
            $\lnot$ holds(B, S$_{1}$)
          \item
            $\lnot$ holds(B, S$_{1}$) $\leftarrow$ $\lnot$ holds(B, S$_{0}$) 
            $\land$ not holds(B, S$_{1}$)
          \item
            holds(C, S$_{1}$) $\leftarrow$ holds(C, S$_{0}$) $\land$ not
            $\lnot$ holds(C, S$_{1}$)
          \item
            $\lnot$ holds(C, S$_{1}$) $\leftarrow$ $\lnot$ holds(C, S$_{0}$)
            $\land$ not holds(C, S$_{1}$)
        \end{list}

      \subsubsection{General Logic Program}


        \begin{list}{}{Initial State}
          \item holds(A, S$_{0}$, t)
          \item holds(B, S$_{0}$, f)
          \item holds(C, S$_{0}$, f)
        \end{list}

        \begin{list}{}{Constraint}
          \item holds(C, S$_{0}$, t) $\leftarrow$ holds(B, S$_{0}$, t)
          \item holds(C, S$_{1}$, t) $\leftarrow$ holds(B, S$_{1}$, t)
        \end{list}

        \begin{list}{}{Transformation}
          \item holds(B, S$_{1}$, t) $\leftarrow$ holds(B, S$_{0}$, f)
        \end{list}

        \begin{list}{}{Inertial Rules}
          \item
            holds(A, S$_{1}$, t) $\leftarrow$ holds(A, S$_{0}$, t) $\land$ not
            holds(A, S$_{1}$, f)
          \item
            holds(A, S$_{1}$, f) $\leftarrow$ holds(A, S$_{0}$, f) $\land$ not
            holds(A, S$_{1}$, t)
          \item
            holds(B, S$_{1}$, t) $\leftarrow$ holds(B, S$_{0}$, t) $\land$ not
            holds(B, S$_{1}$, f)
          \item
            holds(B, S$_{1}$, f) $\leftarrow$ holds(B, S$_{0}$, f) $\land$ not
            holds(B, S$_{1}$, t)
          \item
            holds(C, S$_{1}$, t) $\leftarrow$ holds(C, S$_{0}$, t) $\land$ not
            holds(C, S$_{1}$, f)
          \item
            holds(C, S$_{1}$, f) $\leftarrow$ holds(C, S$_{0}$, f) $\land$ not
            holds(C, S$_{1}$, t)
        \end{list}

        \begin{list}{}{Complementary Rules}
          \item
            false $\leftarrow$ holds(A, S$_{0}$, t) $\land$ holds(A, S$_{0}$, f)
          \item
            false $\leftarrow$ holds(B, S$_{0}$, t) $\land$ holds(B, S$_{0}$, f)
          \item
            false $\leftarrow$ holds(C, S$_{0}$, t) $\land$ holds(C, S$_{0}$, f)
          \item
            false $\leftarrow$ holds(A, S$_{1}$, t) $\land$ holds(A, S$_{1}$, f)
          \item
            false $\leftarrow$ holds(B, S$_{1}$, t) $\land$ holds(B, S$_{1}$, f)
          \item
            false $\leftarrow$ holds(C, S$_{1}$, t) $\land$ holds(C, S$_{1}$, f)
        \end{list}

    \pagebreak

  \section{System Structure}

    \subsection{Parser1: Epilog}

      This program was specifically designed to be a quick and limited 
      parser/logic engine for the language. Because it is also meant to
      be small and simple, the program supports only a subset of the
      proposed language: without support for default propositions. However,
      since the program's language can still express transformations and query
      interpretations, may still be used as an authorisation engine for simple
      applications.

      \subsubsection{Data Structures}

        Identifiers are stored into a symbol table as a list of strings, each
        of which are allocated memory only once. This provides a very
        efficient way to manipulate the identifiers since only its pointer
        reference are passed around (safely).

        Atoms are implemented as a union of a holds record, a member record,
        a subset record and a constant record (true and false). Expressions
        are simply lists of atoms, since all expressions are really
        conjunctions of atoms. The actual knowledge base is composed of:

        \begin{itemize}
          \item
            Symbol table to hold the identifiers.
          \item
            Initial state, which is just an expression.
          \item
            Table of transformations, with each entry having a list of
            variable place holders, a precondition expression and a
            postcondition expression.
          \item
            Table of queries
        \end{itemize}

      \subsubsection{Operations}

        The following is a brief outline of the programs execution cycle:

        \begin{itemize}
          \item
            Input authorisation program is parsed.
          \item
            While the parser is processing the input program, all the
            necessary information are stored in sequence into the knowledge
            base: declared identifiers, initial state, transformation
            definitions and query propositions.
          \item
            Just after a query has parsed and processed, the parser then
            looks up the transformation table to get a reference to all
            transformations relevant to query that was just parsed.
          \item
            When the transformation entries are retrieved, they are then
            \emph{grounded} to replace any instances of variables with
            the corresponding identifier that was given in the query.
          \item
            After this, the transformations are then applied sequentially
            into a copy of the knowledge base, beginning with the initial
            state. Before a transformation's postcondition expression is added
            into the current state, the precondition expression is first
            checked against the current state.
          \item
            If everything went well the program should end up with a state,
            or more accurately, a set of atoms and expressions that holds
            true in the final state. The query expression is then check
            against this final state and an appropriate answer is retured:
            true, false or unknown.
            
        \end{itemize}

    \subsection{Parser2: Vlad}

      Unlike Epilog, this implementations accepts the full authorisation
      language that was proposed. Because it must support default logic
      constraints given in an authorisation logic program, the parser must
      perform various translations first before handing over the contents
      of the knowledge base to the logic engine.

      The biggest difference between the Epilog implementation and this one
      is the fact that this implementation's sole purpose is to translate
      the authorisation language into a general logic program. Once translated,
      another mechanism, most likely an external logic engine will perform
      the logic operations.

      \subsubsection{Data Structures}

        The structures used to hold data for this implementation is somewhat
        similar to that of Epilog, with the exception of the addition table
        to store constraints that was not present in the Epilog implementation.

        Another major, but subtle difference is the way atoms are stored. In 
        the Epilog implmentation, atoms are stored in memory as records of
        identfiers and a truth value. This implementations, however, offers
        a more robust and efficient method of storing atoms: conceptually,
        instead of in memory. Each atom is never actaully stored in physical
        memory but is really just a number. This number corresponds to the
        unique combination of the indices of the identifiers that it contains.

      \subsubsection{Operations}

        As stated above, the goal of this implementations is to translate
        the authorisation language into a simple general logic program
        so that its output could be passed to a logic engine. The actual
        procedure that this implementation uses for conversion to general
        logic program is outlined in the previous section.

    \subsection{Application Program}

      The application that will be developed for this project is a website 
      access control system. Authorisation control for websites is not 
      something new. Most web servers are run on top of a Unix or Unix-like
      filesystem that provides some basic authorisation scheme by directly
      manipulating file-access permissions. Some web servers such as Apache
      provide a much better authorisation and authentication scheme with
      the htaccess mechanism.

      The web authorisation system will allow the website administrator to
      define high-level abstract objects and subjects from the different web
      pages in his/her site and the users that will access the site. For
      example a web administrator might create an object called Accounting
      Site, which should only be accessible by a group of users called
      Accountants. The policies will be written and evaluated in the new
      language. The transformation and conflict resolution will be very
      helpful in situations where the administrator decides to change
      the policies.

      The following description highlights the operations of the system. 
      An administrator feeds the policy base with the authorisation rules
      and constraints using the new language. It is then up to the policy
      base to resolve any conflicts and inconsistencies that might arise
      when the administrator changes a policy. The policy base will also
      work closely with the enforcement agent, who will send a query to
      the policy base every time it receives a request from a user. When
      this happens, the policy base will then evaluate the query and return
      Granted or Denied depending on whether there is a policy covering
      that specific query. If the enforcement agent receives a granted 
      reply, it will grant the user making the request access the site.
      A denied reply would cause it to revoke the request.

    \pagebreak

  \section{Conclusion}

    \pagebreak

  \begin{thebibliography}{}
    \bibitem{BV1}Y. Bai and V. Varadharajan, \emph{On Transformation of Authorization Policies}. School of Computing and Information Technology, University of Western Sydney, 1997.
    \bibitem{BV2}Y. Bai and V. Varadharajan, \emph{On Sequence of Authorization Policy Transformations}. School of Computing and Information Technology, University of Western Sydney, 1997.
    \bibitem{GV}M. Gelfond and V. Lifschitz, \emph{Classical Negation in Logic Programs and Disjunctive Databases}. New Generation Computing, 1991.
    \bibitem{RN}S. Russell and P. Norvig, \emph{Artificial Intelligence - A Modern Approach}. Prentice Hall, 1995.
    \bibitem{S}P. Simons, \emph{Efficient Implementation of the Stable Model Semantics for Normal Logic Programs}. Helsinki University of Technology, Series A Research Reports, No. 35, 1995.
    \bibitem{WL}.Y.C. Woo and S.S. Lam, \emph{Authorization in Distributed systems: A Formal Approach}. Proceedings of IEEE Symposium on Research in Security and Privacy, 1992.
  \end{thebibliography}
\end{document}

