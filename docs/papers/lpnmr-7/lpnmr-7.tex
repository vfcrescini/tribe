\documentclass{llncs}

\pagestyle{plain}

\usepackage{epsfig}
\usepackage{changebar}


\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of PolicyUpdater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we propose \emph{PolicyUpdater}\footnotemark -- an access 
    control system that provides policy evaluations as well as dynamic policy 
    updates. These are achieved by the use of a logic-based language $\cal{L}$
    to represent the underlying access control policies, constraints and update
    propositions. The system performs general authrorization query evaluations
    and conditional policy updates by first translating the language $\cal{L}$
    to a normal logic program in a form suitable for evaluation using the
    \emph{Stable Model} semantics. Queries can then be evaulated from the
    models generated by the \emph{Smodels}\footnotemark program.

    \footnotetext[1]{Homepage at http://www.cit.uws.edu.au/~jcrescin/projects/PolicyUpdater.}
    \footnotetext[2]{Smodels by Patrik Simons (http://www.tcs.hut.fi/Software/smodels).}
  \end{abstract}

  \section{Introduction}

    The simplest and most straight forward access control mechanism is the
    \emph{Access Control Matrix} where columns represent subjects, rows
    represent objects and each cell contains the access-rights or priviledges
    of a subject over a particular object. However, flexibility and scalability
    issues arise when such method is used on real-world applications.

    A more effective paradigm of access control systems is the logic-based
    approach. In this approach, instead of explicitly defining all
    access-rights of all subjects for all ojects in a domain, a set of logical
    facts, rules and contraints are used to define the policy base. 

    Recent advances in the field have produced a number of different approaches
    to logic-based access control systems. Bertino, et. al. \cite{BER} proposed
    such a system based on ordered logic. Jajodia, et. al. \cite{JAJ}, on the 
    other hand, proposed a general access control framework that features
    handling of multiple policies. Yet another significant work is the
    system proposed by Bai and Varadharajan \cite{BAI}. Their system's key
    characteristic is the ability to dynamically update the otherwise static
    policy base. These systems, effective as they are, lack the details
    necessary to address the issues involved in the implementation of such
    a system. PolicyUpdater, on the other hand, is a fully-implemented
    logic-based access control system.

  \section{Language $\cal{L}$}

    The language $\cal{L}$ is a first-order logic language that provides the
    following:  (1) a logic-based representation of the policy base; (2) a
    means to conditionally and dynamically update the existing policy base;
    and (3) a mechanism by which queries may be evaluated from the updated
    policy base.

    \emph{Identifiers} are elements of the language $\cal{L}$ used to represent
    an entity (subject, access-right, or object), a group of entities or an
    update. Formally, an identifier is defined as:

    \begin{verbatim}[a-zA-Z]([a-zA-Z0-9_])*\end{verbatim}

    \emph{Atoms} are the basic logical units that make up the policy base.
    The Holds atom denotes a binding of a subject, an object and the
    access-right of that subject for that object. The Membership atom binds
    a singular entity to a group entity of the same type. Similarly, a Subset
    atom shows the relationship between a group and its supergroup. The
    negation of an atom is represented in $\cal{L}$ by prepending the 
    exclamation symbol \emph{!} to the atom.

    \begin{verbatim}[!]holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
[!]memb(<singular-identifier>, <group-identifier>)
[!]subset(<group-identifier>, <group-identifier>)\end{verbatim}

    \emph{Expressions} are atoms or conjunctions of atoms linked together by
    the double ampersand characters \&\&.

    \begin{verbatim}atom1 [&& atom2 [&& ...]]\end{verbatim}

    \emph{Indetifier Declaration.} Entity and group identifiers must first be
    declared by the following statement before they appear anywhere in the
    language $\cal{L}$:

    \begin{verbatim}ident {sub|acc|obj}[-grp] <identifier>;\end{verbatim}

    \emph{Initial State Definition.} Initial state expressions may be defined
    to represent the inital facts of the policy base before any policy update
    is applied.

    \begin{verbatim}initially <expression>;\end{verbatim}

    \emph{Constraint Definition.} Constraints are the logical rules that must
    hold in the initial state and any other state of the policy base after
    any policy update. The syntax below states that exp1 must hold if exp2 is 
    true and that there is no evidence that exp3 is true.

    \begin{verbatim}always exp1 [implied by exp2 [with absence exp3]];\end{verbatim}

    \emph{Policy Update Definition.} The following policy update definition
    statement defines a policy update which, when applied, will generate a new
    state by applying exp1 to the current state if and only if exp2 is true in
    the current state. The variable parameters that may occur in any of the
    expressions allow identifiers to be set dynamically when the update is
    applied.

    \begin{verbatim}<update-identifier>([<var1>[,...]]) causes exp1 if exp2;\end{verbatim}

    \emph{Sequence Manipulation Directives.} The current state of the policy
    base (the state in which queries will be evaluated) is derived by applying
    the updates that are appended into the policy update sequence list. Below
    is the syntax for adding a defined policy update into the sequence.

    \begin{verbatim}seq add <update-identifier>([<var1>[,...]]);\end{verbatim}

    Similarly, to remove the n'th update from the sequence:

    \begin{verbatim}seq del <n>;\end{verbatim}

    For the sake of completeness, the language $\cal{L}$ also has provisions
    for listing the policy updates in the sequence:

    \begin{verbatim}seq list;\end{verbatim}

    \emph{Query Directive.} The policy base may be given an expression to be
    queried. Queries are evaluated after all the policy updates in the
    sequence and all the defined constraints have been applied. Query
    directives are always answered by either \emph{true}, \emph{false}, or
    \emph{unknown}.

    \begin{verbatim}query expression;\end{verbatim}

  \section{Implementation: Translating Language $\cal{L}$ to Normal Logic Program}

    \emph{Integration of Set Theory.} Since entities in language $\cal{L}$ may 
    be singular or groups, the following constraints must be applied to ensure
    that set theory holds.

    Rule 1 ensures that each member M inherits all the properties P of group G 
    if M is an element of group G. Similarly, in Rule 2, groups inherit all
    properties of its supergroup. Lastly, Rule 3 preserves the transitive
    property of subsets: If S1 is a subset of S2 and S2 is a subset of S3,
    then S1 is a subset of S3.

    \begin{enumerate}
      \item[1]
        holds(M, P) $\leftarrow$ holds(G, P) $\land$ M $\in$ G
      \item[2]
        holds(S1, P) $\leftarrow$ holds(S2, P) $\land$ S1 $\subseteq$ S2
      \item[3]
        S1 $\subseteq$ S3 $\leftarrow$ S1 $\subseteq$ S2 $\land$ S2
        $\subseteq$ S3
    \end{enumerate}

    \emph{State Handling Mechanism.} An undesirable side-effect of providing
    dynamic update capabilities to language $\cal{L}$ is the presence of
    states in the policy base. To translate the language into an extended
    logic program, the states need to be flattened to produce a stateless
    policy base. This flattening procedure can easily be achieved by treating
    the state as a property of each atom. 

    Rule 4 shows that initial state expressions are easily translated since
    the additional state property is fixed to the initial state 0. The atom
    holds(sub, acc, obj) in the initial state is translated to holds(sub,
    acc, obj, 0).

    As with the initial state expressions, Rule 5 states that every atom in a
    constraint rule will be given a new state property. However, since
    constraint rules apply to all states in the policy base, an instance of
    each constraint rules must be copied for every state.

    For the policy update Rules 6, 7 and 8, the \emph{Res} function returns
    the resulting state after update U is applied to state S. Rules 7 and
    8 preserves the inertial property of policy updates that require all atoms
    that are not affected by the update to be carried over to the next state.

    \begin{enumerate}
      \item[4]
        For all initial state atoms A, holds(A, 0).
      \item[5]
        For all constraints of the form "Always A implied by B with
        absence C", for all states S, holds(A, S) $\leftarrow$ holds(B, S)
        $\land$ not holds(C, S).
      \item[6]
        Given an update "U causes A if B", holds(A, Res(U, S)) $\leftarrow$
        holds(B, S).
      \item[7]
        Given an update "U causes A if B", holds(A, Res(U, S)) $\leftarrow$
        holds(A, S) $\land$ not $\lnot$ holds(A, Res(U, S)).
      \item[8]
        Given an update "U causes A if B", $\lnot$ holds(A, Res(U, S))
        $\leftarrow$ $\lnot$ holds(A, S) $\land$ not holds(A, Res(U, S)).
    \end{enumerate}

    \emph{Removal of Classical Negation.} At this stage, the program is an
    extended logic program. The translation from extended logic program to
    normal logic program requires one additional step: to remove classical
    negation ($\lnot$). This can easily be achieved by replacing instances of
    atoms that are classically negated by a new and unique positive atom. To do
    this, a \emph{truth} attribute (\emph{true} or \emph{false}) can be added
    to atoms to indicate whether an atom is classically negated or not.

    It is not difficult to see that a conflict will occur when two atoms that
    differ only by their truth attributes are both true. To maintain the
    integrity of the policy base, the following rule must be added for all
    atoms A in all states S:

    \begin{enumerate}
      \item[9]
        FALSE $\leftarrow$ holds(A, S, true) $\land$ holds(A, S, false)
    \end{enumerate}

  \section{Conclusion}

    The expressiveness of language $\cal{L}$ and the effectiveness of the
    implementation can best be demonstrated by a web server authorization
    application of PolicyUpdater. The application serves as an authorization
    module for the popular web server, \emph{Apache}\footnotemark. Although the
    PolicyUpdater module has not yet reached the full functionality provided
    by Apache's built-in authorization module \emph{mod\_auth}, it does provide
    a flexible logic-based authorization system which is capable of dynamic and
    conditional updates.

    The PolicyUpdater module works by intercepting all authenticated HTTP
    requests made to the web server. Users or groups of users directly
    correspond to the language $\cal{L}$ subjects, HTTP request methods
    (i.e. GET, POST, etc.) are the access-rights, and files, directories
    and other resources in the document root are the objects. These entities
    plus any initial facts, constraints and update propositions in the 
    policy base make up the domain of language $\cal{L}$.

    Figure \ref{fig-1} shows how the PolicyUpdate module work within a typical
    HTTP request. (1) User S makes a HTTP request A for file O and is
    authenticated by Apache through the Basic HTTP Authentication Scheme. (2)
    Once properly authenticated, Apache passes the request tuple {S, A, O} to
    the PolicyUpdater module. (3) PolicyUpdater then queries the policy base
    to verify the atom holds(S, A, O) and returns a reply (4) back to Apache.
    If the request is allowed, as determined by the module in the policy base,
    Apache accepts and honors the request A to the file O (5) and sends the
    results back to the user (6). Optionally, an Administrator, once properly
    authenticated can dynamically update the policy (7) by altering the
    update sequence in the policy base.

    \footnotetext{Apache Web Server (http://www.apache.org).}

    \begin{figure}[h]
      \begin{center}
        \epsfig{file=fig1.eps}
        \caption{PolicyUpdater module for Apache.}
        \label{fig-1}
      \end{center}
    \end{figure}

  \begin{thebibliography}{5}
    \bibitem{BAI}
      Bai, Y., Varadharajan, V.,
      On Formal Languages for Sequences of Authorization Transformations.
      In \emph{Lecture Notes in Computer Science},
      Vol. 1698,
      pp 375-384.
      Springer-Verlag, 1999

    \bibitem{BER}
      Bertino, E., Buccafurri, F., Ferrari, E., Rullo, P.,
      A Logic-based Approach for Enforcing Access Control.
      \emph{Journal of Computer Security},
      Vol. 8, No. 2-3,
      pp 109-140.
      IOS Press, 2000

    \bibitem{JAJ}
      Jajodia, S., Samarati, P., Sapino, M. L., Subrahmanian, V. S.,
      Flexible Support for Multiple Access Control Policies.
      In \emph{ACM Transactions on Database Systems},
      Vol. 29, No. 2,
      pp 214-260.
      ACM, 2001
  \end{thebibliography}

\end{document}
