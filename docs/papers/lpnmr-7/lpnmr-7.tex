\documentclass{llncs}

\pagestyle{plain}

\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of Policy Updater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we propose an access control system, \emph{Policy Updater},
    that provides policy evaluation as well as dynamic policy manipulation.
    This is achieved by the use of the proposed logic-based language L to
    represent the access control policies. As the language L is logic-based,
    policy manipulation is achieved by adding or removing atoms and constraints
    that make up the policy base. The policy base can then be translated into a
    normal logic program and then by using the \emph{Stable Models} semantics,
    authorization queries can be evaluated.

    [needs to be edited]
  \end{abstract}

  \section{Introduction}
    [text]

  \section{Language L}
    \subsection{Language Syntax}

      Every statement must end with the semicolon ; terminator. Comments
      may appear between the C-style comment symbols /* and */.

      \emph{Identifiers} are used to represent an entity (subject, access
      right, object), a group of entities or a transformation.

      \begin{verbatim}[a-zA-Z]([a-zA-Z0-9_])*\end{verbatim}

      Entity/group identifiers must first be defined before they appear
      anywhere in the policy base.

      \begin{verbatim}ident {sub|acc|obj}[-grp] <identifier>;\end{verbatim}

      \emph{Atoms} are the basic logical units that make up the policy base.
      The Holds atom signifies a binding of a subject, an object and the
      access right of that subject for that object. The Membership atom binds
      a singular entity to a group entity of the same type. Similarly, a Subset
      atom shows the relationship between a group and its supergroup. The
      negation of an atom is represented in L by prepending the symbol ! to the
      atom.

      \begin{verbatim}[!]holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
[!]memb(<singular-identifier>, <group-identifier>)
[!]subset(<group-identifier>, <group-identifier>)\end{verbatim}

      \emph{Expressions} are atoms or conjunctions of atoms linked together by
      the double ampersand characters \&\&.

      \begin{verbatim}atom1 [&& atom2 [&& ...]]\end{verbatim}

      \emph{Initial State Definition.} This feature of Language L allows the
      initial facts of the policy base to be set.

      \begin{verbatim}initially <expression>;\end{verbatim}

      \emph{Constraint Definition.} Constraints are the logical rules that must
      hold in the initial state and any other state of the policy base after
      any policy update or transformation. The syntax below states that exp1
      must hold if exp2 is true and that there is no evidence that exp3 is
      true.

      \begin{verbatim}always exp1 [implied by exp2 [with absence exp3]];\end{verbatim}

      \emph{Policy Manipulation.} A special feature of the Language L allows
      the policies to be dynamically updated through the process of
      transformation. The following transformation definition syntax generates
      a new state by applying exp1 to the current state if and only if exp2 is
      true in the current state.

      \begin{verbatim}<update-identifier>(<var1>[,...]) causes exp1 if exp2;\end{verbatim}

      The current state of the policy base (the state in which queries will be
      evaluated) is derived by applying the transformations that are added into
      the transformation sequence. Below is the syntax for adding a
      transformation into the sequence.

      \begin{verbatim}seq add <update-identifier>(<var1>[,...]);\end{verbatim}

      Similarly, to remove the n'th transformation from the sequence:

      \begin{verbatim}seq del <n>;\end{verbatim}

      For the sake of completeness, the Language L also has provisions to list
      the transformations in the sequence.

      \begin{verbatim}seq list;\end{verbatim}

      \emph{Query Directive.} The policy base may be given an expression to be
      queried. Queries are evaluated after after all transformations in the
      sequence and all constraints have been applied.

      \begin{verbatim}query expression;\end{verbatim}

  \section{Implementation}

    \subsection{Language L to Extended Logic Program}

      \subsubsection{Integration of Set Theory}

        \begin{itemize}
          \item
            Inheritance Rules for Members of Groups

            holds(M, P) $\leftarrow$ holds(G, P) $\land$ M $\in$ G
          \item
            Inheritance Rules for Subgroups

            holds(S1, P) $\leftarrow$ holds(S2, P) $\land$ S1 $\subseteq$ S2
          \item
            Transitivity Rule

            S1 $\subseteq$ S3 $\leftarrow$ S1 $\subseteq$ S2 $\land$ S2 $\subseteq$ S3
        \end{itemize}

      \subsubsection{State Handling Mechanism}

        \begin{itemize}
          \item
            Initial State
          \item
            Constraints
          \item
            Transformations
        \end{itemize}

    \subsection{Extended Logic Program to Normal Logic Program}

      \subsubsection{Removal of Classical Negation.}
        A \emph{truth} attribute can be added to atoms to indicate whether
        an atom is classically negated or not.

        \vspace{0.65cm}

        \begin{table}
          \begin{tabular}{ll}
            \hline \\
            ELP & NLP \\
            \hline \\
            holds(A, S) & holds(A, S, T) \\
            $\lnot$ holds(A, S) & holds(A, S, F) \\
            not holds(A, S) & not holds(A, S, T) \\
            not $\lnot$ holds(A, S) & not holds(A, S, F) \\
            \hline
          \end{tabular}
        \end{table}

        FALSE $\leftarrow$ holds(A, S, T) $\land$ holds(A, S, F)

  \section{Conclusion}

  \begin{thebibliography}{5}

    \bibitem{yan:plp}
      Zhang and N.Y. Foo,
      Answer sets for prioritized logic programs.
      In {\em Proceedings of the 1997 International Logic Programming
      Symposium (ILPS'97)},
      pp 69-83. 
      MIT Press, 1997

  \end{thebibliography}

\end{document}

