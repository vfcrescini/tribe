\documentclass{llncs}

\usepackage{epsfig}
\usepackage{changebar}

\pagestyle{plain}

\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of PolicyUpdater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we propose \emph{PolicyUpdater}\footnotemark -- an access 
    control system that provides policy evaluations as well as dynamic policy 
    updates. These are achieved by the use of a logic-based language $\cal{L}$
    to represent the underlying access control policies, constraints and update
    propositions. The system performs general authrorization query evaluations
    and conditional policy updates by first translating the language $\cal{L}$
    to a normal logic program in a form suitable for evaluation using the
    \emph{Stable Model} semantics. Queries can then be evaulated from the
    models generated by the \emph{Smodels}\footnotemark program.

    \footnotetext[1]{Homepage at http://www.cit.uws.edu.au/~jcrescin/projects/PolicyUpdater.}
    \footnotetext[2]{Smodels by Patrik Simons (http://www.tcs.hut.fi/Software/smodels).}
  \end{abstract}

  \section{Introduction}

    The simplest and most straight forward access control mechanism is the
    \emph{Access Control Matrix} where columns represent subjects, rows
    represent objects and each cell contains the access-rights or priviledges
    of a subject over a particular object. However, flexibility and scalability
    issues arise when such method is used on real-world applications.

    A more effective paradigm of access control systems is the logic-based
    approach. In this approach, instead of explicitly defining all
    access-rights of all subjects for all ojects in a domain, a set of logical
    facts, rules and contraints are used to define the policy base. 

    Recent advances in the field have produced a number of different approaches
    to logic-based access control systems. Bertino, et. al. \cite{BER} proposed
    such a system based on ordered logic. Jajodia, et. al. \cite{JAJ}, on the 
    other hand, proposed a general access control framework that features
    handling of multiple policies. Yet another significant work is the
    system proposed by Bai and Varadharajan \cite{BAI}. Their system's key
    characteristic is the ability to dynamically update the otherwise static
    policy base. These systems, effective as they are, lack the details
    necessary to address the issues involved in the implementation of such
    a system. PolicyUpdater, on the other hand, is a fully-implemented
    logic-based access control system.

  \section{Language $\cal{L}$}

    The language $\cal{L}$ is a first-order logic language that provides the
    following:  (1) a logic-based representation of the policy base; (2) a
    means to conditionally and dynamically update the existing policy base;
    and (3) a mechanism by which queries may be evaluated from the updated
    policy base.

    \emph{Identifiers} are elements of the language $\cal{L}$ used to represent
    an entity (subject, access-right, or object), a group of entities or an
    update. Formally, an identifier is defined as:

    \begin{verbatim}[a-zA-Z]([a-zA-Z0-9_])*\end{verbatim}

    \emph{Atoms} are the basic logical units that make up the policy base.
    The Holds atom denotes a binding of a subject, an object and the
    access-right of that subject for that object. The Membership atom binds
    a singular entity to a group entity of the same type. Similarly, a Subset
    atom shows the relationship between a group and its supergroup. The
    negation of an atom is represented in $\cal{L}$ by prepending the 
    exclamation symbol \emph{!} to the atom.

    \begin{verbatim}[!]holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
[!]memb(<singular-identifier>, <group-identifier>)
[!]subset(<group-identifier>, <group-identifier>)\end{verbatim}

    \emph{Expressions} are atoms or conjunctions of atoms linked together by
    the double ampersand characters \&\&.

    \begin{verbatim}atom1 [&& atom2 [&& ...]]\end{verbatim}

    \emph{Indetifier Declaration.} Entity and group identifiers must first be
    declared by the following statement before they appear anywhere in the
    language $\cal{L}$:

    \begin{verbatim}ident {sub|acc|obj}[-grp] <identifier>;\end{verbatim}

    \emph{Initial State Definition.} Initial state expressions may be defined
    to represent the inital facts of the policy base before any policy update
    is applied.

    \begin{verbatim}initially <expression>;\end{verbatim}

    \emph{Constraint Definition.} Constraints are the logical rules that must
    hold in the initial state and any other state of the policy base after
    any policy update. The syntax below states that exp1 must hold if exp2 is 
    true and that there is no evidence that exp3 is true.

    \begin{verbatim}always exp1 [implied by exp2 [with absence exp3]];\end{verbatim}

    \emph{Policy Update Definition.} The following policy update definition
    statement defines a policy update which, when applied, will generate a new
    state by applying exp1 to the current state if and only if exp2 is true in
    the current state. The variable parameters that may occur in any of the
    expressions allow identifiers to be set dynamically when the update is
    applied.

    \begin{verbatim}<update-identifier>([<var1>[,...]]) causes exp1 if exp2;\end{verbatim}

    \emph{Sequence Manipulation Directives.} The current state of the policy
    base (the state in which queries will be evaluated) is derived by applying
    the updates that are appended into the policy update sequence list. Below
    is the syntax for adding a defined policy update into the sequence.

    \begin{verbatim}seq add <update-identifier>([<var1>[,...]]);\end{verbatim}

    Similarly, to remove the n'th update from the sequence:

    \begin{verbatim}seq del <n>;\end{verbatim}

    For the sake of completeness, the language $\cal{L}$ also has provisions
    for listing the policy updates in the sequence:

    \begin{verbatim}seq list;\end{verbatim}

    \emph{Query Directive.} The policy base may be given an expression to be
    queried. Queries are evaluated after all the policy updates in the
    sequence and all the defined constraints have been applied. Query
    directives are always answered by either \emph{true}, \emph{false}, or
    \emph{unknown}.

    \begin{verbatim}query expression;\end{verbatim}

  \section{Implementation}

    \subsection{Translating Language $\cal{L}$ to Extended Logic Program}

      \subsubsection{Integration of Set Theory.}

        Since entities in language $\cal{L}$ may be singular or groups,
        the following constraints must be applied to ensure that set theory
        holds.

        \emph{Inheritance Rules for Members of Groups.} The rule below must
        ensures that each member M inherits all the properties P of group G if
        M is an element of group G.

        \begin{quote}
          holds(M, P) $\leftarrow$ holds(G, P) $\land$ M $\in$ G
        \end{quote}

        \emph{Inheritance Rules for Subgroups.} Similarly, groups inherit all
        properties of its supergroup.

        \begin{quote}
          holds(S1, P) $\leftarrow$ holds(S2, P) $\land$ S1 $\subseteq$ S2
        \end{quote}

        \emph{Transitivity Rule.} If S1 is a subset of S2 and S2 is a subset
        of S3, then S1 is a subset of S3.

        \begin{quote}
          S1 $\subseteq$ S3 $\leftarrow$ S1 $\subseteq$ S2 $\land$ S2
          $\subseteq$ S3
        \end{quote}

      \subsubsection{State Handling Mechanism.}

        An undesirable side-effect of providing dynamic update capabilities to
        language $\cal{L}$ is the presence of states in the policy base. To
        translate the language into an extended logic program, the states need
        to be flattened to produce a stateless policy base. This flattening
        procedure can easily be achieved by treating the state as a property
        of each atom. 

        \emph{Initial State.} Initial state expressions are the easiest to
        translate since the additional state property is fixed to the initial
        state 0. The atom holds(sub, acc, obj) in the initial state is
        translated to holds(sub, acc, obj, 0).

        \begin{quote}
          $\forall$ A $\in$ \{initial state atoms\}, holds(A, 0)
        \end{quote}

        \emph{Constraint Rules.} As with the initial state expressions, every
        atom in every constraint rule will be given a new state property.
        However, since constraint rules apply to all states in the policy
        base, an instance of each constraint rules must be copied for every
        state. Constraints of the form "A implied by B with absence C" is
        translated to:

        \begin{quote}
          $\forall$ S $\in$ \{all states\},
          holds(A, S) $\leftarrow$ holds(B, S) not holds(C, S)
        \end{quote}

        \emph{Policy Updates.} Given the most basic form of a policy update,
        "U causes A if B", an update U, a state S before update U is applied,
        and a function Res that returns the state after update U is applied
        to state S:

        \begin{quote}
          holds(A, Res(U, S)) $\leftarrow$ holds(B, S)
        \end{quote}
 
        In addition to the above rule, a pair of rules are needed to preserve
        the intertial property of policy updates that require all atoms that
        are not affected by the update to be carried over to the next state.

        \begin{quote}
          holds(A, Res(U, S)) $\leftarrow$ holds(A, S) $\land$ not $\lnot$
          holds(A, Res(U, S))
        \end{quote}
        \begin{quote}
          $\lnot$ holds(A, Res(U, S)) $\leftarrow$ $\lnot$ holds(A, S) $\land$
          not holds(A, Res(U, S))
        \end{quote}

        where U is the update, S is the state before update U is applied, and 
        Res is a function that returns the state after update U is applied to
        state S, for all atoms A in the domain.

    \subsection{Translating the Extended Logic Program to Normal Logic Program}

      \subsubsection{Removal of Classical Negation.}

        The translation from extended logic program to normal logic program
        requires one additional step: to remove classical negation ($\lnot$).
        This can easily be achieved by replacing instances of atoms that are
        classically negated by a new and unique positive atom. To do this,
        a \emph{truth} attribute (\emph{true} or \emph{false}) can be added to
        atoms to indicate whether an atom is classically negated or not.

        It is not difficult to see that a conflict will occur when two atoms
        that differ only by their truth attributes are both true. To maintain
        the integrity of the policy base, the following rule must be added 
        for all atoms A in all states S:

        \begin{quote}
          FALSE $\leftarrow$ holds(A, S, true) $\land$ holds(A, S, false)
        \end{quote}

  \section{Conclusion}

    The expressiveness of language $\cal{L}$ and the effectiveness of the
    implementation can best be demonstrated by a web server authorization
    application of PolicyUpdater. The application serves as an authorization
    module for the popular web server, \emph{Apache}\footnotemark. Although the
    PolicyUpdater module has not yet reached the full functionality provided
    by Apache's built-in authorization module \emph{mod\_auth}, it does provide
    a flexible logic-based authorization system which is capable of dynamic and
    conditional updates.

    The PolicyUpdater module works by intercepting all authenticated HTTP
    requests made to the web server. Users or groups of users directly
    correspond to the language $\cal{L}$ subjects, HTTP request methods
    (i.e. GET, POST, etc.) are the access-rights, and files, directories
    and other resources in the document root are the objects. These entities
    plus any initial facts, constraints and update propositions in the 
    policy base make up the domain of language $\cal{L}$.

    Figure 1 shows how the PolicyUpdate module work within a typical HTTP
    request. (1) User S makes a HTTP request A for file O and is authenticated
    by Apache through the Basic HTTP Authentication Scheme. (2) Once properly
    authenticated, Apache passes the request tuple {S, A, O} to the
    PolicyUpdater module. (3) PolicyUpdater then queries the policy base 
    to verify the atom holds(S, A, O) and returns a reply (4) back to Apache.
    If the request is allowed, as determined by the module in the policy base,
    Apache accepts and honors the request A to the file O (5) and sends the
    results back to the user (6). Optionally, an Administrator, once properly
    authenticated can dynamically update the policy (7) by altering the
    update sequence in the policy base.

    \footnotetext{Apache Web Server (http://www.apache.org).}

    \epsfig{file=fig1.eps}

  \begin{thebibliography}{5}
    \bibitem{BAI}
      Bai, Y., Varadharajan, V.,
      On Formal Languages for Sequences of Authorization Transformations.
      In \emph{Lecture Notes in Computer Science},
      Vol. 1698,
      pp 375-384.
      Springer-Verlag, 1999

    \bibitem{BER}
      Bertino, E., Buccafurri, F., Ferrari, E., Rullo, P.,
      A Logic-based Approach for Enforcing Access Control.
      \emph{Journal of Computer Security},
      Vol. 8, No. 2-3,
      pp 109-140.
      IOS Press, 2000

    \bibitem{JAJ}
      Jajodia, S., Samarati, P., Sapino, M. L., Subrahmanian, V. S.,
      Flexible Support for Multiple Access Control Policies.
      In \emph{ACM Transactions on Database Systems},
      Vol. 29, No. 2,
      pp 214-260.
      ACM, 2001
  \end{thebibliography}

\end{document}
