\documentclass{llncs}

\pagestyle{plain}

\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of PolicyUpdater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we propose \emph{PolicyUpdater} -- an access control system
    that provides policy evaluations as well as dynamic policy updates.
    These are achieved by the use of a logic-based language $\cal{L}$ to
    represent the underlying access control policies, constraints and update
    propositions. The system performs general authrorization query evaluations
    and conditional policy updates by first translating the language $\cal{L}$
    to a normal logic program in a form suitable for evaluation using the
    \emph{Stable Model} semantics. Queries can then be evaulated from the
    models generated by the \emph{Smodels}\footnotemark program.

    \footnotetext{Smodels by Patrik Simons (http://www.tcs.hut.fi/Software/smodels)}
  \end{abstract}

  \section{Introduction}
    [insert text]

    \pagebreak

  \section{Language $\cal{L}$}

    The language $\cal{L}$ is a first-order logic language that provides the
    following:  (1) a logic-based representation of the policy base; (2) a
    means to conditionally and dynamically update the existing policy base;
    and (3) a mechanism by which queries may be evaluated from the updated
    policy base.

    \emph{Identifiers} are elements of the language $\cal{L}$ used to represent
    an entity (subject, access-right, or object), a group of entities or an
    update. Formally, an identifier is defined as:

    \begin{verbatim}[a-zA-Z]([a-zA-Z0-9_])*\end{verbatim}

    \emph{Atoms} are the basic logical units that make up the policy base.
    The Holds atom denotes a binding of a subject, an object and the
    access-right of that subject for that object. The Membership atom binds
    a singular entity to a group entity of the same type. Similarly, a Subset
    atom shows the relationship between a group and its supergroup. The
    negation of an atom is represented in $\cal{L}$ by prepending the 
    exclamation symbol \emph{!} to the atom.

    \begin{verbatim}[!]holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
[!]memb(<singular-identifier>, <group-identifier>)
[!]subset(<group-identifier>, <group-identifier>)\end{verbatim}

    \emph{Expressions} are atoms or conjunctions of atoms linked together by
    the double ampersand characters \&\&.

    \begin{verbatim}atom1 [&& atom2 [&& ...]]\end{verbatim}

    \emph{Indetifier Declaration.} Entity and group identifiers must first be
    declared by the following statement before they appear anywhere in the
    language $\cal{L}$:

    \begin{verbatim}ident {sub|acc|obj}[-grp] <identifier>;\end{verbatim}

    \emph{Initial State Definition.} Initial state expressions may be defined
    to represent the inital facts of the policy base before any policy update
    is applied.

    \begin{verbatim}initially <expression>;\end{verbatim}

    \emph{Constraint Definition.} Constraints are the logical rules that must
    hold in the initial state and any other state of the policy base after
    any policy update. The syntax below states that exp1 must hold if exp2 is 
    true and that there is no evidence that exp3 is true.

    \begin{verbatim}always exp1 [implied by exp2 [with absence exp3]];\end{verbatim}

    \emph{Policy Update Definition.} The following policy update definition
    statement defines a policy update which, when applied, will generate a new
    state by applying exp1 to the current state if and only if exp2 is true in
    the current state. The variable parameters that may occur in any of the
    expressions allow identifiers to be set dynamically when the update is
    applied.

    \begin{verbatim}<update-identifier>([<var1>[,...]]) causes exp1 if exp2;\end{verbatim}

    \emph{Sequence Manipulation Directives.} The current state of the policy
    base (the state in which queries will be evaluated) is derived by applying
    the updates that are appended into the policy update sequence list. Below
    is the syntax for adding a defined policy update into the sequence.

    \begin{verbatim}seq add <update-identifier>([<var1>[,...]]);\end{verbatim}

    Similarly, to remove the n'th update from the sequence:

    \begin{verbatim}seq del <n>;\end{verbatim}

    For the sake of completeness, the language $\cal{L}$ also has provisions
    for listing the policy updates in the sequence:

    \begin{verbatim}seq list;\end{verbatim}

    \emph{Query Directive.} The policy base may be given an expression to be
    queried. Queries are evaluated after all the policy updates in the
    sequence and all the defined constraints have been applied. Query
    directives are always answered by either \emph{true}, \emph{false}, or
    \emph{unknown}.

    \begin{verbatim}query expression;\end{verbatim}

  \section{Implementation}

    \subsection{Translating Language $\cal{L}$ to Extended Logic Program}

      \subsubsection{Integration of Set Theory.}

        Since entities in language $\cal{L}$ may be singular or groups,
        the following constraints must be applied to ensure that set theory
        holds.

        \emph{Inheritance Rules for Members of Groups.} The rule below must
        ensures that each member M inherits all the properties P of group G if
        M is an element of group G.

        \begin{quote}
          holds(M, P) $\leftarrow$ holds(G, P) $\land$ M $\in$ G
        \end{quote}

        \emph{Inheritance Rules for Subgroups.} Similarly, groups inherit all
        properties of its supergroup.

        \begin{quote}
          holds(S1, P) $\leftarrow$ holds(S2, P) $\land$ S1 $\subseteq$ S2
        \end{quote}

        \emph{Transitivity Rule.} If S1 is a subset of S2 and S2 is a subset
        of S3, then S1 is a subset of S3.

        \begin{quote}
          S1 $\subseteq$ S3 $\leftarrow$ S1 $\subseteq$ S2 $\land$ S2
          $\subseteq$ S3
        \end{quote}

      \subsubsection{State Handling Mechanism.}

        An undesirable side-effect of providing dynamic update capabilities to
        language $\cal{L}$ is the presence of states in the policy base. To
        translate the language into an extended logic program, the states need
        to be flattened to produce a stateless policy base. This flattening
        procedure can easily be achieved by treating the state as a property
        of each atom. 

        \emph{Initial State.} Initial state expressions are the easiest to
        translate since the additional state property is fixed to the initial
        state 0. The atom holds(sub, acc, obj) in the initial state is
        translated to holds(sub, acc, obj, 0).

        \begin{quote}
          $\forall$ A $\in$ \{initial state atoms\}, holds(A, 0)
        \end{quote}

        \emph{Constraint Rules.} As with the initial state expressions, every
        atom in every constraint rule will be given a new state property.
        However, since constraint rules apply to all states in the policy
        base, an instance of each constraint rules must be copied for every
        state. Constraints of the form "A implied by B with absence C" is
        translated to:

        \begin{quote}
          $\forall$ S $\in$ \{all states\},
          holds(A, S) $\leftarrow$ holds(B, S) not holds(C, S)
        \end{quote}

        \emph{Policy Updates.} Given the most basic form of a policy update,
        "U causes A if B", an update U, a state S before update U is applied,
        and a function Res that returns the state after update U is applied
        to state S:

        \begin{quote}
          holds(A, Res(U, S)) $\leftarrow$ holds(B, S)
        \end{quote}
 
        In addition to the above rule, a pair of rules are needed to preserve
        the intertial property of policy updates that require all atoms that
        are not affected by the update to be carried over to the next state.

        \begin{quote}
          holds(A, Res(U, S)) $\leftarrow$ holds(A, S) $\land$ not $\lnot$
          holds(A, Res(U, S))
        \end{quote}
        \begin{quote}
          $\lnot$ holds(A, Res(U, S)) $\leftarrow$ $\lnot$ holds(A, S) $\land$
          not holds(A, Res(U, S))
        \end{quote}

        where U is the update, S is the state before update U is applied, and 
        Res is a function that returns the state after update U is applied to
        state S, for all atoms A in the domain.

    \subsection{Translating the Extended Logic Program to Normal Logic Program}

      \subsubsection{Removal of Classical Negation.}

        The translation from extended logic program to normal logic program
        requires one additional step: to remove classical negation ($\lnot$).
        This can easily be achieved by replacing instances of atoms that are
        classically negated by a new and unique positive atom. To do this,
        a \emph{truth} attribute (\emph{true} or \emph{false}) can be added to
        atoms to indicate whether an atom is classically negated or not.

        It is not difficult to see that a conflict will occur when two atoms
        that differ only by their truth attributes are both true. To maintain
        the integrity of the policy base, the following rule must be added 
        for all atoms A in all states S:

        \begin{quote}
          FALSE $\leftarrow$ holds(A, S, true) $\land$ holds(A, S, false)
        \end{quote}

  \section{Conclusion}

  \begin{thebibliography}{5}
    \bibitem{BAI}
      Bai, Y., Varadharajan, V.,
      On Formal Languages for Sequences of Authorization Transformations.
      In \emph{Lecture Notes in Computer Science},
      Vol. 1698,
      pp 375-384.
      Springer-Verlag, 1999

    \bibitem{BER}
      Bertino, E., Buccafurri, F., Ferrari, E., Rullo, P.,
      A Logic-based Approach for Enforcing Access Control.
      \emph{Journal of Computer Security},
      Vol. 8, No. 2-3,
      pp 109-140.
      IOS Press, 2000

    \bibitem{JAJ}
      Jajodia, S., Samarati, P., Sapino, M. L., Subrahmanian, V. S.,
      Flexible Support for Multiple Access Control Policies.
      In \emph{ACM Transactions on Database Systems},
      Vol. 29, No. 2,
      pp 214-260.
      ACM, 2001
  \end{thebibliography}

\end{document}
