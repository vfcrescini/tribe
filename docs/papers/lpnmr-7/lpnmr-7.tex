\documentclass{llncs}

\pagestyle{plain}

\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of Policy Updater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we propose an access control system, \emph{Policy Updater},
    that provides policy evaluation as well as dynamic policy manipulation.
    This is achieved by the use of the proposed logic-based language L to
    represent the access control policies. As the language L is logic-based,
    policy manipulation is achieved by adding or removing atoms and constraints
    that make up the policy base. The policy base can then be translated into a
    normal logic program and then by using the \emph{Stable Models} semantics,
    authorization queries can be evaluated.

    [needs to be edited]
  \end{abstract}

  \section{Introduction}
    [text]

  \section{Language L}
    \subsection{Language Syntax}

      Every statement must end with the semicolon ; terminator. Comments
      may appear between the C-style comment symbols /* and */.

      \emph{Identifiers} are used to represent an entity (subject, access
      right, object), a group of entities or a transformation.

      \begin{verbatim}[a-zA-Z]([a-zA-Z0-9_])*\end{verbatim}

      Entity/group identifiers must first be defined before they appear
      anywhere in the policy base.

      \begin{verbatim}ident {sub|acc|obj}[-grp] <identifier>;\end{verbatim}

      \emph{Atoms} are the basic logical units that make up the policy base.
      The Holds atom signifies a binding of a subject, an object and the
      access right of that subject for that object. The Membership atom binds
      a singular entity to a group entity of the same type. Similarly, a Subset
      atom shows the relationship between a group and its supergroup. The
      negation of an atom is represented in L by prepending the symbol ! to the
      atom.

      \begin{verbatim}[!]holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
[!]memb(<singular-identifier>, <group-identifier>)
[!]subset(<group-identifier>, <group-identifier>)\end{verbatim}

      \emph{Expressions} are atoms or conjunctions of atoms linked together by
      the double ampersand characters \&\&.

      \begin{verbatim}atom1 [&& atom2 [&& ...]]\end{verbatim}

      \emph{Initial State Definition.} This feature of Language L allows the
      initial facts of the policy base to be set.

      \begin{verbatim}initially <expression>;\end{verbatim}

      \emph{Constraint Definition.} Constraints are the logical rules that must
      hold in the initial state and any other state of the policy base after
      any policy update or transformation. The syntax below states that exp1
      must hold if exp2 is true and that there is no evidence that exp3 is
      true.

      \begin{verbatim}always exp1 [implied by exp2 [with absence exp3]];\end{verbatim}

      \emph{Policy Manipulation.} A special feature of the Language L allows
      the policies to be dynamically updated through the process of
      transformation. The following transformation definition syntax generates
      a new state by applying exp1 to the current state if and only if exp2 is
      true in the current state.

      \begin{verbatim}<update-identifier>(<var1>[,...]) causes exp1 if exp2;\end{verbatim}

      The current state of the policy base (the state in which queries will be
      evaluated) is derived by applying the transformations that are added into
      the transformation sequence. Below is the syntax for adding a
      transformation into the sequence.

      \begin{verbatim}seq add <update-identifier>(<var1>[,...]);\end{verbatim}

      Similarly, to remove the n'th transformation from the sequence:

      \begin{verbatim}seq del <n>;\end{verbatim}

      For the sake of completeness, the Language L also has provisions to list
      the transformations in the sequence.

      \begin{verbatim}seq list;\end{verbatim}

      \emph{Query Directive.} The policy base may be given an expression to be
      queried. Queries are evaluated after after all transformations in the
      sequence and all constraints have been applied.

      \begin{verbatim}query expression;\end{verbatim}

  \section{Implementation}

    \subsection{Language L to Extended Logic Program}

      \subsubsection{Integration of Set Theory.}

        Since entities in Language L may be singular or groups, certain rules
        must be added to ensure that set theory holds.

        \emph{Inheritance Rules for Members of Groups.} Ensures that members
        inherit all the properties of groups of which it is a member.

        \begin{equation}
          holds(M, P) \leftarrow holds(G, P) \land M \in G
        \end{equation}

        \emph{Inheritance Rules for Subgroups.} Similarly, groups inherit all
        properties of its supergroup.

        \begin{equation}
          holds(S1, P) \leftarrow holds(S2, P) \land S1 \subseteq S2
        \end{equation}

        \emph{Transitivity Rule.} If S1 is a subset of S2 and S2 is a subset
        of S3, then S1 is a subset of S3.

        \begin{equation}
          S1 \subseteq S3 \leftarrow S1 \subseteq S2 \land S2 \subseteq S3
        \end{equation}

      \subsubsection{State Handling Mechanism.}

        An undesirable side-effect of providing dynamic update capabilities to
        Language L is the presence of states in the policy base. To translate
        the language into an extended logic program, the states need to be
        flattened to produce a stateless policy base. This flattening
        procedure can easily be achieved by treating the state as a property
        of each atom. Unfortunately, the procedure itself is not as straight-
        forward as one would expect. Each of the elements of Language L will
        have a different procedure for flattening the states.

        \emph{Initial State.} Initial state expressions are the easiest to
        translate since the additional state property is fixed to the initial
        state 0. The atom holds(sub, acc, obj) in the initial state is
        translated to holds(sub, acc, obj, 0).

        \begin{equation}
          \forall\{A | A \in set of all atoms\} holds(A, 0)
        \end{equation}

        \emph{Constraint Rules.} As with the initial state expressions, every
        atom in every constraint rule will be given a new state property.
        However, since constraint rules apply to all states in the policy
        base, each constraint rule will be repeated for every state.
        Constraints of the form "A implied by B with absence C" is translated
        to:

        \begin{equation}
          \forall\{S | S \in set of all states\}
          holds(A, S) \leftarrow holds(B, S) not holds(C, S)
        \end{equation}

        \emph{Transformation.} Given the most basic form of a transformation,
        "T causes A if B", a transformation T, a state S before transformation
        T is applied and a function Res that returns the state after
        transformation T is applied to state S:

        \begin{equation}
          holds(A, Res(T, S)) \leftarrow holds(B, S)
        \end{equation}
 
        In addition to the above rule, we also expect atoms that are not
        affected by the transformation to be carried over to the next state.
        The following rules must be applied to ensure that this property is
        held:

        \begin{equation}
          holds(A, Res(T, S)) \leftarrow holds(A, S) \land not \lnot holds(A, Res(T, S))
        \end{equation}
        \begin{equation}
          \lnot holds(A, Res(T, S)) \leftarrow \lnot holds(A, S) \land not holds(A, Res(T, S))
        \end{equation}

        where T is the transformation, S is the state before transformation
        T is applied, A is all the atoms in the domain and Res is a function
        that returns the state after transformation T is applied to state S.

    \subsection{Extended Logic Program to Normal Logic Program}

      \subsubsection{Removal of Classical Negation.}
        A \emph{truth} attribute can be added to atoms to indicate whether
        an atom is classically negated or not.

        \vspace{0.65cm}

        \begin{table}
          \begin{tabular}{ll}
            \hline \\
            ELP & NLP \\
            \hline \\
            holds(A, S) & holds(A, S, T) \\
            $\lnot$ holds(A, S) & holds(A, S, F) \\
            not holds(A, S) & not holds(A, S, T) \\
            not $\lnot$ holds(A, S) & not holds(A, S, F) \\
            \hline
          \end{tabular}
        \end{table}

        FALSE $\leftarrow$ holds(A, S, T) $\land$ holds(A, S, F)

  \section{Conclusion}

  \begin{thebibliography}{5}

    \bibitem{yan:plp}
      Zhang and N.Y. Foo,
      Answer sets for prioritized logic programs.
      In {\em Proceedings of the 1997 International Logic Programming
      Symposium (ILPS'97)},
      pp 69-83. 
      MIT Press, 1997

  \end{thebibliography}

\end{document}

