\documentclass{llncs}

\pagestyle{plain}

\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of PolicyUpdater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we propose an access control system, \emph{PolicyUpdater},
    that provides policy evaluations as well as dynamic policy manipulations.
    This is achieved by the use of the proposed logic-based language $\cal{L}$
    to represent the underlying access control policies. As the language
    $\cal{L}$ is logic-based, policy manipulation is achieved by adding or
    removing atoms and constraints that make up the policy base. The policy
    base can then be translated into a normal logic program and then by
    using the \emph{Stable Model} semantics, authorization queries can
    be evaluated.

    [needs to be edited]
  \end{abstract}

  \section{Introduction}
    [text]

  \section{Language $\cal{L}$}

    [some language intro text]

    Every statement must end with the semicolon ; terminator. Comments
    may appear between the C-style comment symbols /* and */.

    \emph{Identifiers} are used to represent an entity (subject, access
    right, object), a group of entities or an update.

    \begin{verbatim}[a-zA-Z]([a-zA-Z0-9_])*\end{verbatim}

    Entity/group identifiers must first be defined before they appear
    anywhere in the policy base.

    \begin{verbatim}ident {sub|acc|obj}[-grp] <identifier>;\end{verbatim}

    \emph{Atoms} are the basic logical units that make up the policy base.
    The Holds atom signifies a binding of a subject, an object and the
    access right of that subject for that object. The Membership atom binds
    a singular entity to a group entity of the same type. Similarly, a Subset
    atom shows the relationship between a group and its supergroup. The
    negation of an atom is represented in $\cal{L}$ by prepending the symbol
    \emph{!} to the atom.

    \begin{verbatim}[!]holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
[!]memb(<singular-identifier>, <group-identifier>)
[!]subset(<group-identifier>, <group-identifier>)\end{verbatim}

    \emph{Expressions} are atoms or conjunctions of atoms linked together by
    the double ampersand characters \&\&.

    \begin{verbatim}atom1 [&& atom2 [&& ...]]\end{verbatim}

    \emph{Initial State Definition.} This feature of language $\cal{L}$ allows
    the initial facts of the policy base to be set.

    \begin{verbatim}initially <expression>;\end{verbatim}

    \emph{Constraint Definition.} Constraints are the logical rules that must
    hold in the initial state and any other state of the policy base after
    any policy update. The syntax below states that exp1 must hold if exp2 is 
    true and that there is no evidence that exp3 is true.

    \begin{verbatim}always exp1 [implied by exp2 [with absence exp3]];\end{verbatim}

    \emph{Policy Update Definition.} The following policy update definition
    syntax generates a new state by applying exp1 to the current state
    if and only if exp2 is true in the current state. The variable
    parameters that may occur in any of the expressions allow identifiers
    to be set dynamically when the update is applied.

    \begin{verbatim}<update-identifier>([<var1>[,...]]) causes exp1 if exp2;\end{verbatim}

    The current state of the policy base (the state in which queries will be
    evaluated) is derived by applying the updates that are added into
    the policy update sequence list. Below is the syntax for adding an
    update into the sequence.

    \begin{verbatim}seq add <update-identifier>([<var1>[,...]]);\end{verbatim}

    Similarly, to remove the n'th update from the sequence:

    \begin{verbatim}seq del <n>;\end{verbatim}

    For the sake of completeness, the language $\cal{L}$ also has provisions to
    list the updates in the sequence.

    \begin{verbatim}seq list;\end{verbatim}

    \emph{Query Directive.} The policy base may be given an expression to be
    queried. Queries are evaluated after after all updates in the
    sequence and all constraints have been applied. Query directives are
    always answered \emph{true}, \emph{false}, or \emph{unknown}.

    \begin{verbatim}query expression;\end{verbatim}

  \section{Implementation}

    \subsection{Language $\cal{L}$ to Extended Logic Program}

      \subsubsection{Integration of Set Theory.}

        Since entities in language $\cal{L}$ may be singular or groups,
        the following rules must hold to ensure that set theory holds.

        \emph{Inheritance Rules for Members of Groups.} The rule below must
        ensures that each member M inherits all the properties P of group G if
        M is an element of group G.

        \begin{quote}
          holds(M, P) $\leftarrow$ holds(G, P) $\land$ M $\in$ G
        \end{quote}

        \emph{Inheritance Rules for Subgroups.} Similarly, groups inherit all
        properties of its supergroup.

        \begin{quote}
          holds(S1, P) $\leftarrow$ holds(S2, P) $\land$ S1 $\subseteq$ S2
        \end{quote}

        \emph{Transitivity Rule.} If S1 is a subset of S2 and S2 is a subset
        of S3, then S1 is a subset of S3.

        \begin{quote}
          S1 $\subseteq$ S3 $\leftarrow$ S1 $\subseteq$ S2 $\land$ S2
          $\subseteq$ S3
        \end{quote}

      \subsubsection{State Handling Mechanism.}

        An undesirable side-effect of providing dynamic update capabilities to
        language $\cal{L}$ is the presence of states in the policy base. To
        translate the language into an extended logic program, the states need
        to be flattened to produce a stateless policy base. This flattening
        procedure can easily be achieved by treating the state as a property
        of each atom. Unfortunately, the procedure itself is not as straight-
        forward as one would expect. Each of the elements of language $\cal{L}$
        will have a different procedure for flattening the states.

        \emph{Initial State.} Initial state expressions are the easiest to
        translate since the additional state property is fixed to the initial
        state 0. The atom holds(sub, acc, obj) in the initial state is
        translated to holds(sub, acc, obj, 0).

        \begin{quote}
          $\forall$ A $\in$ \{initial state atoms\}, holds(A, 0)
        \end{quote}

        \emph{Constraint Rules.} As with the initial state expressions, every
        atom in every constraint rule will be given a new state property.
        However, since constraint rules apply to all states in the policy
        base, each constraint rule will be repeated for every state.
        Constraints of the form "A implied by B with absence C" is translated
        to:

        \begin{quote}
          $\forall$ S $\in$ \{all states\},
          holds(A, S) $\leftarrow$ holds(B, S) not holds(C, S)
        \end{quote}

        \emph{Policy Updates.} Given the most basic form of a policy update,
        "U causes A if B", an update U, a state S before update U is applied
        and a function Res that returns the state after update U is applied
        to state S:

        \begin{quote}
          holds(A, Res(U, S)) $\leftarrow$ holds(B, S)
        \end{quote}
 
        In addition to the above rule, we also expect atoms that are not
        affected by the update to be carried over to the next state. The 
        following rules must be applied to ensure that this property is
        held:

        \begin{quote}
          holds(A, Res(U, S)) $\leftarrow$ holds(A, S) $\land$ not $\lnot$
          holds(A, Res(U, S))
        \end{quote}
        \begin{quote}
          $\lnot$ holds(A, Res(U, S)) $\leftarrow$ $\lnot$ holds(A, S) $\land$
          not holds(A, Res(U, S))
        \end{quote}

        where U is the update, S is the state before update U is applied, A is 
        all the atoms in the domain and Res is a function that returns the
        state after update U is applied to state S.

    \subsection{Extended Logic Program to Normal Logic Program}

      \subsubsection{Removal of Classical Negation.}

        The translation from extended logic program to normal logic program
        requires one additional step: to remove classical negation ($\lnot$).
        This can easily be achieved by replacing instances of atoms that are
        classically negated by a new and unique positive atom. To do this,
        a \emph{truth} attribute (\emph{T} or \emph{F})can be added to atoms
        to indicate whether an atom has classical negation or not. Table 1 shows
        every possible atom configuration represented with the extra truth
        attribute.

        \begin{table}
         \caption{adding a truth parameter to atoms}
          \begin{tabular}{ll}
            \hline \\
            ELP & NLP \\
            \hline \\
            holds(A, S) & holds(A, S, T) \\
            $\lnot$ holds(A, S) & holds(A, S, F) \\
            not holds(A, S) & not holds(A, S, T) \\
            not $\lnot$ holds(A, S) & not holds(A, S, F) \\
            \hline
          \end{tabular}
        \end{table}

        It is not difficult to see that a conflict will occur when two atoms
        that differ only by their truth attributes are both true. To maintain
        the integrity of the policy base, the following rule must be added 
        for all atoms A in all states S:

        \begin{quote}
          FALSE $\leftarrow$ holds(A, S, T) $\land$ holds(A, S, F)
        \end{quote}

  \section{Conclusion}

  \begin{thebibliography}{5}

    \bibitem{BAI}
      Y. Bai and V. Varadharajan,
      On Formal Languages for Sequences of Authorization Transformations.
      In \emph{Lecture Notes in Computer Science},
      Vol. 1698,
      pp 375-384.
      Springer-Verlag, 1999
    \bibitem{JAJ}
      S. Jajodia, et. al.,
      Flexible Support for Multiple Access Control Policies.
      In \emph{ACM Transactions on Database Systems},
      Vol. 29, No. 2,
      pp 214-260.
      ACM, 2001
      

  \end{thebibliography}

\end{document}

