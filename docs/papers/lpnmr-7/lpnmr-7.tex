\documentclass{llncs}

\pagestyle{plain}

\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of Policy Updater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we propose an access control system, \emph{Policy Updater},
    that provides policy evaluation as well as dynamic policy manipulation.
    This is achieved by the use of the proposed logic-based language L to
    represent the access control policies. As the language L is logic-based,
    policy manipulation is achieved by adding or removing atoms and constraints
    that make up the policy base. The policy base can then be translated into a
    normal logic program and then by using the \emph{Stable Models} semantics,
    authorization queries can be evaluated.

    [needs to be edited]
  \end{abstract}

  \section{Introduction}
    [text]

  \section{Language L}
    \subsection{Language Elements}

      \subsubsection{Identifier}
        \begin{verbatim}
[a-zA-Z]([a-zA-Z0-9_])*
        \end{verbatim}
      \subsubsection{Atom}
        \begin{verbatim}
holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
memb(<singular-identifier>, <group-identifier>)
subset(<group-identifier>, <group-identifier>)
        \end{verbatim}
      \subsubsection{Expression}
        \begin{verbatim}
atom1 [&& ...]
        \end{verbatim}

    \subsection{Initial State Definition}

      \begin{verbatim}
initially <expression>
      \end{verbatim}

    \subsection{Constraint Definition}

      \begin{verbatim}
always exp1 [implied by exp2 [with absence exp3]]
      \end{verbatim}

    \subsection{Policy Manipulation}

      \subsubsection{Definition}

        \begin{verbatim}
<update-identifier>(<var1>[,...]) causes exp1 if exp2
        \end{verbatim}

      \subsubsection{Directives}

        \begin{itemize}
          \item Adding a Transformation into the Sequence
          \item Remove a Transformation from the Sequence
          \item Listing the Sequence Table
        \end{itemize}

    \subsection{Query Directive}

      \begin{verbatim}
query expression
      \end{verbatim}

  \section{Implementation}

    \subsection{Language L to Extended Logic Program}

      \subsubsection{Integration of Set Theory}

        \begin{itemize}
          \item
            Inheritance Rules for Members of Groups

            holds(M, P) $\leftarrow$ holds(G, P) $\land$ M $\in$ G
          \item
            Inheritance Rules for Subgroups

            holds(S1, P) $\leftarrow$ holds(S2, P) $\land$ S1 $\subseteq$ S2
          \item
            Transitivity Rule

            S1 $\subseteq$ S3 $\leftarrow$ S1 $\subseteq$ S2 $\land$ S2 $\subseteq$ S3
        \end{itemize}

      \subsubsection{State Handling Mechanism}

        \begin{itemize}
          \item
            Initial State
          \item
            Constraints
          \item
            Transformations
        \end{itemize}

    \subsection{Extended Logic Program to Normal Logic Program}

      \subsubsection{Removal of Classical Negation.}
        A \emph{truth} attribute can be added to atoms to indicate whether
        an atom is classically negated or not.

        \vspace{0.65cm}

        \begin{table}
          \begin{tabular}{ll}
            \hline \\
            ELP & NLP \\
            \hline \\
            holds(A, S) & holds(A, S, T) \\
            $\lnot$ holds(A, S) & holds(A, S, F) \\
            not holds(A, S) & not holds(A, S, T) \\
            not $\lnot$ holds(A, S) & not holds(A, S, F) \\
            \hline
          \end{tabular}
        \end{table}

        FALSE $\leftarrow$ holds(A, S, T) $\land$ holds(A, S, F)

  \section{Application: Dynamic Access Control System in Web Servers}

  \begin{thebibliography}{5}

    \bibitem{yan:plp}
      Zhang and N.Y. Foo,
      Answer sets for prioritized logic programs.
      In {\em Proceedings of the 1997 International Logic Programming
      Symposium (ILPS'97)},
      pp 69-83. 
      MIT Press, 1997

  \end{thebibliography}

\end{document}

