\documentclass{llncs}

\pagestyle{plain}

\usepackage{epsfig}
\usepackage{changebar}


\begin{document}

  \long\def\comment#1{}

  \title{The Implementation of PolicyUpdater}
  \subtitle{A System for Dynamic Access Control}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia\\
             E-mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    In this paper, we describe the development of \emph{PolicyUpdater}\footnotemark -- an
    access control system that provides policy evaluations as well as dynamic
    policy updates. These are achieved by the use of a logic-based language
    $\cal{L}$ to represent the underlying access control policies, constraints
    and update propositions. The system performs general authorization query
    evaluations and conditional policy updates by first translating the language
    $\cal{L}$ to a normal logic program in a form suitable for evaluation using
    the \emph{Stable Model} semantics, and then queries and updates are
    evaluated through the \emph{Smodels} program.
  \end{abstract}

  \footnotetext{Homepage at \tt http://www.cit.uws.edu.au/{\homedir}jcrescin/projects/PolicyUpdater}

  \section{Introduction}

    The traditional access control mechanism is the \emph{Access Control Matrix}
    where columns represent subjects, rows represent objects and each cell
    contains the access-rights of a subject over a particular object. However,
    flexibility and scalability issues arise when such method is used on
    real-world applications. A more effective paradigm of access control
    systems is the logic-based approach. In this approach, instead of
    explicitly defining all access-rights of all subjects for all objects
    in a domain, a set of logical facts and rules are used to define the
    policy base. 

    Recent advances in the field have produced a number of different approaches
    to logic-based access control systems. Bertino, et. al. \cite{BER} proposed
    such a system based on ordered logic with ordered domains. Jajodia, et. al.
    \cite{JAJ} on the other hand, proposed a general access control framework
    that features handling of multiple policies. Another significant work is
    the system proposed by Bai and Varadharajan \cite{BAI}. Their system's key
    characteristic is the ability to dynamically update the otherwise static
    policy base. These systems, effective as they are, lack the details
    necessary to address the issues involved in the implementation of such
    a system. PolicyUpdater, on the other hand, is a fully-implemented
    logic-based access control system.

  \section{Language $\cal{L}$}

    The language $\cal{L}$ is a first-order logic language that provides the
    following:  (1) a logic-based representation of the policy base; (2) a
    means to conditionally and dynamically update the existing policy base;
    and (3) a mechanism by which queries may be evaluated from the updated
    policy base.

    \emph{Identifiers} are elements of the language $\cal{L}$ used to represent
    an entity (subject, access-right, or object), a group of entities or an
    update. \emph{Atoms} are the basic logical units that make up the
    policy base. The \emph{Holds} atom denotes a binding of a subject,
    an object and the access-right of that subject for that object.
    The \emph{Membership} atom binds a singular entity to a group entity of
    the same type. Similarly, a \emph{Subset} atom shows the relationship
    between a group and its supergroup. The negation of an atom is represented
    in $\cal{L}$ by prepending the exclamation symbol $!$ to the atom.
    \emph{Expressions} are atoms, negative atoms or conjunctions of these
    linked together by the double ampersand characters $\&\&$.

    \begin{verbatim}
[!]holds(<sub-identifier>, <acc-identifier>, <obj-identifier>)
[!]memb(<singular-identifier>, <group-identifier>)
[!]subset(<group-identifier>, <group-identifier>)
\end{verbatim}

    \noindent
    \underline{\emph{Domain Declaration.}}
    Entity and group identifiers must first be declared by the following
    statement before they appear anywhere in the language $\cal{L}$:

    \begin{verbatim}ident {sub|acc|obj}[-grp] <identifier>;\end{verbatim}

    \noindent
    \underline{\emph{Initial State Definition.}}
    Initial state expressions may be defined
    to represent the initial facts of the policy base before any policy update
    is applied.

    \begin{verbatim}initially <expression>;\end{verbatim}

    \noindent
    \underline{\emph{Constraint Definition.}}
    Constraints are the logical rules that must hold in the initial state and
    any other state of the policy base after any policy update. The syntax
    below states that $exp1$ must hold if $exp2$ is true and that there is no
    evidence that $exp3$ is true. Note that the presence of the "with absence"
    clause denotes a default proposition.

    \begin{verbatim}always exp1 [implied by exp2 [with absence exp3]];\end{verbatim}

    \noindent
    \underline{\emph{Policy Update Definition.}}
    The following policy update definition statement defines a policy update
    which, when applied, will generate a new state by applying $exp1$ to the
    current state if and only if $exp2$ is true in the current state. The
    variable parameters that may occur in any of the expressions allow
    identifiers to be set dynamically when the update is applied.

    \begin{verbatim}<update-identifier>([<var1>[,...]]) causes exp1 if exp2;\end{verbatim}

    \noindent
    \underline{\emph{Sequence Manipulation Directives.}}
    The current state of the policy base (the state in which queries will be
    evaluated) is derived by applying the updates that are appended into the
    policy update sequence list. Below is the syntax for adding, removing and
    listing defined policy updates in the sequence.

\begin{verbatim}
seq add <update-identifier>([<var1>[,...]]);
seq del <n>
seq list;
\end{verbatim}

    \noindent
    \underline{\emph{Query Directive.}}
    Queries are evaluated after all the policy updates in the sequence and all
    the defined constraints have been applied. Query directives are always
    answered by either $true$, $false$, or $unknown$.

  \section{Implementation Issues}

    \noindent
    \underline{\emph{Integration of Set Theory.}}
    Since entities in language $\cal{L}$ may be singular or collective groups,
    the following constraints must be applied to ensure that set theory holds.

    \begin{enumerate}
      \item
        Group members inherit all properties held by their super groups.
      \item
        Subgroups inherit all properties held by their super groups.
      \item
        Subset relation is transitive: if $S1$ is a subset of $S2$ and $S2$ is
        a subset of $S3$, then $S1$ is a subset of $S3$.
    \end{enumerate}

    \noindent
    \underline{\emph{Domain Description Translation.}}
    To translate the language into a normal logic program, the states need to
    be flattened to produce a stateless policy base. This flattening procedure
    is achieved by treating the state as a property of each atom.

    \begin{enumerate}
      \item
        For all initial state facts $holds(A)$ or $\lnot$ $holds(A)$: 
        $holds(A, 0)$ or $\lnot$ $holds(A, 0)$, respectively.
      \item
        Given a constraint of the form "Always $A$ implied by $B$ with
        absence $C$", for all states $S$:
        $holds(A, S)$ $\leftarrow$ $holds(B, S)$ $\land$ $not$ $holds(C, S)$.
      \item
        Given an update "$U$ causes $A$ if $B$":
        $holds(A, Res(U, S))$ $\leftarrow$ $holds(B, S)$.
      \item
        Given an update "$U$ causes $A$ if $B$":
        $holds(A, Res(U, S))$ $\leftarrow$ $holds(A, S)$ $\land$ $not$ $\lnot$
        $holds(A, Res(U, S))$.
      \item
        Given an update "$U$ causes $A$ if $B$":
        $\lnot$ $holds(A, Res(U, S))$ $\leftarrow$ $\lnot$ $holds(A, S)$
        $\land$ $not$ $holds(A, Res(U, S))$.
    \end{enumerate}

    Rule 1 shows that initial state expressions are easily translated since
    the additional state property is fixed to the initial state 0. Rule 2
    states that every atom in a constraint rule must be given a new state
    property. However, since constraint rules apply to all states in the
    policy base, an instance of each constraint rules is copied for every
    state.

    For the policy update Rules 3, 4 and 5, the $Res$ function returns
    the resulting state after update $U$ is applied to state $S$. Rules 4 and
    5 preserves the inertial property of policy updates that require all atoms
    that are not affected by the update to be carried over to the next state.

    The final step in the translation involves the removal of classical
    negation ($\lnot$). This is done by adding a \emph{truth} property
    in each atom to indicate whether the atom is classically negated or not.

    \vspace{0.05cm}

    \noindent
    \underline{\emph{Conflict Resolution.}}
    A logical conflict arises when constraints contradict each other. Such
    contradictions may occur due to the presence of $not$. PolicyUpdater
    resolves this conflict by assuming that negative facts have higher
    precedence over its positive counterpart.

  \section{A Web Server Application of PolicyUpdater}

    The expressiveness of language $\cal{L}$ and the effectiveness of the
    implementation can best be demonstrated by a web server authorization
    application of PolicyUpdater. The application serves as an authorization
    module for the \emph{Apache}\footnotemark web server. Although the
    PolicyUpdater module has not yet reached the full functionality provided
    by Apache's built-in authorization module \emph{mod\_auth}, it does provide
    a flexible logic-based authorization mechanism.

    The PolicyUpdater module works by intercepting all authenticated HTTP
    requests made to the web server. Users and groups directly correspond to
    the language $\cal{L}$ subjects, HTTP request methods (i.e. GET, POST,
    etc.) are the access-rights, and files, directories and other resources
    in the document root are the objects. These entities plus any initial
    facts, constraints and update propositions in the policy base make up the
    domain of language $\cal{L}$.

    Figure \ref{fig-1} shows how the PolicyUpdater module works within a
    typical HTTP request. (1) User $S$ makes a HTTP request $A$ for file
    $O$ and is authenticated by Apache through the Basic HTTP Authentication
    Scheme. (2) Once properly authenticated, Apache passes the request tuple
    $\{S, A, O\}$ to the PolicyUpdater module. (3) PolicyUpdater then queries
    the policy base to verify the atom $holds(S, A, O)$ and returns a reply
    (4) back to Apache. If the request is allowed, as determined by the module
    in the policy base, Apache accepts and honors the request $A$ to the file
    $O$ (5) and sends the results back to user $S$ (6). Optionally, an
    Administrator, once properly authenticated can dynamically update the
    policy (7) by altering the update sequence in the policy base.

    \footnotetext{Apache Web Server (\tt http://www.apache.org).}

  \vspace{-0.5cm}

    \begin{figure}[h]
      \begin{center}
        \epsfig{file=fig1.eps}
        \caption{PolicyUpdater module for Apache.}
        \label{fig-1}
      \end{center}
    \end{figure}

  \vspace{-1.70cm}

  \begin{thebibliography}{5}
    \bibitem{BAI}
      Bai, Y., Varadharajan, V.,
      On Formal Languages for Sequences of Authorization Transformations.
      In \emph{Proceedings of Safety, Reliability and Security of Computer
      Systems}. Also in \emph{Lecture Notes in Computer Science},
      Vol. 1698, pp 375-384. Springer-Verlag, 1999

    \bibitem{BER}
      Bertino, E., Buccafurri, F., Ferrari, E., Rullo, P.,
      A Logic-based Approach for Enforcing Access Control.
      \emph{Journal of Computer Security},
      Vol. 8, No. 2-3,
      pp 109-140.
      IOS Press, 2000

    \bibitem{JAJ}
      Jajodia, S., Samarati, P., Sapino, M. L., Subrahmanian, V. S.,
      Flexible Support for Multiple Access Control Policies.
      In \emph{ACM Transactions on Database Systems},
      Vol. 29, No. 2,
      pp 214-260.
      ACM, 2001
  \end{thebibliography}

\end{document}
