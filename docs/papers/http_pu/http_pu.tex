\documentclass[11pt]{llncs}
\usepackage{epsfig}

\pagestyle{plain}

\begin{document}
  \title{Web Server Authorisation with PolicyUpdater:}
  \subtitle{A Logic Based Access Control System}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia \\
             E-Mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    [text]
  \end{abstract}

  \section{Introduction}

  \section{PolicyUpdater System}

    The PolicyUpdater system is a generic access control system designed to
    be used in a variety of applications. As shown in Figure \ref{fig-1},
    the core PolicyUpdater system works with an external authorisation agent,
    which functions as an access control enforcer and at the same time provide
    an interface for administrators to allow policy updates to be performed.
    The primary purpose of the core system is to provide a policy base system
    that can evaluate access control queries and dynamic policy updates to
    support the authorisation agent.

    \begin{figure}[ht]
      \begin{center}
        \epsfig{file=system.eps}
        \caption{Overview of the Core PolicyUpdater System}
        \label{fig-1}
      \end{center}
    \end{figure}

    \subsection{Language ${\cal L}$}
      Language $\cal{L}$ is a first-order logic language that represents a
      policy base for an authorisation system. Two key features of the
      language are: (1) providing a means to conditionally and dynamically
      update  the existing policy base and (2) having a mechanism by which
      queries may be evaluated from the updated policy base.

      \subsubsection{Identifiers.}

        As the most basic unit of language ${\cal L}$, identifiers are used to
        represent the different components of the language. There are three
        main classes of identifiers:

        \begin{itemize}
          \item
            {\bf Entity Identifiers} represent constant entities that make
            up an atom. They are divided further into three types, with each
            type again divided into the {\em singular} and {\em group} entity
            categories:

            \begin{itemize}
              \item
                {\em Subjects}. e.g. bob, administrators, users.
              \item
                {\em Access Rights}. e.g. read, write, own.
              \item
                {\em Objects}. e.g. file, directory, database.
            \end{itemize}
          \vspace{1mm}
          \item
            {\bf Policy Update Identifiers} are used as name handles or labels
            for policy update definitions and directives. e.g. $grant\_read$,
            $revoke\_write$.

          \vspace{1mm}
          \item
            {\bf Variable Identifiers} are used as place holders to represent
            defined entity identifiers.
        \end{itemize}

        The following regular expression shows the syntax of Entity and
        Policy Update Identifiers:

        \begin{verbatim}[a-z]([a-zA-Z0-9_/]){0,127}\end{verbatim}

        Variable Identifiers in contrast, are prefixed with an upper-case
        character:

        \begin{verbatim}[A-Z]([a-zA-Z0-9_]){0,127}\end{verbatim}

      \subsubsection{Atoms.}

        An atom is composed of a relation with 2 to 3 entity or variable
        identifiers that represent a logical relationship between the entities.
        There are three types of atoms:

        \begin{itemize}
          \item
            {\bf Holds.} Atoms of this type states that the subject
            identifier $sub$ holds the access right identifier $acc$ for the
            object identifier $obj$.

            \begin{verbatim}holds(<sub>,<acc>.<obj>)\end{verbatim}

          \vspace{1mm}
          \item
            {\bf Membership.} This type of atom states that the singular
            identifier $elt$ is a member or element of the group identifier
            $grp$. It is important to note that identifiers $elt$ and $grp$
            must be of the same base type (e.g. subject singular and subject
            group).

            \begin{verbatim}memb(<elt>, <grp>)\end{verbatim}

          \vspace{1mm}
          \item
            {\bf Subset.} The subset atom states that the group identifiers
            $grp1$ and $grp2$ are of the same types and that group $grp1$ is
            a subset of the group $grp2$.

            \begin{verbatim}subst(<grp1>, <grp2>)\end{verbatim}
        \end{itemize}

        Atoms that contain no variables, i.e. composed entirely of entity
        identifiers, are called {\em ground atoms}.

      \subsubsection{Facts.}

        A fact makes a claim that the relationship represented by an atom or
        its negation holds in the current context. Facts are negated by the
        use of the negation operator ($!$). The following shows the formal
        syntax of a fact:

        \begin{verbatim}[!]<holds_atm>|<memb_atm>|<subst_atm>\end{verbatim}

        Note that facts may be made up of atoms that contain variable
        identifiers. Facts with no variable occurrences are called {\em ground
        facts}.

      \subsubsection{Expressions.}

        An expression is either a fact, or a logical conjunction of facts,
        separated by the double-ampersand characters $\&\&$.

        \begin{verbatim}<fact1> [&& <fact2> [&& ...]]\end{verbatim}

        Expressions that are made up of only ground facts are called
        {\em ground expressions}.

      \subsubsection{Entity Identifier Definition.}

        All entity identifiers (subjects, access rights, objects and groups)
        must first be declared before any other statements to define the
        entity domain of the policy base. The following entity declaration
        syntax illustrates how to define one or more entity identifiers of a
        particular type.

        \begin{verbatim}ident sub|acc|obj[-grp] <e_id>[, ...]];\end{verbatim}

      \subsubsection{Initial Fact Definition.}

        The initial facts of the policy base, those that hold before any
        policy updates are performed, are defined by using the following
        definition syntax:

        \begin{verbatim}initially <ground-exp>;\end{verbatim}

      \subsubsection{Constraint Definition.}

        Constraints are logical rules that hold regardless of any changes
        that may occur when the policy base is updated. The constraint rules
        are true in the initial state and remains true after any policy
        update.

        The constraint syntax below shows that for any state of the policy
        base, expression $exp1$ holds if expression $exp2$ is true and there
        is no evidence that $exp3$ is true. The $with$ $absence$ clause
        allows constraints to behave like default propositions, where the
        absence of proof of an expression implies that the expression holds.

        It is important to note that the expressions $exp1$, $exp2$ and
        $exp3$ are non-ground expressions, which means identifiers within
        them may be variables.

        \begin{verbatim}always <exp1>
  [implied by <exp2>
  [with absence <exp3>]];\end{verbatim}

      \subsubsection{Policy Update Definition.}

        Before a policy update can be applied, it must first be defined by
        using the following syntax:

        \begin{verbatim}<up_id>([<var_id>[, ...]])
  causes <exp1>
  if <exp2>;\end{verbatim}

        $up\_id$ is the policy update identifier to be used in referencing
        this policy update. The optional $var\_id$ list are the variable
        identifiers occurring the expressions $exp1$ and $exp2$ and will
        eventually be replaced by entity identifiers when the update is
        referenced. The postcondition expression $exp1$ is an expression that
        will hold in the state after this update is applied. The expression
        $exp2$ is a precondition expression that must hold in the current
        state before this update is applied.

        It is important to note that a policy update definition will have no
        effect on the policy base until it is applied by one of the
        directives described in the following section.

      \subsubsection{Policy Update Directives.}

        The policy update sequence list contains a list of references to
        defined policy updates in the domain. The policy updates in the
        sequence list are applied to the current state of the policy base one
        at a time to produce a policy base state upon which queries can be
        evaluated.

        The following four directives are the policy sequence manipulation
        features of language $\cal{L}$.

        \begin{itemize}
          \item
            {\bf Adding an update into the sequence.} Defined policy updates
            are added into the sequence list through the use of the following
            directive statement:

            \begin{verbatim}seq add <up_id>([<e_id>[, ...]]);\end{verbatim}

            \noindent where $up\_id$ is the identifier of a defined policy
            update and the $e\_id$ list is a comma-separated list of entity
            identifiers that will replace the variable identifiers that occur
            in the definition of the policy update.

          \vspace{1mm}
          \item
            {\bf Listing the updates in the sequence.} The following
            directive may be used to list the current contents of the policy
            update sequence list.

            \begin{verbatim}seq list;\end{verbatim}

            This directive is answered with an ordinal list of policy
            updates in the form:

            \begin{verbatim}<n> <up_id>([e_id[, ...]])\end{verbatim}

            \noindent where $n$ is the ordinal index of the policy update
            within the sequence list starting at 0. $up\_id$ is the policy
            update identifier and the $e\_id$ list is the list of entity
            identifiers used to replace the variable identifier
            place-holders.

          \vspace{1mm}
          \item
            {\bf Removing an update from the sequence.} The syntax below
            shows the directive to remove a policy update reference from the
            list. $n$ is the ordinal index of the policy update to be
            removed. Note that removing a policy update reference from the
            sequence list may change the ordinal index of other update
            references.

            \begin{verbatim}seq del <n>;\end{verbatim}

          \vspace{1mm}
          \item
            {\bf Computing an update sequence.} The policy updates in the
            sequence list does not get applied until the $compute$ directive
            is issued. The directive causes the policy update references in
            the sequence list to be applied one at a time in the same order
            that they appear in the list. The directive also causes the
            system to generate the policy base models against which query
            requests can be evaluated.

           \begin{verbatim}compute;\end{verbatim}
        \end{itemize}

      \subsubsection{Query Directive.}

        A ground query expression may be issued against the current state of
        the policy base. This current state is derived after all the updates
        in the update sequence have been applied, one at a time, upon the
        initial state. Query expressions are answered with a $true$, $false$
        or an $unknown$, depending on whether the queried expression holds,
        its negation holds, or neither, respectively. Syntax is as follows:

        \begin{verbatim}query <ground-exp>;\end{verbatim}

    \subsection{Query Evaluation and Policy Updates}

      The PolicyUpdater system evaluates queries by translating language
      ${\cal L}$ policy base into a {\em normal logic program}, which can be
      evaluated using the {\em stable model semantics} \cite{SIM}. With the use
      of the {\em smodels}\footnotemark library to generate a set of all the
      stable models $S$ of the policy, PolicyUpdater can then perform query
      evaluations by checking to see if the query expression holds in set $S$.

      \footnotetext{Smodels from {\tt http://www.tcs.hut.fi/Software/smodels/}}

      Without policy updates, the translation of language ${\cal L}$ into a
      normal logic program is a straightforward procedure: simply express each
      statement as a logical rule of the form:

      \begin{quote}
        $Q$ $\leftarrow$ $P_{0}$, $P_{1}$, ..., $P_{n}$

        where $P_{i}$ ($0$ $\leq$ $i$ $\leq$ $n$) are the premise facts and $Q$
        is the consequent fact.
      \end{quote}

      However, with policy updates, the policy base has states: a state
      transition occurs when a policy update is applied. Since atoms cannot
      express the states in which its relation is meaningful, facts cannot
      express the states in which they hold or do not hold. Such policy bases
      cannot be translated into normal logic programs as rules in one state
      may not necessarily apply to another state, and there is no means to
      distinguish between two states.

      PolicyUpdater solves the problem that is described above by redefining
      atoms: instead of just binding entities in a relation, atoms now
      represent a relationship in a particular state. This is achieved by
      adding a state parameter on every atom. The initial state, or the state
      before any policy update is applied, is assigned state $S_{0}$. States
      after $S_{0}$ is defined by the following function:

      \begin{quote}
        $S'$ = $update$($S$, $U$)

        where $S$ is the current state, $S'$ is the state after update $U$ is
        applied and the function $update$ applies update $U$ to state $S$.
      \end{quote}

      By using this technique, we can now translate each statement of language
      ${\cal L}$ to normal logic program:

      \begin{itemize}
        \item
          Initial state facts are assigned the extra parameter $S_{0}$.
        \vspace{1mm}
        \item
          Constraints are rules that apply regardless of any updates, so
          for each state $S_{i}$ ($0$ $\leq$ $i$ $\leq$ $n$, $n$ is the total
          number of applied updates), each fact in each constraint is assigned
          the new parameter $S_{i}$.
        \vspace{1mm}
        \item
          Policy Updates are applied by translating them into logic rules:
          preconditions are premises and postconditions are consequents. Note
          that facts in the premises are given the parameter $S_{b}$ and
          facts in the consequents are given the parameter $S_{a}$ ($S_{b}$ is
          the current state before update $U$ is applied and $S_{a}$ =
          $update$($S_{b}$, $U$)).
      \end{itemize}

  \section{Web Server Access Control}

    Most web servers include some form of built-in access control mechanism.
    The most popular one, the Apache web server, provides a rudimentary access
    control system as provided by its {\em mod\_auth} and {\em mod\_access}
    modules \cite{AP,LAU}. With this built-in access control system, Apache
    provides the standard HTTP {\em Basic} and {\em Digest} authentication
    schemes \cite{HTTP2}, as well as an authorisation system to enforce
    access control policies. Such policies may be defined as per-request
    rules with HTTP request methods ({\em GET}, {\em POST}, etc.) \cite{HTTP1}
    as access rights; users and hosts as subjects and the resources in the
    server's document root as objects.

    \begin{figure}[ht]
      \begin{center}
        \epsfig{file=apache.eps}
        \caption{Simplified Apache Access Control Mechanism}
        \label{fig-2}
      \end{center}
    \end{figure}

    The diagram in Figure \ref{fig-2} illustrates how access control is
    enforced in a simplified HTTP GET request. (1) client makes a request for a
    file; (2) if required by the policy, the client (user) is authenticated
    against the password table; once authenticated, the client request is sent
    to the access control module (3) where the policy is checked to decide
    whether to accept or deny the request; if the request is accepted, it is
    then passed on to other request handlers for processing and eventually,
    (4) the transaction is completed by sending the requested file back to
    the client.

    \subsection{Integration of PolicyUpdater}

      \begin{figure}[ht]
        \begin{center}
          \epsfig{file=polupdate_apache.eps}
          \caption{Apache Access Control Mechanism with PolicyUpdater}
          \label{fig-3}
        \end{center}
      \end{figure}

      As shown in Figure \ref{fig-3}, Apache's Access Control module, together
      with its policy base, is replaced by the PolicyUpdater module and its own
      policy base. The sole purpose of the PolicyUpdater module is to act as an
      interface between the web server and the core PolicyUpdater system. The
      system works as follows: as the server is started, the PolicyUpdater
      module initialises the core PolicyUpdater system by sending the policy
      base. When a client makes an arbitrary HTTP request for a resource from
      the server (1), the client (user) is authenticated against the password
      table by the built-in authentication module; once the client is properly
      authenticated (2) the request is transferred to the PolicyUpdater module,
      which in turn generates a language ${\cal L}$ query (3) from the request
      details, then sends the query to the core PolicyUpdater system for
      evaluation; if the query is successful and access control is granted,
      the original request is sent to the other request handlers of the web
      server (4) where the request is eventually honoured; then finally (5),
      the resource (or acknowledgment for HTTP requests other than GET) is sent
      back to the client. Optionally, client can be an administrator who,
      after being authenticated, is presented with a special administrator
      interface by the module to allow the policy base to be updated.

      \paragraph{\bf Policy Description in Language ${\cal L'}$.}

        The policy description in the policy base is written in language
        ${\cal L'}$, which is syntactically and semantically similar to
        language ${\cal L}$ except for the lack of entity identifier
        definitions. Entity identifiers need not be explicitly defined in
        the policy definition:

        \begin{itemize}
          \item
            {\bf Subjects} of the access control policies are the users. Since
            all users must first be authenticated, the password table used
            in authentication may also be used to extract the list of subjects.
          \vspace{1mm}
          \item
            {\bf Access Rights} of the policies are built in: they are the
            HTTP request methods as defined by the HTTP 1.1 standard
            \cite{HTTP1} (i.e. OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE
            and CONNECT).
          \vspace{1mm}
          \item
            {\bf Objects} are the resources available in the server themselves.
            Assuming that the document root is a hierarchy of directories and
            files, each of these are mapped as a unique object of language
            ${\cal L'}$.
        \end{itemize}

        Like language ${\cal L}$, language ${\cal L'}$ allows the definition of
        initial state facts, constraint rules and policy update definitions.

      \paragraph{\bf Mapping the Policies to Language ${\cal L}$.}

        As mentioned above, one task of the PolicyUpdater module is to generate
        a language ${\cal L}$ policy from the given language ${\cal L'}$ to be
        evaluated by the core PolicyUpdater system. This process is outlined
        below:

        \begin{itemize}
          \item
            {\bf Generating entity identifier definitions}. As mentioned in the
            previous section, subjects are extracted from the authentication
            (password) table; access rights are hard-coded built-ins; and
            the list of objects are generated by traversing the document root
            for files and directories.
          \vspace{1mm}
          \item
            {\bf Generating additional constraints}. The module also generates
            additional constraints to preserve the relationship between groups
            and elements. This is useful to model the assertion that unless
            explicitly stated, users holding particular access rights to a
            directory automatically hold those access rights to every file in
            that directory (recursively, if with subdirectories). The
            PolicyUpdater module achieves this assertion by generating
            non-conditional constraint rules that state that each file
            (object) is a member of the directory (object group) in which it
            is contained.
        \end{itemize}

        All other language ${\cal L'}$ statements (initial state definitions,
        constraint definitions and policy update definitions) are already in
        language ${\cal L}$ form.

      \paragraph{\bf Evaluation of HTTP Requests.}

        A HTTP request may be represented as a simplified tuple:

        \begin{quote}
          $<$$user$, $request\_method$, $requested\_resource$$>$
        \end{quote}

        $user$ is the authenticated username that made the request (subject);
        $request\_method$ is any of the standard HTTP request methods (access
        right); and $requested\_resource$ is the resource associated with the
        request (object). Intuitively, such a tuple may be expressed as a
        language ${\cal L}$ atom:

        \begin{quote}
          \begin{verbatim}holds(user, request_method, requested_resource)\end{verbatim}
        \end{quote}

        With each request expressed as language ${\cal L}$ atoms, a language
        ${\cal L}$ query statement can be composed to check if the request is
        to be honoured:

        \begin{quote}
          \begin{verbatim}query holds(user, request_method, requested_resource);\end{verbatim}
        \end{quote}

        Once the query statement is composed, it is then sent by the
        PolicyUpdater module to the core PolicyUpdater system for evaluation
        against the policy base.

      \paragraph{\bf Policy Updates by Administrators.}

        After being properly authenticated, an administrator can perform policy
        updates through the use of a special interface generated by the
        PolicyUpdater module. This interface lists all the predefined policy
        updates that are allowed, as defined in the policy description in
        language ${\cal L'}$, as well as all the policy updates that have been
        previously applied and are in effect. As with the core PolicyUpdater
        system, administrators are allowed only the following operations:

        \begin{itemize}
          \item
            Apply a policy update or a sequence of policy updates to the policy
            base. Note that like language ${\cal L}$, in language ${\cal L'}$
            policy updates are predefined within the policy base themselves.
          \vspace{1mm}
          \item
            Revert to a previous state of the policy base by removing a
            previously applied policy update from the policy base.
        \end{itemize}

  \section{Conclusion}

    In this paper, we have presented a logic based approach for web server
    access control systems.

  \begin{thebibliography}{5}
    \bibitem{AP}
      Apache Software Foundation,
      Authentication, Authorization and Access Control.
      In {\em Apache HTTP Server 2.1 Documentation}.
      {\tt http://httpd.apache.org/docs-2.1/}, 2004.
    \bibitem{LAU}
      Laurie, B., Laurie, P.,
      {\em Apache: The Definitive Guide} (3rd Edition).
      O'Reilly \& Associates Inc., 2003.
    \bibitem{HTTP1}
      Network Working Group,
      {\em Hypertext Transfer Protocol -- HTTP/1.1. (RFC 2616)}.
      The Internet Society,
      {\tt ftp://ftp.isi.edu/in-notes/rfc2616.txt}, 1999.
    \bibitem{HTTP2}
      Network Working Group,
      {\em HTTP Authentication (RFC 2617)}.
      The Internet Society,
      {\tt ftp://ftp.isi.edu/in-notes/rfc2617.txt}, 1999.
    \bibitem{SIM}
      Simons, P.,
      Efficient Implementation of the Stable Model Semantics for Normal Logic
      Programs.
      {\em Research Report A35},
      Helsinki University of Technology, Digital Systems Laboratory,
      Finland, 1995.

  \end{thebibliography}
\end{document}
