\documentclass{llncs}
\usepackage{epsfig}

\pagestyle{plain}

\begin{document}
  \title{Web Server Authorisation with PolicyUpdater:}
  \subtitle{A Logic-Based Access-Control System}

  \author{Vino Fernando Crescini \and Yan Zhang}

  \institute{School of Computing and Information Technology\\
             University of Western Sydney\\
             Penrith South DC, NSW 1797, Australia \\
             E-Mail: \{jcrescin,yan\}@cit.uws.edu.au}

  \maketitle

  \begin{abstract}
    [text]
  \end{abstract}

  \section{Introduction}

  \section{PolicyUpdater System}

    \subsection{Language ${\cal L}$}

      Language ${\cal L}$ is a first-order logic language...

      \subsubsection{Identifiers.}

        As the most basic unit of language ${\cal L}$, identifiers are used to
        represent the different components of the language. There are three
        main classes of identifiers:

        \begin{itemize}
          \item
            {\bf Entity Identifiers} represent constant entities that make
            up an atom. They are divided further into three types, with each
            type again divided into the {\em singular} and {\em group} entity
            catogories:
 
            \begin{itemize}
              \item
                {\em Subjects}. e.g. bob, administrators, users.
              \item
                {\em Access Rights}. e.g. read, write, own.
              \item
                {\em Objects}. e.g. file, directory, database.
            \end{itemize}
          \vspace{1mm}
          \item
            {\bf Policy Update Identifiers} are used as name handles or labels
            for policy update definitions and directives. e.g. $grant\_read$,
            $revoke\_write$.
 
          \vspace{1mm}
          \item
            {\bf Variable Identifiers} are used as placeholders to represent
            defined entity identifiers.
        \end{itemize}
 
        The following regular expression shows the syntax of Entity and
        Policy Update Identifiers:
 
        \begin{verbatim}[a-z]([a-zA-Z0-9_]){0,127}\end{verbatim}
 
        Variable Identifiers in consrast, are prefixed with an upper-case
        character:
 
        \begin{verbatim}[A-Z]([a-zA-Z0-9_]){0,127}\end{verbatim}

      \subsubsection{Atoms.}

        An atom is composed of a relation with 2 to 3 entity or variable
        identifiers that represent a logical relationship between the entities.
        There are three types of atoms:

        \begin{itemize}
          \item
            {\bf Holds.} Atoms of this type states that the subject
            identifier $sub$ holds the access right identifier $acc$ for the
            object identifier $obj$.

            \begin{verbatim}holds(<sub>,<acc>.<obj>)\end{verbatim}

          \vspace{1mm}
          \item
            {\bf Membership.} This type of atom states that the singular
            identifier $elt$ is a member or element of the group identifier
            $grp$. It is important to note that identifiers $elt$ and $grp$
            must be of the same base type (e.g. subject singular and subject
            group).

            \begin{verbatim}memb(<elt>, <grp>)\end{verbatim}

          \vspace{1mm}
          \item
            {\bf Subset.} The subset atom states that the group identifiers
            $grp1$ and $grp2$ are of the same types and that group $grp1$ is
            a subset of the group $grp2$.

            \begin{verbatim}subst(<grp1>, <grp2>)\end{verbatim}
        \end{itemize}

        Atoms that contain no variables, i.e. composed entirely of entity
        identifiers, are called {\em ground atoms}.

      \subsubsection{Facts.}

        A fact makes a claim that the relationship represented by an atom or
        its negation holds in the current context. Facts are negated by the
        use of the negation operator ($!$). The following shows the formal
        syntax of a fact:

        \begin{verbatim}[!]<holds_atm>|<memb_atm>|<subst_atm>\end{verbatim}

        Note that facts may be made up of atoms that contain variable
        identifiers. Facts with no variable occurrences are called {\em ground
        facts}.

      \subsubsection{Expressions.}

        An expression is either a fact, or a logical conjunction of facts,
        separated by the double-ampersand characters $\&\&$.

        \begin{verbatim}<fact1> [&& <fact2> [&& ...]]\end{verbatim}

        Expressions that are made up of only ground facts are called
        {\em ground expressions}.

      \subsubsection{Entity Identifier Definition.}

        All entity identifiers (subjects, access rights, objects and groups)
        must first be declared before any other statements to define the
        entity domain of the policy base. The following entity declaration
        syntax illustrates how to define one or more entity identifiers of a
        particular type.

        \begin{verbatim}ident sub|acc|obj[-grp] <e_id>[, ...]];\end{verbatim}

      \subsubsection{Initial Fact Definition.}

        The initial facts of the policy base, those that hold before any
        policy updates are performed, are defined by using the following
        definition syntax:

        \begin{verbatim}initially <ground-exp>;\end{verbatim}

      \subsubsection{Constraint Definition.}

        Constraints are logical rules that hold regardless of any changes
        that may occur when the policy base is updated. The constraint rules
        are true in the initial state and remains true after any policy
        update.

        The constraint syntax below shows that for any state of the policy
        base, expression $exp1$ holds if expression $exp2$ is true and there
        is no evidence that $exp3$ is true. The $with$ $absence$ clause
        allows constraints to behave like default propositions, where the
        absence of proof of an expression implies that the expression holds.

        It is important to note that the expressions $exp1$, $exp2$ and
        $exp3$ are non-ground expressions, which means identifiers within
        them may be variables.

        \begin{verbatim}always <exp1>
  [implied by <exp2>
  [with absence <exp3>]];\end{verbatim}

      \subsubsection{Policy Update Definition.}

        Before a policy update can be applied, it must first be defined by
        using the following syntax:

        \begin{verbatim}<up_id>([<var_id>[, ...]])
  causes <exp1>
  if <exp2>;\end{verbatim}

        $up\_id$ is the policy update identifier to be used in referencing
        this policy update. The optional $var\_id$ list are the variable
        identifiers occurring the expressions $exp1$ and $exp2$ and will
        eventually be replaced by entity identifiers when the update is
        referenced. The postcondition expression $exp1$ is an expression that
        will hold in the state after this update is applied. The expression
        $exp2$ is a precondition expression that must hold in the current
        state before this update is applied.

        It is important to note that a policy update definition will have no
        effect on the policy base until it is applied by one of the
        directives described in the following section.

      \subsubsection{Policy Update Directives.}

        The policy update sequence list contains a list of references to
        defined policy updates in the domain. The policy updates in the
        sequence list are applied to the current state of the policy base one
        at a time to produce a policy base state upon which queries can be
        evaluated.

        The following four directives are the policy sequence manipulation
        features of language $\cal{L}$.

        \begin{itemize}
          \item
            {\bf Adding an update into the sequence.} Defined policy updates
            are added into the sequence list through the use of the following
            directive statement:

            \begin{verbatim}seq add <up_id>([<e_id>[, ...]]);\end{verbatim}
                                                                              
            \noindent where $up\_id$ is the identifier of a defined policy
            update and the $e\_id$ list is a comma-separated list of entity
            identifiers that will replace the variable identifiers that occur
            in the definition of the policy update.

          \vspace{1mm}
          \item
            {\bf Listing the updates in the sequence.} The following
            directive may be used to list the current contents of the policy
            update sequence list.
                                                                              
            \begin{verbatim}seq list;\end{verbatim}
                                                                              
            This directive is answered with an ordinal list of policy
            updates in the form:
                                                                              
            \begin{verbatim}<n> <up_id>([e_id[, ...]])\end{verbatim}

            \noindent where $n$ is the ordinal index of the policy update
            within the sequence list starting at 0. $up\_id$ is the policy
            update identifier and the $e\_id$ list is the list of entity
            identifiers used to replace the variable identifier
            place-holders.

          \vspace{1mm}
          \item
            {\bf Removing an update from the sequence.} The syntax below
            shows the directive to remove a policy update reference from the
            list. $n$ is the ordinal index of the policy update to be
            removed. Note that removing a policy update reference from the
            sequence list may change the ordinal index of other update
            references.
                                                                
            \begin{verbatim}seq del <n>;\end{verbatim}

          \vspace{1mm}
          \item
            {\bf Computing an update sequence.} The policy updates in the
            sequence list does not get applied until the $compute$ directive
            is issued. The directive causes the policy update references in
            the sequence list to be applied one at a time in the same order
            that they appear in the list. The directive also causes the
            system to generate the policy base models against which query
            requests can be evaluated.

           \begin{verbatim}compute;\end{verbatim}
        \end{itemize}

      \subsubsection{Query Directive.}

        A ground query expression may be issued against the current state of
        the policy base. This current state is derived after all the updates
        in the update sequence have been applied, one at a time, upon the
        initial state. Query expressions are answered with a $true$, $false$
        or an $unknown$, depending on whether the queried expression holds,
        its negation holds, or neither, respectively. Syntax is as follows:

        \begin{verbatim}query <ground-exp>;\end{verbatim}

    \subsection{Policy Updates}

    \subsection{Query Evaluation}

  \section{Web Server Access Control}

    [some notes on web servers in general, introduce apache]

    The Apache web server provides a rudimentary access control system as
    provided by its {\em mod\_auth} and {\em mod\_access} modules
    \cite{AP,LAU}. With this built-in access control system, Apache provides
    the standard HTTP {\em Basic} and {\em Digest} authentication schemes
    \cite{HTTP2}, as well as an authorization system to enforce
    administrator-defined policies. Such policies may be defined as per-request
    rules with HTTP request methods ({\em Get}, {\em Post}, etc.) \cite{HTTP1}
    as access rights; users and hosts as subjects and the resources in the
    server's document root as objects.

    \begin{figure}[ht]
      \begin{center}
        \epsfig{file=apache.eps}
        \caption{Simplified Apache Access Control Mechanism}
        \label{fig-1}
      \end{center}
    \end{figure}

    The diagram in Figure \ref{fig-1} illustrates how access control is
    enforced in a simplified HTTP GET request. (1) client makes a request for a
    file; (2) if required by the policy, the client (user) is authenticated
    against the client table; once authenticated, the client request is sent
    to the access control module (3) where the policy is checked to decide
    whether to accept or deny the request; if the request is accepted, it is
    then passed on to other request handlers for processing and eventually,
    (4) the transaction is completed by sending the requested file back to
    the client.

    [add: details of apache policy description]

    \subsection{Integration of PolicyUpdater}

      \begin{figure}[ht]
        \begin{center}
          \epsfig{file=polupdate_apache.eps}
          \caption{Apache Access Control Mechanism with PolicyUpdater}
          \label{fig-2}
        \end{center}
      \end{figure}

      As shown in Figure \ref{fig-2}, Apache's Access Control module, together
      with its policy base, is replaced by the PolicyUpdater module and its own
      policy base. The sole purpose of the PolicyUpdater module is to act as an
      interface between the web server and the core PolicyUpdater system. The
      system works as follows: as the server is started, the PolicyUpdater
      module initialises the core PolicyUpdater system by sending the policy
      base. When a client makes an arbitrary HTTP request for a resource from
      the server (1), the client (user) is authenticated against the client
      table by the built-in authentication module; once the client is properly
      authenticated (2) the request is transferred to the PolicyUpdater module,
      which in turn generates a language ${\cal L}$ query (3) from the request
      details, then sends the query to the core PolicyUpdater system for
      evaluation; if the query is successful and access control is granted,
      the original request is sent to the other request handlers of the web
      server (4) where the request is eventually honoured; then finally (5),
      the resource (or acknowledgment for HTTP requests other than GET) is sent
      back to the client. [add admininstrator later]

      \paragraph{\bf Policy Description in Language ${\cal L'}$.}

        The policy description in the policy base is written in language
        ${\cal L'}$, which is syntactically and semantically similar to
        language ${\cal L}$ except for the lack of entity identifier
        definitions. As users are mapped as the only subjects in the system,
        and since the only valid users in the system are those that appear in
        the authentication table, then the subject entity identifiers can be
        derived from that table. Access rights are hard-coded: they are the
        HTTP request methods. Finally, the objects are the resources
        themselves: assuming that the document root is a hierarchy of
        directories and files, each of these are mapped as a unique object of
        language ${\cal L'}$.

      \paragraph{\bf Mapping the Policies to Lanugage ${\cal L}$.}

        As mentioned above, one task of the PolicyUpdater module is to generate
        a language ${\cal L}$ policy to be evaluated by the core PolicyUpdater
        system. In addition to generating the entity identifier definitions
        from the client table and the document root, the module also generates
        additional constraints to preserve the relationship between groups
        and elements. This is useful to model the assertion that unless
        explicitly stated, users holding particular access rights to a
        directory automatically hold those access rights to every file in
        that directory (recursively, if with subdirectories). The PolicyUpdater
        module achieves this assertion by generating a non-conditional
        constraint that states that each file (object) is a member of the
        directory (object group) in which it is contained.

        All other language ${\cal L'}$ statements (initial state definitions,
        constraint definitions and policy update definitions) are already in
        language ${\cal L}$ form.

      \paragraph{\bf Evaluation of HTTP Requests.}

        For our purposes, a HTTP request may be described as a simple tuple:

        \begin{quote}
          $<$$user$, $request-method$, $requested-resource$$>$
        \end{quote}

        Intuitively, such a tuple may be viewed as a language {\cal L} atom:

        \begin{quote}
          $holds$($user$, $request_method$, $requested-resource$)
        \end{quote}

        With language ${\cal L}$ atoms, a query can be generated then passed to
        the core PolicyUpdater system for evaluation.

      \paragraph{\bf Policy Updates by Administrators.}

        When an administrator, after being properly authenticated, makes a
        {\em Get} request for predefined and non-existent resource (such as
        http://<host>/.administrator), a special policy update 
        



  \section{Conclusion}

    \subsection{Summary}

    \subsection{Limitations and Future Work}

  \begin{thebibliography}{5}
    \bibitem{AP}
      Apache Software Foundation,
      Authentication, Authorization and Access Control.
      http://httpd.apache.org/docs/howto/auth.html.
    \bibitem{LAU}
      Laurie, B., Laurie, P.,
      Apache: The Definitive Guide (3rd Edition).
      {\em O'Reilly \& Associates Inc.}, 2003.
    \bibitem{HTTP1}
      Network Working Group,
      Hypertext Transfer Protocol -- HTTP/1.1. (RFC 2616).
      {\em The Internet Society},
      ftp://ftp.isi.edu/in-notes/rfc2616.txt, 1999.
    \bibitem{HTTP2}
      Network Working Group,
      HTTP Authentication (RFC 2617).
      {\em The Internet Society},
      ftp://ftp.isi.edu/in-notes/rfc2617.txt, 1999.
  \end{thebibliography}
\end{document}
