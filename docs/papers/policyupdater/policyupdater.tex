\documentclass[10pt, twocolumn]{article}
\usepackage{latex8}
\usepackage{times}
\usepackage{amsmath}

\newtheorem{definition}{Definition}

\begin{document}
  \title{
    PolicyUpdater -- A System for Dynamic Access Control:  \\
    Formalization, Implementation and a Case Study
  }

  \author{
    Vino Fernando Crescini and Yan Zhang                   \\
    School of Computing and Information Technology         \\
    University of Western Sydney                           \\
    Penrith South DC, NSW 1797, Australia                  \\
    E-mail: \{jcrescin,yan\}@cit.uws.edu.au
  }

  \date{}

  \maketitle

  \begin{abstract}
    [text]
  \end{abstract}

  \section{Introduction}

    \subsection{Overview of Logic-Based Approaches}

    \subsection{Contribution}

    \subsection{Structure of this Paper}

  \section{Language $\cal{L}$}

    \subsection{Syntax}

      [language statements, statement terminators, and comments]

      \subsubsection{Components of Language $\cal{L}$}

        \noindent \textbf{\emph{Identifiers}}

          The most fundamental unit of Language $\cal{L}$ is an identifier. An
          identifier is used to represent the different components of the
          language. 
    
          The first character of an identifier must be an alpha character
          followed by 0 to 127 characters of alpha, digit or underscore
          characters.

          \begin{verbatim}[a-zA-Z]([a_zA-Z0-9_]){0,127}\end{verbatim}

          An identifier is divided into three main classes:

          \begin{itemize}
            \item
              $Entity$ $Identifiers$ represent entities that make up a logical
              atom. They are further divided into three types, with each type
              again divided into the $singular$ $entity$ and $group$ $entity$
              categories:
              \begin{itemize}
                \item
                  $Subjects$: priviledge holders (eg. alice, astrologers,
                  students).
                \item
                  $Access-Rights$: priviledges (eg. read, write, own).
                \item
                  $Objects$: priviledged entities (eg. file, database,
                  directory).
              \end{itemize}
            \item
              $Policy$ $Update$ $Identifiers$ are used to name a policy
              update definition or directive.
            \item
              $Variable$ $Identifiers$ are used as entity identifier
              placeholders in policy updates.
          \end{itemize}

        \noindent \textbf{\emph{Atoms}}
 
          Atoms are composed of a relation plus 2 to 3 entity identifiers
          that represent a logical relationship between the entities. There are
          three types of atoms:

          \begin{itemize}
            \item
              $Holds$. An atom of this type states that the subject identifier
              $sub$ holds the access-right identifier $acc$ for the object
              identifier $obj$.
         
              \begin{verbatim}holds(<sub>, <acc>, <obj>)\end{verbatim}
            \item
              $Membership$. This type of atom states that the singular
              identifier $elt$ is a member or element of the group identifier
              $grp$. It is important to note that identifiers $elt$ and $grp$
              must be of the same base type (eg. subject and subject group).
         
              \begin{verbatim}memb(<elt>, <grp>)\end{verbatim}
            \item
              $Subset$. The subset atom states that the groups identifiers
              $grp1$ and $grp2$ are of the same types and that group $grp1$
              is a subset of the group $grp2$.

              \begin{verbatim}subst(<grp1>, <grp2>)\end{verbatim}
          \end{itemize}

        \noindent \textbf{\emph{Facts}}

          A fact makes a claim that the relationship represented by an atom or
          its negation holds in the current context. Facts are negated by the
          use of the negation operator ($!$). The following shows the formal
          syntax of a fact:
 
          \begin{verbatim}[!]<holds_atm>|<memb_atm>|<subst_atm>\end{verbatim}
 
        \noindent \textbf{\emph{Expressions}}

          An expression is either a fact, or a logical conjunction of facts,
          separated by the double-ampersand characters $\&\&$.

          \begin{verbatim}<fact1> [&& <fact2> [&& ...]]\end{verbatim}

      \subsubsection{Identifier Entity Declaration}

        All entity identifiers (subjects, access-rights, objects and groups)
        must first be declared before any other statements to define the
        entity domain of the policy base. The following entity declaration
        syntax illustrates how to define one or more entity identifiers of a
        particular type.

        \begin{verbatim}ident sub|acc|obj[-grp] <name>[, ...]];\end{verbatim}

      \subsubsection{Initial State Definition}

        The initial facts in the policy base can be defined by the following
        syntax:

        \begin{verbatim}initially <expression>;\end{verbatim}

      \subsubsection{Constraint Definition}

        Constraints are logical rules that holds regardless of any changes
        that may occur when the policy base is updated. The constraint rules
        are true in the initial state and remains true after any policy update.

        The constraint syntax below shows that for any state of the policy
        base, expression $exp1$ holds if expression $exp2$ is true and there
        is no evidence that $exp3$ is true.

        Note that the conditional clauses $implied$ $by$ and $with$ $absence$
        are optional.

\begin{verbatim}
always <exp1>
  [implied by <exp2>
  [with absence <exp3>]];
\end{verbatim}

      \subsubsection{Policy Update Definition}

        Before a policy update can be applied, it must first be defined by
        by using the following syntax:

\begin{verbatim}
<up_ident>([<var_ident>[, ...]])
  causes <exp1>
  if <exp2>;
\end{verbatim}

        $up\_ident$ is the policy update identifier to be used in referencing
        this identifier. The optional $var\_ident$ list are the variable
        identifiers occuring the expressions and will eventually be replaced
        by entity identifiers when the update is referenced. The postcondition
        expression $exp1$ is an expression that will hold in the state after
        this update is applied. The expression $exp2$ is a precondition
        expression that must hold in the current state before this update is
        applied.

        It is important to note that a defined policy state has no effect
        whatsoever on the policy base until it is applied by one of the
        directives described in the next section.

      \subsubsection{Policy Update Directives}

        The policy update sequence list contains a list of references to
        defined policy updates in the domain. The policy updates in the
        sequence list are applied to the current state of the policy base one
        at a time to produce a policy base state upon which queries can be
        evaluated. The order in which the policy update references appear in
        sequence list is the same order in which they were added.

        The following four directives are the policy sequence manipulation
        features of Language $\cal{L}$.

        \emph{Adding an Update into the Sequence}. Defined policy updates are
        added into the sequence list through the syntax below.

        \begin{verbatim}seq add <up_ident>([<e_ident>[, ...]]);\end{verbatim}

        where $up\_ident$ is the identifier of a defined policy update and 
        the $e\_ident$ list is a comma-separated list of entity identifiers
        that will replace the variable identifiers that occur in the
        definition of the policy update. It is important to note that the
        replacement of variable identifiers with entity identifiers is
        dependent on the order in which they appear in the list.

        \emph{Listing the Updates in the Sequence}. The following directive may
        be used to list the current contents of the policy update sequence
        list.

        \begin{verbatim}seq list;\end{verbatim}

        This directive is answered with an ordinal list of policy updates in
        the form:

        \begin{verbatim}<n> <up_ident>([e_ident[, ...]])\end{verbatim}

        where $n$ is the ordinal index of the policy update within the sequence
        list starting at 0. $up_ident$ is the policy update identifier and the
        $e_ident$ list is the list of entity identifiers used to replace the
        variable identifier placeholders.

        \emph{Removing an Update from the Sequence}. The syntax below shows the
        directive to remove a policy update reference from the list. $n$ is the
        ordinal index of the policy update to be removed. Note that removing
        a policy update reference from the sequence list may change the ordinal
        index of the other update references.

        \begin{verbatim}seq del <n>;\end{verbatim}

      \emph{Computing after a Polcy Update}. The policy updates in the sequence
      list does not get applied until the compute directive is issued. The
      directive causes the policy update references in the sequence list to be
      applied one at a time in the same order that they appear in the list. The
      directive also causes the system to generate the policy base models
      against which query requests can be evaluated.

      \begin{verbatim}compute;\end{verbatim}

      \subsubsection{Query Directive}

        A query expression may be issued against the current state of the
        policy base. This current state is derived after all the updates in
        the update sequence has been applied, one at a time, onto the initial
        state. Query expressions are answered with a \emph{true}, \emph{false}
        or an \emph{unknown}, depending on whether the queried expression
        holds, its negation holds, or neither, respectively. Syntax is as
        follows:

        \begin{verbatim}query <exp>;\end{verbatim} 

    \subsection{Semantics}

      \subsubsection{Domain Definition of Language ${\cal L}$}

        \begin{definition}
          The domain of Language ${\cal L}$ is as follows:

          \begin{quote}
            \begin{math}
              {\cal D}_{\cal L} = 
              \begin{cases}
                \mbox{set of Initial State Facts $\alpha$} \\
                \mbox{set of Constraint Rules $\beta$} \\
                \mbox{set of Policy Update Definitions $\gamma$}
              \end{cases}
            \end{math}
          \end{quote}

          \begin{itemize}
            \item
              The initial state facts $\alpha$ is an expression, or a
              conjunction of facts that hold in the initial state.
            \item
              The constraint rules $\beta$ are the rules that holds in all
              states.
            \item
              The policy update definitions $\gamma$ contains the name,
              preconditions and postconditions of all policy updates that
              can be applied in the policy base.
          \end{itemize}
        \end{definition}

        In addition to the domain ${\cal D}_{\cal L}$, Language ${\cal L}$
        includes one additional ordered set: the sequence list $\psi$.

        \begin{definition}
          The sequence list $\psi$ is an ordered set that contains a sequence 
          of references to policy update definitions from set $\gamma$. Each
          policy update reference consists of the policy update identifier and
          a set of zero or more entities from set ${\cal E}$ to replace the
          variable placeholders in the policy update definitions.
        \end{definition}

        Given the domain ${\cal D}_{\cal L}$, a query expression may be
        evaluated against the state of the policy base derived after a sequence
        of policy updates from the sequence list $\psi$ are applied.

        \begin{definition}
          A query expression $\omega$ is said to hold in the policy base
          $PB_{{\cal D}_{\cal L}}$ with the sequence list $\psi$ if and only
          if:

          \begin{quote}
            $PB_{{\cal D}_{\cal L}}$ $\models$ $\omega$ after $\psi$
          \end{quote}
          
        \end{definition}

      \subsubsection{Translating Language ${\cal L}$ into ${\cal L}^{*}$}

        The Elements of Language ${\cal L}$ must first be expressed as a Normal
        Logic Program before logical operations such as querying and updating
        can be performed. The Language ${\cal L}^{*}$ is a direct translation
        of Language ${\cal L}$, and as such, it contains the same elements and
        has an equivalent expressive power.

      \subsubsection{Entity Definition of Language ${\cal L}^{*}$}

        \begin{definition}

          The entity set ${\cal E}$ is the union of six disjoint entity sets:
          single-subject ${\cal E}_{SS}$, group-subject ${\cal E}_{SG}$,
          single-access-right ${\cal E}_{AS}$, group-access-right
          ${\cal E}_{AG}$, single-object ${\cal E}_{OS}$ and group-object
          ${\cal E}_{OG}$.

          \begin{enumerate}
            \item
              ${\cal E} = {\cal E}_{S} \cup {\cal E}_{A} \cup {\cal E}_{O}$
            \item
              ${\cal E}_{S} = {\cal E}_{SS} \cup {\cal E}_{SG}$
            \item
              ${\cal E}_{A} = {\cal E}_{AS} \cup {\cal E}_{AG}$
            \item
              ${\cal E}_{O} = {\cal E}_{OS} \cup {\cal E}_{OG}$
          \end{enumerate}

        \end{definition}

      \subsubsection{State Semantics}

        Conceptually, a state may be thought of as a set of facts and
        constraints of the policy base at a particular instant. The state
        transition notation below shows that the new state $PB'$ is generated
        from the current state $PB$ after the policy update $U$ is applied.

        \begin{quote}
          $PB$ $\overrightarrow{_{U}}$ $PB'$
        \end{quote}

        Using this definition of a state means that for every policy update
        applied to the policy base, a new instance of the policy base or a new 
        set of facts and constraints are generated. To avoid having to deal
        with multiple instances of the policy base, the semantics of language
        ${\cal L}^{*}$ uses a simpler and less tangible definition of a state:

        \begin{definition}
          State is a property of atoms in the policy base used to differentiate
          atoms that hold before the application of a particular policy update,
          from the atoms that hold after the application.
        \end{definition}

      \subsubsection{Atoms, Facts and Expressions}

        The principal difference between Language ${\cal L}$ and Language
        ${\cal L}^{*}$ lies in the definition of atoms. Atoms in Language
        ${\cal L}^{*}$ includes an additional state parameter $\sigma$, thereby
        limiting the scope of the atom to a particular state in the policy
        base.

        \begin{definition}
          An atom represents a logical relationship of two to three entities
          is a particular policy base state. The atom set $\cal{A}^{\sigma}$ is
          the set of all possible atoms in state $\sigma$.

          \begin{enumerate}
            \item
              ${\cal A}^{\sigma} = {\cal A}^{\sigma}_{H} \cup {\cal A}^{\sigma}_{M} \cup {\cal A}^{\sigma}_{S}$
            \item
              ${\cal A}^{\sigma}_{H} = \{\forall (s \in {\cal E}_{S}, a \in {\cal E}_{A}, o \in {\cal E}_{O}, holds(s, a, o, \sigma) \}$
            \item
              ${\cal A}^{\sigma}_{M} = {\cal A}^{\sigma}_{MS} \cup {\cal A}^{\sigma}_{MA} \cup {\cal A}^{\sigma}_{MO}$
            \item
              ${\cal A}^{\sigma}_{S} = {\cal A}^{\sigma}_{SS} \cup {\cal A}^{\sigma}_{SA} \cup {\cal A}^{\sigma}_{SO}$
            \item
              ${\cal A}^{\sigma}_{MS} = \{\forall (e \in {\cal E}_{SS}, g \in {\cal E}_{SG}), memb(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{MA} = \{\forall (e \in {\cal E}_{AS}, g \in {\cal E}_{AG}), memb(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{MO} = \{\forall (e \in {\cal E}_{OS}, g \in {\cal E}_{OG}), memb(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{SS} = \{\forall (g1, g2 \in {\cal E}_{SG}), subst(g1, g2, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{SA} = \{\forall (g1, g2 \in {\cal E}_{AG}), subst(g1, g2, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{SO} = \{\forall (g1, g2 \in {\cal E}_{OG}), subst(g1, g2, \sigma)\}$
          \end{enumerate}

        \end{definition} 

        \begin{definition}
          A fact is a logical statement that makes a claim that an atom either
          holds or does not hold in a particular state $\sigma$. The following
          is the formal definition of a fact:

          \begin{quote}
            $f^{\sigma}$ = $[\lnot]$$a$, $a$ $\in$ ${\cal A}^{\sigma}$
          \end{quote}
        \end{definition}

        \begin{definition}
          An expression is a fact or a conjunction of facts of a particular
          state $\sigma$.

          \begin{quote}
            $e^{\sigma}$ = $f^{\sigma}_{0}$ $\land$ ... $\land$ $f^{\sigma}_{n}$, $n$ $\geq$ $0$
          \end{quote}
        \end{definition}

      \subsubsection{Translating Language ${\cal L}$ into the Normal Logic Program ${\cal L^{*}}$}

        \noindent \emph{Initial State}

        \noindent \emph{Constraints}

        \noindent \emph{Policy Updates}

        \noindent \emph{Queries}

      \subsubsection{Additional Constraints}

        \noindent \emph{Inheritance Rules}

        \noindent \emph{Transitivity Rules}

        \noindent \emph{Contradictory Rule}

          $false$ $\leftarrow$ $A$ $\land$ $\lnot$ $A$

    \subsection{Example}

    \subsection{Properties}

  \section{Implementation}

    \subsection{System Structure}

    \subsection{Algorithms}

  \section{Case Study: Web Server Application}

  \section{Conclusion}

    [summary]

    [effectiveness of system/application]

    [future work]

\end{document}
