\documentclass[10pt, twocolumn]{article}
\usepackage{latex8}
\usepackage{times}
\usepackage{amsmath}
\usepackage{alltt}
\usepackage{epsfig}
\usepackage{rotating}
\usepackage{multirow}

\newtheorem{definition}{Definition}
\newtheorem{examp}{Example}
\newenvironment{example}{\begin{examp}\rm}{\rule{2mm}{2mm}\end{examp}}

\begin{document}
  \title{PolicyUpdater -- A System for Dynamic Access Control}
  \author{
    Vino Fernando Crescini and Yan Zhang                   \\
    School of Computing and Information Technology         \\
    University of Western Sydney                           \\
    Penrith South DC, NSW 1797, Australia                  \\
    E-mail: \{jcrescin,yan\}@cit.uws.edu.au
  }

  \date{}

  \maketitle

  \begin{abstract}
    [text]
  \end{abstract}

  \section{Introduction}

    \subsection{Overview of Logic-Based Approaches}

    \subsection{Contributions}

    \subsection{Structure of This Paper}

  \section{Language $\cal{L}$}

    Language $\cal{L}$ is a first-order logic language that represents a policy
    base for an authorisation system. Two key features of the language are: (1)
    providing a means to conditionally and dynamically update the existing
    policy base and (2) having a mechanism by which queries may be evaluated
    from the updated policy base.

    \subsection{Syntax}

      Logic programs of language ${\cal L}$ are composed of language
      statements, each terminated by a semicolon ";" character. C-style
      comments delimited by the "/*" and "*/" characters may appear anywhere in
      the logic program.

      \subsubsection{Components of Language $\cal{L}$}

        \paragraph{Identifiers.}
          The most basic unit of language $\cal{L}$ is the identifier.
          Identifiers are used to represent the different components of the
          language, and are divided into three main classes:

          \begin{itemize}
            \item
              {\em Entity Identifiers} represent constant entities that make up
              a logical atom. They are divided further into three types, with
              each type again divided into the {\em singular entity} and
              {\em group entity} categories:

              \begin{itemize}
                \item
                  {\em Subjects}: e.g. alice, lecturers, group.
                \item
                  {\em Access Rights}: e.g. read, write, own.
                \item
                  {\em Objects}: e.g. file, database, directory.
              \end{itemize}

              An entity identifier is defined as a lower-case alphabet
              character, followed by 0 to 127 characters of alphabet, digit or
              underscore characters. The following regular expression shows the
              syntax of entity identifiers:

              \begin{verbatim}[a-z]([a-zA-Z0-9_]{0,127}\end{verbatim}

            \item
              {\em Policy Update Identifiers} are used for the sole purpose of
              naming a policy update. These identifier names are then used as
              labels to refer to policy update definitions and directives. As
              labels, identifiers of this class occupy a different namespace
              from entity identifiers. For this reason, policy update
              identifiers share the same syntax with entity identifiers:

              \begin{verbatim}[a-z]([a-zA-Z0-9_]{0,127}\end{verbatim}

            \item
              {\em Variable Identifiers} are used as entity identifier
              place-holders. To distinguish them from entity and policy update
              identifiers, variable identifiers are prefixed with an upper-case
              character, followed by 0 to 127 alphanumeric and underscore
              characters. The following regular expression shows the syntax of
              variable identifiers:

              \begin{verbatim}[A-Z]([a-zA-Z0-9_]{0,127}\end{verbatim}
          \end{itemize}

        \paragraph{Atoms.}
          An atom is composed of a relation with 2 to 3 entity or variable
          identifiers that represent a logical relationship between the
          entities. There are three types of atoms:

          \begin{itemize}
            \item
              {\em Holds.} An atom of this type states that the subject
              identifier $sub$ holds the access right identifier $acc$
              for the object identifier $obj$.

              \begin{verbatim}holds(<sub>, <acc>, <obj>)\end{verbatim}
            \item
              {\em Membership.} This type of atom states that the singular
              identifier $elt$ is a member or element of the group identifier
              $grp$. It is important to note that identifiers $elt$ and $grp$
              must be of the same base type (e.g. subject and subject group).

              \begin{verbatim}memb(<elt>, <grp>)\end{verbatim}
            \item
              {\em $Subset$.} The subset atom states that the group identifiers
              $grp1$ and $grp2$ are of the same types and that group $grp1$ is
              a subset of the group $grp2$.

              \begin{verbatim}subst(<grp1>, <grp2>)\end{verbatim}
          \end{itemize}

          Atoms that contain no variables, i.e. composed entirely of entity
          identifiers, are called {\em ground atoms}.

        \paragraph{Facts.}
          A fact makes a claim that the relationship represented by an atom or
          its negation holds in the current context. Facts are negated by the
          use of the negation operator ($!$). The following shows the formal
          syntax of a fact:

          \begin{verbatim}[!]<holds_atm>|<memb_atm>|<subst_atm>\end{verbatim}

          Note that facts may be made up of atoms that contain variable
          identifiers. Facts with no variable occurrences are called
          {\em ground facts}.

        \paragraph{Expressions.}
          An expression is either a fact, or a logical conjunction of facts,
          separated by the double-ampersand characters $\&\&$.

          \begin{verbatim}<fact1> [&& <fact2> [&& ...]]\end{verbatim}

          Expressions that are made up of only ground facts are called
          {\em ground expressions}.

      \subsubsection{Definition Statements}

        \paragraph{Entity Identifier Definition.}

          All entity identifiers (subjects, access rights, objects and groups)
          must first be declared before any other statements to define the
          entity domain of the policy base. The following entity declaration
          syntax illustrates how to define one or more entity identifiers of a
          particular type.

          \begin{verbatim}ident sub|acc|obj[-grp] <e_id>[, ...]];\end{verbatim}

        \paragraph{Initial Fact Definition.}

          The initial facts of the policy base, those that hold before any
          policy updates are performed, are defined by using the following
          definition syntax:

          \begin{verbatim}initially <ground-exp>;\end{verbatim}

        \paragraph{Constraint Definition.}

          Constraints are logical rules that holds regardless of any changes
          that may occur when the policy base is updated. The constraint rules
          are true in the initial state and remains true after any policy
          update.

          The constraint syntax below shows that for any state of the policy
          base, expression $exp1$ holds if expression $exp2$ is true and there
          is no evidence that $exp3$ is true. The $with$ $absence$ clause
          allows constraints to behave like default propositions, where the
          absence of proof that an expression holds implies that the default
          expression holds.

          It is important to note that the expressions $exp1$, $exp2$ and
          $exp3$ are non-ground expressions, which means identifiers within
          them may be variables.

          \begin{verbatim}
always <exp1>
  [implied by <exp2>
  [with absence <exp3>]];
          \end{verbatim}

        \paragraph{Policy Update Definition.}

          Before a policy update can be applied, it must first be defined by
          using the following syntax:

          \begin{verbatim}
<up_id>([<var_id>[, ...]])
  causes <exp1>
  if <exp2>;
          \end{verbatim}

          $up\_id$ is the policy update identifier to be used in referencing
          this policy update. The optional $var\_id$ list are the variable
          identifiers occurring the expressions $exp1$ and $exp2$ and will
          eventually be replaced by entity identifiers when the update is
          referenced. The postcondition expression $exp1$ is an expression that
          will hold in the state after this update is applied. The expression
          $exp2$ is a precondition expression that must hold in the current
          state before this update is applied.

          It is important to note that a policy update definition will have no
          effect on the policy base until it is applied by one of the directives
          described in the following section.

        \subsubsection{Directive Statements}

        \paragraph{Policy Update Directives.}

        The policy update sequence list contains a list of references to
        defined policy updates in the domain. The policy updates in the
        sequence list are applied to the current state of the policy base one
        at a time to produce a policy base state upon which queries can be
        evaluated.

        The following four directives are the policy sequence manipulation
        features of language $\cal{L}$.

        \subparagraph{Adding an update into the sequence.}
          Defined policy updates are added into the sequence list through the
          use of the following directive:

          \begin{verbatim}seq add <up_id>([<e_id>[, ...]]);\end{verbatim}

          \noindent where $up\_id$ is the identifier of a defined policy
          update and the $e\_id$ list is a comma-separated list of entity
          identifiers that will replace the variable identifiers that occur in
          the definition of the policy update.

        \subparagraph{Listing the updates in the sequence.}
          The following directive may be used to list the current contents of
          the policy update sequence list.

          \begin{verbatim}seq list;\end{verbatim}

          This directive is answered with an ordinal list of policy updates in
          the form:

          \begin{verbatim}<n> <up_id>([e_id[, ...]])\end{verbatim}

          \noindent where $n$ is the ordinal index of the policy update within
          the sequence list starting at 0. $up\_id$ is the policy update
          identifier and the $e\_id$ list is the list of entity identifiers
          used to replace the variable identifier place-holders.

        \subparagraph{Removing an update from the sequence.}
          The syntax below shows the directive to remove a policy update
          reference from the list. $n$ is the ordinal index of the policy
          update to be removed. Note that removing a policy update reference
          from the sequence list may change the ordinal index of other update
          references.

          \begin{verbatim}seq del <n>;\end{verbatim}

        \subparagraph{Computing an update sequence.}

          The policy updates in the sequence list does not get applied until
          the $compute$ directive is issued. The directive causes the policy
          update references in the sequence list to be applied one at a time in
          the same order that they appear in the list. The directive also
          causes the system to generate the policy base models against which
          query requests can be evaluated.

          \begin{verbatim}compute;\end{verbatim}

        \paragraph{Query Directive.}

          A ground query expression may be issued against the current state of
          the policy base. This current state is derived after all the updates
          in the update sequence have been applied, one at a time, upon the
          initial state. Query expressions are answered with a $true$, $false$
          or an $unknown$, depending on whether the queried expression holds,
          its negation holds, or neither, respectively. Syntax is as follows:

          \begin{verbatim}query <ground-exp>;\end{verbatim}

        \begin{example}
          \label{ex-1}
          The following language ${\cal L}$ program code listing shows a simple
          rule-based document access control system scenario.

          In this example, the subject $alice$ is initially a member of the
          subject group $grp3$, which is a subset of group $grp2$, which in
          turn is a subset of group $grp1$. The group $grp1$ also initially
          holds a $read$ access right for the object $file$. The constraint
          states that if the group $grp1$ has $read$ access for $file$, and no
          other information is present to conclude that $grp1$ do not have
          $write$ access for $file$, then the group $grp1$ is granted $write$
          access for $file$.

          \begin{verbatim}
/* entity identifier definitions */
ident sub alice;
ident sub-grp grp1, grp2, grp3;
ident acc read, write;
ident obj file;

/* initial fact definitions */
initially
  memb(alice, grp2) &&
  holds(grp1, read, file) &&
  subst(grp3, grp2) &&
  subst(grp2, grp1);

/* constraint definitions */
always holds(grp1, write, file)
  implied by
    holds(grp1, read, file)
  with absence
    !holds(grp1, write, file);

/* policy update definitions */
delete_read(SG0, OS0)
  causes !holds(SG0, read, OS0);

/* sequence manipulation directive */
seq add delete_read(grp1, file);

/* compute directive */
compute;

/* query directives */
query holds(grp1, write, file);
query holds(grp1, read, file);
query holds(alice, write, file);
query holds(alice, read, file);
          \end{verbatim}
        \end{example}

    \subsection{Semantics}

      \subsubsection{Domain Description of Language ${\cal L}$}

        \begin{definition}
          The domain description ${\cal D}_{\cal L}$ of language ${\cal L}$ is
          defined as a finite set of ground initial state facts, constraint
          rules and policy update definitions.
        \end{definition}

        In addition to the domain description ${\cal D}_{\cal L}$, language
        ${\cal L}$ also includes an additional ordered set: the sequence list
        $\psi$. The sequence list $\psi$ is an ordered set that contains a
        sequence of references to policy update definitions. Each policy update
        reference consists of the policy update identifier and a series of zero
        or more identifier entities to replace the variable place-holders in
        the policy update definitions.

      \subsubsection{Language ${\cal L}^{*}$}

        In language ${\cal L}$, the policy base is subject to change, which is
        triggered by the application of policy updates. Such changes bring
        forth the concept of policy base states. Conceptually, a state may be
        thought of as a set of facts and constraints of the policy base at a
        particular instant. The state transition notation below shows that a
        new state $PB'$ is generated from the current state $PB$ after the
        policy update $u$ is applied.

        \begin{quote}
          $PB$ $\overrightarrow{_{u}}$ $PB'$
        \end{quote}

        This definition of a state means that for every policy update applied
        to the policy base, a new instance of the policy base or a new set of
        facts and constraints are generated. To precisely define the underlying
        semantics of domain description ${\cal D}_{\cal L}$ in language
        ${\cal L}$, we introduce language ${\cal L}^{*}$, which is an extended
        logic program representation of language ${\cal L}$, with state as an
        explicit sort.

        Language ${\cal L}^{*}$ contains only one special state constant
        $S_{0}$ to represent the initial state of a given domain description.
        All other states are represented as a resulting state obtained by
        applying the $Result$ function.

        The $Result$ function takes a policy update reference $u$, where $u$
        $\in$ $\psi$, and the current state $\sigma$ as input arguments and
        returns the resulting state $\sigma'$ after update $u$ has been applied
        to state $\sigma$.

        \begin{quote}
          $\sigma'$ = $Result$($u$, $\sigma$)
        \end{quote}

        Given an initial state $S_{0}$ and a sequence list $\psi$, each state
        $\sigma_{i}$ ($0$ $\leq$ $i$ $\leq$ $|\psi|$) may be represented as
        follows:

        \begin{quote}
          $\sigma_{0} = S_{0}$

          $\sigma_{1} = Result(u_{0}, \sigma_{0})$

          $\vdots$

          $\sigma_{|\psi|} = Result(u_{|\psi| - 1}, \sigma_{|\psi| - 1})$
        \end{quote}

        Substituting each state with a recursive call to the $Result$ function,
        the final state $S_{|\psi|}$ is defined as follows:

        \begin{quote}
          \begin{math}
            \begin{aligned}[t]
              S_{|\psi|} = Result&(u_{|\psi| - 1}, Result(\ldots, \\
              &Result(u_{0}, S_{0})))
            \end{aligned}
          \end{math}
        \end{quote}

        \paragraph{Entities.}

          The entity set ${\cal E}$ is the union of six disjoint entity sets:
          single subject ${\cal E}_{ss}$, group subject ${\cal E}_{sg}$,
          single access right ${\cal E}_{as}$, group access right
          ${\cal E}_{ag}$, single object ${\cal E}_{os}$ and group object
          ${\cal E}_{og}$. Each entity in set ${\cal E}$ corresponds directly
          to the \emph{entity identifiers} of language ${\cal L}$.

          \begin{enumerate}
            \item
              ${\cal E} = {\cal E}_{s} \cup {\cal E}_{a} \cup {\cal E}_{o}$
            \item
              ${\cal E}_{s} = {\cal E}_{ss} \cup {\cal E}_{sg}$
            \item
              ${\cal E}_{a} = {\cal E}_{as} \cup {\cal E}_{ag}$
            \item
              ${\cal E}_{o} = {\cal E}_{os} \cup {\cal E}_{og}$
          \end{enumerate}

        \paragraph{Atoms.}

          The main difference between language ${\cal L}$ and language
          ${\cal L}^{*}$ lies in the definition of an atom. Atoms in language
          ${\cal L}^{*}$ represent a logical relationship of two to three
          entities, as with atoms of language ${\cal L}$. Furthermore, atoms of
          language ${\cal L}^{*}$ extends this definition by defining the
          state of the policy base in which the relationship holds. In this
          paper, atoms of language ${\cal L}^{*}$ are written with the
          hat character ($\hat{holds}$, $\hat{memb}$ and $\hat{subst}$) to
          differentiate from the atoms of language ${\cal L}$.

          The atom set ${\cal A}^{\sigma}$ is the set of all atoms in state
          $\sigma$.

          \begin{enumerate}
            \item
              ${\cal A}^{\sigma} = {\cal A}^{\sigma}_{h} \cup {\cal A}^{\sigma}_{m} \cup {\cal A}^{\sigma}_{s}$
            \item
              ${\cal A}^{\sigma}_{h} = \{\forall (s \in {\cal E}_{s}, a \in {\cal E}_{a}, o \in {\cal E}_{o}), \hat{holds}(s, a, o, \sigma) \}$
            \item
              ${\cal A}^{\sigma}_{m} = {\cal A}^{\sigma}_{ms} \cup {\cal A}^{\sigma}_{ma} \cup {\cal A}^{\sigma}_{mo}$
            \item
              ${\cal A}^{\sigma}_{s} = {\cal A}^{\sigma}_{ss} \cup {\cal A}^{\sigma}_{sa} \cup {\cal A}^{\sigma}_{so}$
            \item
              ${\cal A}^{\sigma}_{ms} = \{\forall (e \in {\cal E}_{ss}, g \in {\cal E}_{sg}), \hat{memb}(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{ma} = \{\forall (e \in {\cal E}_{as}, g \in {\cal E}_{ag}), \hat{memb}(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{mo} = \{\forall (e \in {\cal E}_{os}, g \in {\cal E}_{og}), \hat{memb}(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{ss} = \{\forall (g1, g2 \in {\cal E}_{sg}), \hat{subst}(g1, g2, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{sa} = \{\forall (g1, g2 \in {\cal E}_{ag}), \hat{subst}(g1, g2, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{so} = \{\forall (g1, g2 \in {\cal E}_{og}), \hat{subst}(g1, g2, \sigma)\}$
          \end{enumerate}

        \paragraph{Facts.}

          A fact is a logical statement that makes a claim that an atom either
          holds or does not hold at a particular state. The following is the
          formal definition of fact $f$ in state $\sigma$:

          \begin{quote}
            $f^{\sigma}$ = $[\lnot]$$\alpha$, $\alpha$ $\in$ ${\cal A}^{\sigma}$
          \end{quote}

      \subsubsection{Translating Language ${\cal L}$ to Language ${\cal L^{*}}$}

        \begin{definition}
          Given a domain description ${\cal D}_{\cal L}$ of language
          ${\cal L}$, $Tran$(${\cal D}_{\cal L}$) is defined as the
          extended logic program ${\cal L}^{*}$ translation of language
          ${\cal L}$. The domain description ${\cal D}_{\cal L}$ is said to be
          {\em consistent} if and only if $Trans$(${\cal D}_{\cal L}$) has
          a consistent answer set.
        \end{definition}

        Before we can fully define the $Trans$(${\cal D}_{\cal L}$), we must
        first define the following functions:

        \paragraph{}

          The $CopyAtom$ function takes two arguments: an atom $\hat{\alpha}$
          of language ${\cal L}^{*}$ at some state $\sigma$ and another state
          $\sigma'$. The function returns an equivalent atom of the same type
          and with the same entities, but in the new state specified.

          \begin{quote}
            $CopyAtom$($\hat{\alpha}$, $\sigma'$)

            =
            \begin{math}
              \begin{cases}
                \mbox{$\hat{holds}$($s$, $a$, $o$, $\sigma'$), if $\hat{\alpha}$ = $\hat{holds}$($s$, $a$, $o$, $\sigma$)} \\
                \mbox{$\hat{memb}$($e$, $g$, $\sigma'$), if $\hat{\alpha}$ = $\hat{memb}$($e$, $g$, $\sigma$)} \\
                \mbox{$\hat{subst}$($g_{1}$, $g_{2}$, $\sigma'$), if $\hat{\alpha}$ = $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$)}
              \end{cases}
            \end{math}
          \end{quote}

        \paragraph{}

          Another function, $TransAtom$, takes an atom $\alpha$ of language
          ${\cal L}$ and an arbitrary state $\sigma$ and returns the equivalent
          atom of language ${\cal L}^{*}$.

          \begin{quote}
            $TransAtom$($\alpha$, $\sigma$)

            =
            \begin{math}
              \begin{cases}
                \mbox{$\hat{holds}$($s$, $a$, $o$, $\sigma$), if $\alpha$ = $holds$($s$, $a$, $o$)} \\
                \mbox{$\hat{memb}$($e$, $g$, $\sigma$), if $\alpha$ = $memb$($e$, $g$)} \\
                \mbox{$\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$), if $\alpha$ = $subst$($g_{1}$, $g_{2}$)}
              \end{cases}
            \end{math}
          \end{quote}

        \paragraph{}

          The $TransFact$ function is similar to the $TransAtom$ function, but
          instead of translating an atom, it takes a fact from language
          ${\cal L}$ and a state then returns the equivalent fact in language
          ${\cal L}^{*}$.

        \paragraph{Initial Fact Expression.}

          Translating initial fact expressions of language ${\cal L}$ to
          language ${\cal L}^{*}$ is a trivial procedure: translate each fact
          that make up the initial fact expression of language ${\cal L}$
          with its corresponding equivalent initial state atom of language
          ${\cal L}^{*}$.

          Given an initial fact expression of language ${\cal L}$ that is
          composed of $n$ facts:

          \begin{alltt}
  initially \(f\sb{0}\) && \ldots && \(f\sb{n}\)
          \end{alltt}

          In language ${\cal L}^{*}$, the statement above is represented as:

          \begin{quote}
            $\hat{f_{0}}$ $\leftarrow$

            $\vdots$

            $\hat{f_{n}}$ $\leftarrow$

            where $\hat{f_{i}}$ $=$ $TransFact$($f_{i}$, $S_{0}$),
            $0$ $\leq$ $i$ $\leq$ $n$
          \end{quote}

          For example, given the following language ${\cal L}$ $initially$
          statements:

          \begin{verbatim}
  initially
    holds(admins, exec, system_tools);
  initially
    holds(admins, read, system_data);
  initially
    memb(alice, admins) &&
    memb(bob, admins);
          \end{verbatim}

        In language ${\cal L}^{*}$, the above statements are translated to:

        \begin{quote}
          $\hat{holds}$($admins$, $exec$, $system\_tools$, $S_{0}$) $\leftarrow$

          $\hat{holds}$($admins$, $read$, $system\_data$, $S_{0}$) $\leftarrow$

          $\hat{memb}$($alice$, $admins$, $S_{0}$) $\leftarrow$

          $\hat{memb}$($bob$, $admins$, $S_{0}$) $\leftarrow$
        \end{quote}

        \paragraph{Constraint Rules.}

          Each constraint rule in language ${\cal L}$ is expressed as a series
          of logical rules in language ${\cal L}^{*}$. Given that all variable
          occurrences have been grounded to entity identifiers, a constraint in
          language ${\cal L}$, with $m$, $n$, $o$ $\geq$ $0$ may be represented
          as:

          \begin{alltt}
  always \(a\sb{0}\) && \ldots && \(a\sb{m}\)
  implied by \(b\sb{0}\) && \ldots && \(b\sb{n}\)
  with absence \(c\sb{0}\) && \ldots && \(c\sb{o}\)
          \end{alltt}

          Each fact in the $always$ clause of language ${\cal L}$ corresponds
          to a new rule, where it is the consequent. Each of these new rules
          will have expression $b$ in the $implied$ $by$ clause as the positive
          premise and the expression $c$ in the $with$ $absence$ clause as the
          negative premise.

          \begin{quote}
            $a_{0}$ $\leftarrow$
            $b_{0}$, \ldots, $b_{n}$,
            $not$ $c_{0}$, \ldots, $not$ $c_{o}$

            $\vdots$

            $a_{m}$ $\leftarrow$
            $b_{0}$, \ldots, $b_{n}$,
            $not$ $c_{0}$, \ldots, $not$ $c_{o}$
          \end{quote}

          Under the definition of constraints, each of the rules above must be
          made to hold in all states as defined by the sequence list $\psi$.
          This can be accomplished by translating each of the rules above to
          a set of $|\psi|$ rules, one for each state.

           \begin{quote}
            $\hat{a}^{S_{0}}_{0}$ $\leftarrow$
            $\hat{b}^{S_{0}}_{0}$, \ldots, $\hat{b}^{S_{0}}_{n}$,
            $not$ $\hat{c}^{S_{0}}_{0}$, \ldots, $not$ $\hat{c}^{S_{0}}_{o}$

            $\vdots$

            $\hat{a}^{S_{|\psi|}}_{0}$ $\leftarrow$
            $\hat{b}^{S_{|\psi|}}_{0}$, \ldots, $\hat{b}^{S_{|\psi|}}_{n}$,
            $not$ $\hat{c}^{S_{|\psi|}}_{0}$, \ldots, $not$ $\hat{c}^{S_{|\psi|}}_{o}$

            $\vdots$

            $\hat{a}^{S_{0}}_{m}$ $\leftarrow$
            $\hat{b}^{S_{0}}_{0}$, \ldots, $\hat{b}^{S_{0}}_{n}$,
            $not$ $\hat{c}^{S_{0}}_{0}$, \ldots, $not$ $\hat{c}^{S_{0}}_{o}$

            $\vdots$

            $\hat{a}^{S_{|\psi|}}_{m}$ $\leftarrow$
            $\hat{b}^{S_{|\psi|}}_{0}$, \ldots, $\hat{b}^{S_{|\psi|}}_{n}$,
            $not$ $\hat{c}^{S_{|\psi|}}_{0}$, \ldots, $not$ $\hat{c}^{S_{|\psi|}}_{o}$

            where

            $\hat{a}^{\sigma}_{i}$ $=$ $TransFact$($a_{i}$, $\sigma$),
            $0$ $\leq$ $i$ $\leq$ $m$,

            $\hat{b}^{\sigma}_{j}$ $=$ $TransFact$($b_{j}$, $\sigma$),
            $0$ $\leq$ $j$ $\leq$ $n$,

            $\hat{c}^{\sigma}_{k}$ $=$ $TransFact$($c_{k}$, $\sigma$),
            $0$ $\leq$ $k$ $\leq$ $o$,

            $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
          \end{quote}

          The example below shows how the following language ${\cal L}$ code
          fragment is translated to language ${\cal L}^{*}$:

          \begin{verbatim}
  always
    holds(alice, read, secret_data) &&
    holds(alice, write, secret_data)
  implied by
    memb(alice, admin)
  with absence
    !holds(alice, read, secret_data);
          \end{verbatim}

          Given 3 policy update references in the sequence list $\psi$
          (i.e. $|\psi|$ $=$ $3$), the language ${\cal L}^{*}$ equivalent is as
          follows:

          \begin{quote}
            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, secret\_data, S_{0}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{0}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{0})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, secret\_data, S_{0}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{0}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{0})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, secret\_data, S_{1}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{1}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{1})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, secret\_data, S_{1}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{1}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{1})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, secret\_data, S_{2}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{2}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{2})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, secret\_data, S_{2}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{2}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{2})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, secret\_data, S_{3}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{3}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{3})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, secret\_data, S_{3}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{3}), \\
                 & not \lnot \hat{holds}(alice, read, secret\_data, S_{3})
              \end{aligned}
            \end{math}

          \end{quote}

        \paragraph{Policy Updates.}

          With all occurrences of variable place-holders grounded to entity
          identifiers, a policy update $u$, as defined by language ${\cal L}$
          is in the form:

          \begin{quote}
            $u$ causes $a_{0}$ \&\& \ldots \&\& $a_{m}$
            if $b_{0}$ \&\& \ldots \&\& $b_{n}$
          \end{quote}

          In language ${\cal L}^{*}$, such policy updates may be represented as
          a set of implications, with each fact $a$ in the postcondition
          expression as the consequent and precondition expression $b$ as the
          premise. However, the translation process must also take into account
          that the premise of the implication holds in the state before the
          policy update is applied and that the consequent holds in the state
          after the application.

          \begin{quote}
            $\hat{a}_{0}$ $\leftarrow$ $\hat{b}_{0}$, \ldots, $\hat{b}_{n}$

            $\vdots$

            $\hat{a}_{m}$ $\leftarrow$ $\hat{b}_{0}$, \ldots, $\hat{b}_{n}$

            where

            $\hat{a}_{i}$ $=$ $TransFact$($a_{i}$, $Result$($u$, $\sigma$)),
            $0$ $\leq$ $i$ $\leq$ $m$,

            $\hat{b}_{j}$ $=$ $TransFact$($b_{j}$, $\sigma$),
            $0$ $\leq$ $j$ $\leq$ $n$
          \end{quote}

          For example, given the following 2 language ${\cal L}$ policy update
          definitions:

          \begin{verbatim}
  grant_read()
    causes
      holds(alice, read, file)
    if
      memb(alice, readers);

  grant_write()
    causes
      holds(alice, write, file)
    if
      memb(alice, writers);
          \end{verbatim}

          Given sequence list $\psi$ $=$ \{$grant\_read$, $grant\_write$\},
          the above statements are written in language ${\cal L}^{*}$ as:

          \begin{quote}
            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                & \hat{memb}(alice, readers, S_{0})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, file, S_{2}) \leftarrow \\
                & \hat{memb}(alice, writers, S_{1})
              \end{aligned}
            \end{math}
          \end{quote}

        \paragraph{Additional Constraints.}

          In addition to the above translations, there are a few other implicit
          constraint rules implied by language ${\cal L}$ that needs to be
          explicitly defined in language ${\cal L}^{*}$.

          \subparagraph{Inheritance rules.}

            All properties held by a group is inherited by all the members and
            subsets of that group. This rule is easy to apply for subject group
            entities. However, careful attention must be given to access right
            and object groups. A subject holding an access right for an object
            group implies that that subject also holds that access right for
            all objects in the object group. Similarly, a subject holding an
            access right group for a particular object implies that the subject
            holds all access rights contained in the access right group for
            that object.

            A conflict is encountered when a particular property is to be
            inherited by an entity from a group of which it is a member or
            subset, and the contained entity already holds the negation of
            that property. This conflict is resolved by giving negative facts
            higher precedence over its positive counterpart: by allowing member
            or subset entities to inherit its parent group's properties only if
            the entities do not already hold the negation of those properties.

            The following are the inheritance constraint rules to allow the
            properties held by a group to propagate to its members and
            subsets that do not already hold the negation of the properties.

            \begin{enumerate}
              \item
                Subject Group Membership Inheritance

                \begin{math}
                  \begin{aligned}[t]
                    \hat{holds}(s_{s}, a, o, \sigma) \leftarrow &
                    \hat{holds}(s_{g}, a, o, \sigma), \\
                    & \hat{memb}(s_{s}, s_{g}, \sigma), \\
                    & not \lnot \hat{holds}(s_{s}, a, o, \sigma) \\
                    \lnot \hat{holds}(s_{s}, a, o, \sigma) \leftarrow &
                    \lnot \hat{holds}(s_{g}, a, o, \sigma), \\
                    & \hat{memb}(s_{s}, s_{g}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($s_{s}$, $s_{g}$, $a$, $o$, $\sigma$), where

                $s_{s} \in {\cal E}_{ss}$,
                $s_{g} \in {\cal E}_{sg}$,
                $a \in {\cal E}_{a}$,
                $o \in {\cal E}_{o}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$

              \item
                Access Right Group Membership Inheritance

                \begin{math}
                  \begin{aligned}[t]
                    \hat{holds}(s, a_{s}, o, \sigma) \leftarrow &
                    \hat{holds}(s, a_{g}, o, \sigma), \\
                    & \hat{memb}(a_{s}, a_{g}, \sigma), \\
                    & not \lnot \hat{holds}(s, a_{s}, o, \sigma) \\
                    \lnot \hat{holds}(s, a_{s}, o, \sigma) \leftarrow &
                    \lnot \hat{holds}(s, a_{g}, o, \sigma), \\
                    & \hat{memb}(a_{s}, a_{g}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($s$, $a_{s}$, $a_{g}$, $o$, $\sigma$), where

                $s \in {\cal E}_{s}$,
                $a_{s} \in {\cal E}_{as}$,
                $a_{g} \in {\cal E}_{ag}$,
                $o \in {\cal E}_{o}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$

              \item
                Object Group Membership Inheritance

                \begin{math}
                  \begin{aligned}[t]
                    \hat{holds}(s, a, o_{s}, \sigma) \leftarrow &
                    \hat{holds}(s, a, o_{g}, \sigma), \\
                    & \hat{memb}(o_{s}, o_{g}, \sigma), \\
                    & not \lnot \hat{holds}(s, a, o_{s}, \sigma) \\
                    \lnot \hat{holds}(s, a, o_{s}, \sigma) \leftarrow &
                    \lnot \hat{holds}(s, a, o_{g}, \sigma), \\
                    & \hat{memb}(o_{s}, o_{g}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($s$, $a$, $o_{s}$, $o_{g}$, $\sigma$) where

                $s \in {\cal E}_{s}$,
                $a \in {\cal E}_{a}$,
                $o_{s} \in {\cal E}_{os}$,
                $o_{g} \in {\cal E}_{og}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$

              \item
                Subject Group Subset Inheritance

                \begin{math}
                  \begin{aligned}[t]
                    \hat{holds}(s_{g1}, a, o, \sigma) \leftarrow &
                    \hat{holds}(s_{g2}, a, o, \sigma), \\
                    & \hat{subst}(s_{g1}, s_{g2}, \sigma), \\
                    & not \lnot \hat{holds}(s_{g1}, a, o, \sigma) \\
                    \lnot \hat{holds}(s_{g1}, a, o, \sigma) \leftarrow &
                    \lnot \hat{holds}(s_{g2}, a, o, \sigma), \\
                    & \hat{subst}(s_{g1}, s_{g2}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($s_{g1}$, $s_{g2}$, $a$, $o$, $\sigma$), where

                $s_{g1}, s_{g2} \in {\cal E}_{sg}$,
                $a \in {\cal E}_{a}$,
                $o \in {\cal E}_{o}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$

              \item
                Access Right Group Subset Inheritance

                \begin{math}
                  \begin{aligned}[t]
                    \hat{holds}(s, a_{g1}, o, \sigma) \leftarrow &
                    \hat{holds}(s, a_{g2}, o, \sigma), \\
                    & \hat{subst}(a_{g1}, a_{g2}, \sigma), \\
                    & not \lnot \hat{holds}(s, a_{g1}, o, \sigma) \\
                    \lnot \hat{holds}(s, a_{g1}, o, \sigma) \leftarrow &
                    \lnot \hat{holds}(s, a_{g2}, o, \sigma), \\
                    & \hat{subst}(a_{g1}, a_{g2}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($s$, $a_{g1}$, $a_{g2}$, $o$, $\sigma$), where

                $s \in {\cal E}_{s}$,
                $a_{g1}, a_{g2} \in {\cal E}_{ag}$,
                $o \in {\cal E}_{o}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$

              \item
                Object Group Subset Inheritance

                \begin{math}
                  \begin{aligned}[t]
                    \hat{holds}(s, a, o_{g1}, \sigma) \leftarrow &
                    \hat{holds}(s, a, o_{g2}, \sigma), \\
                    & \hat{subst}(o_{g1}, o_{g2}, \sigma), \\
                    & not \lnot \hat{holds}(s, a, o_{g1}, \sigma) \\
                    \lnot \hat{holds}(s, a, o_{g1}, \sigma) \leftarrow &
                    \lnot \hat{holds}(s, a, o_{g2}, \sigma), \\
                    & \hat{subst}(o_{g1}, o_{g2}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($s$, $a$, $o_{g1}$, $o_{g2}$, $\sigma$), where

                $s \in {\cal E}_{s}$,
                $a \in {\cal E}_{a}$,
                $o_{g1}, o_{g2} \in {\cal E}_{og}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$
            \end{enumerate}

          \subparagraph{Transitivity rules.}

            Given three groups $G$, $G'$ and $G''$. If $G$ is a subset of $G'$
            and $G'$ is a subset of $G''$, then $G$ must also be a subset of
            $G''$. The following rules ensure that the transitive property of
            subject, access right and object groups hold:

            \begin{enumerate}
              \item
                Subject Group Transitivity

                \begin{math}
                  \begin{aligned}[t]
                    \hat{subst}(sg_{1}, sg_{3}, \sigma) \leftarrow &
                    \hat{subst}(sg_{1}, sg_{2}, \sigma), \\
                    & \hat{subst}(sg_{2}, sg_{3}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($sg_{1}$, $sg_{2}$, $sg_{3}$, $\sigma$), where

                $sg_{1}, sg_{2}, sg_{3} \in {\cal E}_{sg}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$

              \item
                Access Right Group Transitivity

                \begin{math}
                  \begin{aligned}[t]
                    \hat{subst}(ag_{1}, ag_{3}, \sigma) \leftarrow &
                    \hat{subst}(ag_{1}, ag_{2}, \sigma), \\
                    & \hat{subst}(ag_{2}, ag_{3}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($ag_{1}$, $ag_{2}$, $ag_{3}$, $\sigma$), where

                $ag_{1}, ag_{2}, ag_{3} \in {\cal E}_{ag}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$

              \item
                Object Group Transitivity

                \begin{math}
                  \begin{aligned}[t]
                    \hat{subst}(og_{1}, og_{3}, \sigma) \leftarrow &
                    \hat{subst}(og_{1}, og_{2}, \sigma), \\
                    & \hat{subst}(og_{2}, og_{3}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall$ ($og_{1}$, $og_{2}$, $og_{3}$, $\sigma$), where

                $og_{1}, og_{2}, og_{3} \in {\cal E}_{og}$,
                $S_{0} \leq \sigma \leq S_{|\psi|}$
            \end{enumerate}

          \subparagraph{Inertial rules.}

            Intuitively, all facts in the current state that are not affected
            by a policy update should be carried over to the next state after
            the update. In language ${\cal L}^{*}$, this rule must be
            explicitly stated as a constraint. Formally, the inertial rules
            are expressed as follows:

            \begin{quote}
              $\hat{\alpha}'$ $\leftarrow$ $\hat{\alpha}$, $not$ $\lnot$ $\hat{\alpha}'$

              $\lnot$ $\hat{\alpha}'$ $\leftarrow$ $\lnot$ $\hat{\alpha}$, $not$ $\hat{\alpha}'$

              $\forall$($\hat{\alpha}$,$u$), where
              $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$,
              $u$ $\in$ $\psi$,

              $\hat{\alpha}'$ = $CopyAtom$($\hat{\alpha}$, $Result$($u$, $\sigma$))
            \end{quote}

        \begin{example}
          \label{ex-2}
          The following shows the language ${\cal L}$ program listing in
          Example \ref{ex-1},  translated into language ${\cal L}^{*}$.

          \begin{enumerate}
            \item
              Initial State Facts

              $\hat{memb}(alice, grp3, S_{0}) \leftarrow$

              $\hat{holds}(grp1, read, file,S_{0}) \leftarrow$

              $\hat{subst}(grp3, grp2) \leftarrow$

              $\hat{subst}(grp2, grp1) \leftarrow$

            \item
              Constraints

              \begin{math}
                \begin{aligned}[t]
                  % constraints (S0)
                  \hat{holds}&(grp1, write, file, S_{0}) \leftarrow \\
                  & \hat{holds}(grp1, read, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp1, write, file, S_{0}) \\
                  % constraints (S1)
                  \hat{holds}&(grp1, write, file, S_{1}) \leftarrow \\
                  & \hat{holds}(grp1, read, file, S_{1}), \\
                  & not \lnot \hat{holds}(grp1, write, file, S_{1})
                \end{aligned}
              \end{math}

            \item
              Policy Update

              \begin{math}
                \lnot \hat{holds}(grp1, read, file, S_{1}) \leftarrow
              \end{math}

            \item
              Inheritance Rules

              \begin{math}
                \begin{aligned}[t]
                  % inheritance rules (positive, read, S0)
                  \hat{holds}&(alice, read, file, S_{0}) \leftarrow \\
                  & \hat{holds}(grp1, read, file, S_{0}), \\
                  & \hat{memb}(alice, grp1, S_{0}), \\
                  & not \lnot \hat{holds}(alice, read, file, S_{0}) \\
                  % inheritance rules (negative, read, S0)
                  \lnot \hat{holds}&(alice, read, file, S_{0}) \leftarrow \\
                  & \lnot \hat{holds}(grp1, read, file, S_{0}), \\
                  & \hat{memb}(alice, grp1, S_{0})
                \end{aligned}
              \end{math}

              \begin{math}
                \begin{aligned}[t]
                  % inheritance rules (positive, write, S0)
                  \hat{holds}&(alice, write, file, S_{0}) \leftarrow \\
                  & \hat{holds}(grp1, write, file, S_{0}), \\
                  & \hat{memb}(alice, grp1, S_{0}), \\
                  & not \lnot \hat{holds}(alice, write, file, S_{0}) \\
                  % inheritance rules (negative, write, S0)
                  \lnot \hat{holds}&(alice, write, file, S_{0}) \leftarrow \\
                  & \lnot \hat{holds}(grp1, write, file, S_{0}), \\
                  & \hat{memb}(alice, grp1, S_{0})
                \end{aligned}
              \end{math}

              \hspace{1cm} $\vdots$

              \begin{math}
                \begin{aligned}[t]
                  % inheritance rules (positive, read, S1)
                  \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                  & \hat{holds}(grp3, read, file, S_{1}), \\
                  & \hat{memb}(alice, grp3, S_{1}), \\
                  & not \lnot \hat{holds}(alice, read, file, S_{1}) \\
                  % inheritance rules (negative, read, S1)
                  \lnot \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(grp3, read, file, S_{1}), \\
                  & \hat{memb}(alice, grp3, S_{1})
                \end{aligned}
              \end{math}

              \begin{math}
                \begin{aligned}[t]
                  % inheritance rules (positive, write, S1)
                  \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                  & \hat{holds}(grp3, write, file, S_{1}), \\
                  & \hat{memb}(alice, grp3, S_{1}), \\
                  & not \lnot \hat{holds}(alice, write, file, S_{1}) \\
                  % inheritance rules (negative, write, S1)
                  \lnot \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(grp3, write, file, S_{1}), \\
                  & \hat{memb}(alice, grp3, S_{1})
                \end{aligned}
              \end{math}

            \item
              Transitivity Rules

              \begin{math}
                \begin{aligned}[t]
                  \hat{subst}&(grp1, grp1, S_{0}) \leftarrow \\
                  & \hat{subst}(grp1, grp1, S_{0}), \\
                  & \hat{subst}(grp1, grp1, S_{0})
                \end{aligned}
              \end{math}

              \hspace{1cm} $\vdots$

              \begin{math}
                \begin{aligned}[t]
                  \hat{subst}&(grp3, grp3, S_{1}) \leftarrow \\
                  & \hat{subst}(grp3, grp3, S_{1}), \\
                  & \hat{subst}(grp3, grp3, S_{1})
                \end{aligned}
              \end{math}

            \item
              Inertial Rules

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule holds(alice, read, file)
                  \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                  & \hat{holds}(alice, read, file, S_{0}), \\
                  & not \lnot \hat{holds}(alice, read, file, S_{1}) \\
                  % inertial rule !holds(alice, read, file)
                  \lnot \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(alice, read, file, S_{0}), \\
                  & not \lnot \hat{holds}(alice, read, file, S_{1})
                \end{aligned}
              \end{math}

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule holds(alice, write, file)
                  \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                  & \hat{holds}(alice, write, file, S_{0}), \\
                  & not \lnot \hat{holds}(alice, write, file, S_{1}) \\
                  % inertial rule !holds(alice, write, file)
                  \lnot \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(alice, write, file, S_{0}), \\
                  & not \lnot \hat{holds}(alice, write, file, S_{1})
                \end{aligned}
              \end{math}

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule holds(grp1, read, file)
                  \hat{holds}&(grp1, read, file, S_{1}) \leftarrow \\
                  & \hat{holds}(grp1, read, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp1, read, file, S_{1}) \\
                  % inertial rule !holds(grp1, read, file)
                  \lnot \hat{holds}&(grp1, read, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(grp1, read, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp1, read, file, S_{1})
                \end{aligned}
              \end{math}

              \hspace{1cm} $\vdots$

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule holds(grp3, read, file)
                  \hat{holds}&(grp3, read, file, S_{1}) \leftarrow \\
                  & \hat{holds}(grp3, read, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp3, read, file, S_{1}) \\
                  % inertial rule !holds(grp3, read, file)
                  \lnot \hat{holds}&(grp3, read, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(grp3, read, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp3, read, file, S_{1})
                \end{aligned}
              \end{math}

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule holds(grp1, write, file)
                  \hat{holds}&(grp1, write, file, S_{1}) \leftarrow \\
                  & \hat{holds}(grp1, write, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp1, write, file, S_{1}) \\
                  % inertial rule !holds(grp1, write, file)
                  \lnot \hat{holds}&(grp1, write, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(grp1, write, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp1, write, file, S_{1})
                \end{aligned}
              \end{math}

              \hspace{1cm} $\vdots$

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule holds(grp3, write, file)
                  \hat{holds}&(grp3, write, file, S_{1}) \leftarrow \\
                  & \hat{holds}(grp3, write, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp3, write, file, S_{1}) \\
                  % inertial rule !holds(grp3, write, file)
                  \lnot \hat{holds}&(grp3, write, file, S_{1}) \leftarrow \\
                  & \lnot \hat{holds}(grp3, write, file, S_{0}), \\
                  & not \lnot \hat{holds}(grp3, write, file, S_{1})
                \end{aligned}
              \end{math}

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule memb(alice, grp1)
                  \hat{memb}&(alice, grp1, S_{1}) \leftarrow \\
                  & \hat{memb}(alice, grp1, S_{0}), \\
                  & not \lnot \hat{memb}(alice, grp1, S_{1}) \\
                  % inertial rule !memb(alice, grp1)
                  \lnot \hat{memb}&(alice, grp1, S_{1}) \leftarrow \\
                  & \lnot \hat{memb}(alice, grp1, S_{0}), \\
                  & not \hat{memb}(alice, grp1, S_{1})
                \end{aligned}
              \end{math}

              \hspace{1cm} $\vdots$

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule memb(alice, grp3)
                  \hat{memb}&(alice, grp3, S_{1}) \leftarrow \\
                  & \hat{memb}(alice, grp3, S_{0}), \\
                  & not \lnot \hat{memb}(alice, grp3, S_{1}) \\
                  % inertial rule !memb(alice, grp3)
                  \lnot \hat{memb}&(alice, grp3, S_{1}) \leftarrow \\
                  & \lnot \hat{memb}(alice, grp3, S_{0}), \\
                  & not \hat{memb}(alice, grp3, S_{1})
                \end{aligned}
              \end{math}

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule subst(grp1, grp1)
                  \hat{subst}&(grp1, grp1, S_{1}) \leftarrow \\
                  & \hat{subst}(grp1, grp1, S_{0}), \\
                  & not \lnot \hat{subst}(grp1, grp1, S_{1}) \\
                  % inertial rule !subst(grp1, grp1)
                  \lnot \hat{subst}&(grp1, grp1, S_{1}) \leftarrow \\
                  & \lnot \hat{memb}(grp1, grp1, S_{0}), \\
                  & not \hat{memb}(grp1, grp1, S_{1})
                \end{aligned}
              \end{math}

              \hspace{1cm} $\vdots$

              \begin{math}
                \begin{aligned}[t]
                  % inertial rule subst(grp3, grp3)
                  \hat{subst}&(grp3, grp3, S_{1}) \leftarrow \\
                  & \hat{subst}(grp3, grp3, S_{0}), \\
                  & not \lnot \hat{subst}(grp3, grp3, S_{1}) \\
                  % inertial rule !subst(grp3, grp3)
                  \lnot \hat{subst}&(grp3, grp3, S_{1}) \leftarrow \\
                  & \lnot \hat{memb}(grp3, grp3, S_{0}), \\
                  & not \hat{memb}(grp3, grp3, S_{1}) \\
                \end{aligned}
              \end{math}
          \end{enumerate}
        \end{example}
      \subsection{Evaluation}

        \begin{definition}
          Given a consistent domain description ${\cal D}_{\cal L}$, ground
          query expression $\phi$ and a finite sequence list $\psi$, we say the
          query $\phi$ holds in ${\cal D}_{\cal L}$ after the policy updates
          in the sequence list $\phi$ has been applied:

          \begin{quote}
            ${\cal D}_{\cal L}$ $\models$ \{$\phi$, $\psi$\}
          \end{quote}

          \noindent if and only if for every atom $\alpha$ in $\phi$, $\alpha$
          $\in$ ${\cal A}^{|\psi|}$, [$\lnot$] $\alpha$ is in every answer
          set of $Trans$(${\cal D}_{\cal L}$)
        \end{definition}

    \begin{example}
      \label{ex-3}
      Given the language ${\cal L}$ code listing in example \ref{ex-1} and its
      semantic translation in example \ref{ex-2}, the following shows the
      results of the query evaluations:

      \begin{quote}
        \begin{math}
          \begin{aligned}[t]
            &holds(grp1, write, file) ? TRUE. \\
            &holds(grp1, read, file) ? FALSE. \\
            &holds(alice, write, file) ? TRUE. \\
            &holds(alice, read, file) ? FALSE.
          \end{aligned}
        \end{math}
      \end{quote}
    \end{example}

  \section{Implementation}

    \subsection{System Structure}

    \begin{figure}[ht]
      \begin{center}
        \epsfig{file=system.eps}
        \caption{Structure of PolicyUpdater}
        \label{fig-1}
      \end{center}
    \end{figure}

      As shown in figure \ref{fig-1}, the PolicyUpdater system works in
      collaboration with an authorisation agent program that queries the
      policy base to determine whether to allow users access to resources.
      Through an authorisation agent program, the PolicyUpdater system also
      allows administrators to dynamically update the policy base.

      \subsubsection{Parsers}

        \paragraph{Policy Parser.}

          The policy parser is responsible for correctly reading the policy
          file into the core PolicyUpdater system. The parser ensures that
          the policy file strictly adheres to the language $\cal{L}$ syntax
          then systematically stores entity identifiers into the symbol table
          and initial state facts, constraint expressions and policy update
          definitions are stored into their respective tables in the policy
          base.

        \paragraph{Agent Parser.}

          The agent parser is the direct link between the core PolicyUpdater
          system and the authorisation agent program. The parser's sole purpose
          is to receive language $\cal{L}$ directives from an agent, perform
          the directive upon the policy base and return a reply if the
          directive requires one. Such directives may be to query the policy
          base or to manipulate the policy update sequence table.

      \subsubsection{Data Structures}

        As a program of language ${\cal L}$ is parsed, each statement
        containing entity declarations, facts, constraint rules and policy
        updates must be stored into a structure before the translation process
        is started. As shown in appendix \ref{app-1}, the structure is composed
        of the symbol table, the policy base and the policy update sequence
        table.

        The symbol table is used to store all entity identifiers defined in the
        policy, while the rest of the policy definitions are stored into the
        policy base. On the other hand, the sequence of policy update
        directives are stored separately into the update table.

    \subsection{System Processes}

      The processes presented in this section shows how the language
      ${\cal L}$ policy stored in the data structures is translated into a
      normal logic program, how it can be updated dynamically and how it can
      be manipulated to evaluate queries. The flowchart in figure \ref{fig-2}
      gives an overview of the system processes.

      \begin{figure}[ht]
        \begin{center}
          \epsfig{file=flowchart.eps}
          \caption{System Flowchart}
          \label{fig-2}
        \end{center}
      \end{figure}

      \subsubsection{Grounding Constraint Variables}

        While constraints are in the process of being added into the
        constraints table, each variable identifier that occurs within each
        constraint is grounded by replacing that constraint with a set of
        constraints wherein each instance of the variable is replaced by all
        entity identifiers defined in the symbol table. Note that only those
        entity identifiers that are valid for each fact in the current
        constraint are used to replace the variable (e.g. only singular subject entity
        identifiers are used to replace an element variable occurring in a
        subject member fact).

        For example, given that the symbol table contains three singular
        subject entity identifiers: $alice$, $bob$ and $charlie$, and the
        following constraint:

        \begin{verbatim}
  always holds(SSUB, write, file)
    implied by
      holds(SSUB, read, file) &&
      memb(SSUB, students)
    with absence
      !holds(SSUB, write, file)
        \end{verbatim}

        Grounding the constraint above yields three new constraints, each
        replacing occurrences of the variable $SSUB$ with $alice$, $bob$ and
        $charlie$, respectively.

      \subsubsection{Policy Updates}

        In the semantics section, it is shown that policy updates are performed
        by treating each update as a constraint. This constraint is composed of
        a premise, which are the preconditions in the current state and a
        consequent, which is the postcondition of the resulting state after the
        application of the policy update. The resulting state in this procedure
        represents the updated policy.

        The most crucial step in performing a policy update is the translation
        of the policy updates into normal logic program constraints. This step
        involves identifying which policy updates are to be applied from the
        update sequence table and then composing the required constraint from
        the update definition the policy base. Once the policy update
        constraints are composed, they are then treated as any other
        constraint rules and are translated with the rest of the policy into
        a normal logic program.

      \subsubsection{Translation to Normal Logic Program}

        The semantics of language ${\cal L}$ shows that any language
        ${\cal L}$ program $P^{\cal L}$ can be translated into an equivalent
        extended logic program $P^{\cal{L^{*}}}$ then translated again into
        an equivalent normal logic program suitable for manipulation using
        the stable model semantics. However, the implementation of such
        translations can be greatly simplified by translating language
        ${\cal L}$ programs directly into normal logic programs.

        \paragraph{Removal of Classical Negation.}

          The removal of classical negation from facts of language ${\cal L}$
          is a straightforward procedure: each classically negated fact
          $\lnot$ $f$ is replaced by a new and unique positive fact $f'$ that
          represents the negation of fact $f$. To preserve the consistency of
          the policy base for all facts $f$ in the domain, the following
          constraint rule must be added:

          \begin{quote}
            $FALSE$ $\leftarrow$ $f$, $f'$
          \end{quote}

          The removal process is achieved by adding a boolean parameter to
          each fact to indicate whether the fact is classically negated or
          not.

          For example, given the fact:

          \begin{quote}
            $\lnot$ $holds$($alice$, $exec$, $file$)
          \end{quote}

          To remove classical negation, this fact is replaced by:

          \begin{quote}
            $holds$($alice$, $exec$, $file$, $false$)
          \end{quote}

          For consistency, the following constraint is added:

          \begin{quote}
            \begin{math}
              \begin{aligned}[t]
                FALSE \leftarrow & holds(alice, exec, file, true), \\
                & holds(alice, exec, file, false)
              \end{aligned}
            \end{math}
          \end{quote}

        \paragraph{Representing Facts in Propositional Form.}

          A fact expressed in normal logic program form is composed of the
          atom relation, the state in which it holds and a boolean flag to
          indicate classical negation. For notational simplicity, this tuple
          may be represented by a unique positive integer $i$, where $0$ $\leq$
          $i$ $<$ $n$ ($n$ is the total number of possible facts in the
          domain). The process of translating facts of language ${\cal L}$
          into normal logic program form is achieved by performing the
          following steps:

          \subparagraph{Enumerate all possible atoms.}
            By using all the entities in the symbol table, all possible
            language ${\cal L}$ atoms may be enumerated by grouping together
            2 to 3 entities together. All possible atoms of type $holds$ are
            generated by enumerating all possible combinations of subject,
            access right and object entities. The set of $member$ atoms is
            generated from all the different combinations of singular and
            group entities of types subject, access right and object.
            Similarly, the set of $subset$ atoms is derived from different
            subject, access right and object group pair combinations.

          \subparagraph{Arrange the atoms in a predefined order.}
            This procedure relies on the assumption that the list of all
            possible atoms derived from the step above is arranged in a
            predefined order. In this step we ensure that the atoms are
            enumerated in the following order (first to last): $holds$,
            $subject$ $member$, $access$ $right$ $member$, $object$ $member$,
            $subject$ $subset$, $access$ $right$ $subset$ and $object$
            $subset$. In addition to the ordering of atom types, atoms of each
            type are themselves sorted according to the order in which their
            entities appear in the symbol table.

          \subparagraph{Assign an ordinal index for each enumerated atom.}
            Since the enumerated list of atoms are ordered, consecutive
            positive integers may be assigned to each atom as an ordinal
            index $i$, where $0$ $\leq$ $i$ $<$ $n$ ($n$ is the total
            number of atoms enumerated).

          \subparagraph{Extend indexing procedure to represent facts.} The
            indices produced in the above step represent positive facts. Since
            negative facts are just mirror images of their positive
            counterparts, their indices are calculated by adding $n$ to the
            indices of the corresponding positive facts. Furthermore, this
            procedure is again extended to represent the states of the facts.
            The process is similar: indices $i$ ($0$ $\leq$ $i$ $<$ $2n$)
            represent facts of state $S_{0}$, indices $i$ ($2n$ $\leq$ $i$ $<$
            $4n$) represent facts of state $S_{1}$, and so on.

          The steps outlined above may be summarised by the function below:

          \begin{quote}
            $index$ = $encode$($ent1$, $ent2$, $ent3$, $state$, $truth$)
          \end{quote}

        \paragraph{Generating the Normal Logic Program from the Policy Base.}

          With the language ${\cal L}$ policy elements stored into the storage
          structure (see appendix \ref{app-1}), a normal logic program can
          then be generated for evaluation. Using the translation methods
          described in the semantics section and the method for eliminating
          classical negation, each initial state expression, constraint rule
          and policy update becomes a set of simple logical rules. By applying
          the $encode$ function above for each fact in each of these rules,
          a normal logic program is generated.

      \subsubsection{Query Evaluation}

        Once a normal logic program has been generated from the policy stored
        in the storage structure, a set of answer sets may then be generated
        by using the stable model semantics with the
        {\emph smodels}\footnotemark program. Query evaluation then becomes
        possible by checking whether each fact of a given query holds in each
        generated answer set of the normal logic program.

        \footnotetext{Smodels [smodels homepage url]}

        If a given fact indeed holds in all the answer sets, it is then
        evaluated to be true. On the other hand, if the negation of a fact
        holds in every answer set, then it is evaluated to be false. A fact
        or its negation that does not hold in every answer set is neither true
        nor false: inconclusive.

  \section{Conclusion}

    [effectiveness of system/application]

    [future work]

  \begin{thebibliography}{5}
  \end{thebibliography}

  \appendix

  \section{Appendices}

    \subsection{Storage Structures}

      \label{app-1}
      The data structures outlined in this section are used as a storage
      structure to hold the elements of language ${\cal L}$ before any
      operations are performed.

      Each of the tables and lists used in the system inherits from a generic
      ordered and indexed list implementation. Each node in this list holds a
      generic data type that can be used to store strings, an arbitrary data
      type or another list type.

      \subsubsection{Symbol Table.}

        The symbol table is used to store the identifier entities defined in
        the entity identifier declaration section of language ${\cal L}$
        programs. The symbol table is composed of 6 separate string lists:

        \begin{quote}
          \begin{tabular}[t]{|l|l|l|}
            \hline
            \textbf{Field} & \textbf{Type} & \textbf{Description} \\
            \hline
            $ss$ & string list & single subject \\
            \hline
            $sg$ & string list & group subject \\
            \hline
            $as$ & string list & single access right \\
            \hline
            $ag$ & string list & group access right \\
            \hline
            $os$ & string list & single object \\
            \hline
            $og$ & string list & group object \\
            \hline
          \end{tabular}
        \end{quote}

        Each entity identifier are sorted in the above lists according to
        their type, and ordered according to the order in which they are
        declared in the program. Each list is indexed by consecutive
        positive integers starting from zero.

      \subsubsection{Policy Base.}

        When a language ${\cal L}$ program is parsed, each of the facts,
        rules and policy updates must first be stored into the policy base.
        The policy base is composed of 4 tables to store the following:
        initial state facts, constraint rules, policy update definitions and
        the policy update sequence.

        \paragraph{Atoms.}

          The three types of atoms (subject, access right and object) are
          represented as structures of 2 to 3 strings, with each string
          matching an entity identifier in the symbol table.

          \begin{quote}
            \begin{tabular}[t]{|l|l|l|l|}
              \hline
              \textbf{Field} & \textbf{Type} & \textbf{Description} & \\
              \hline
              $sub$ & string & subject entity & {\multirow{3}{*}{\begin{sideways}hol\end{sideways}}} \\
              \cline{1-3}
              $acc$ & string & access right entity & \\
              \cline{1-3}
              $obj$ & string & object entity & \\
              \hline
              \hline
              $elt$ & string & single entity & {\multirow{2}{*}{\begin{sideways}mem\end{sideways}}} \\
              \cline{1-3}
              $grp$ & string & group entity & \\
              \hline
              \hline
              $grp1$ & string & subgroup entity & {\multirow{2}{*}{\begin{sideways}sub\end{sideways}}} \\
              \cline{1-3}
              $grp2$ & string & supergroup entity & \\
              \hline
            \end{tabular}
          \end{quote}

        \paragraph{Facts.}

          Facts are represented as a three-element structure composed of the
          following: polymorphic type which can be any of the three atom
          structures above; a type indicator to specify whether the fact is
          holds, member or subset; and a truth flag, to indicate whether the
          atom is classically negated or not ({\em true} if the fact holds
          and {\em false} if the classical negation of the fact holds.

          \begin{quote}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              \textbf{Field} & \textbf{Type} & \textbf{Description} \\
              \hline
              $atom$ & atom type & polymorphic structure \\
              \hline
              $type$ & \{h$|$m$|$s\} & holds, member or subset \\
              \hline
              $truth$ & boolean & negation indicator \\
              \hline
            \end{tabular}
          \end{quote}

        \paragraph{Expressions.}

          Since expressions are simply conjunctions of facts, they are
          represented as a list of fact structures.

        \paragraph{Initial state facts table.}

          The initial state facts table is represented as a single list of
          fact structures, or an expression. Each fact in all {\em initially}
          statements are added into the initial state facts table.

        \paragraph{Constraint table.}

          The constraint table is represented as a list of constraint
          structures, with each structure composed of the following:

          \begin{quote}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              \textbf{Field} & \textbf{Type} & \textbf{Description} \\
              \hline
              $exp$ & expression type & consequent \\
              \hline
              $pcond$ & expression type & positive premise \\
              \hline
              $ncond$ & expression type & negative premise \\
              \hline
            \end{tabular}
          \end{quote}

        \paragraph{Policy update definition table.}

          Another list of structures is the policy update table. Each element
          structure of this table is composed of the following 4 fields:

          \begin{quote}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              \textbf{Field} & \textbf{Type} & \textbf{Description} \\
              \hline
              $name$ & string & update identifier \\
              \hline
              $vlist$ & ordered string list & variables \\
              \hline
              $pre$ & expression type & precondition \\
              \hline
              $post$ & expression type & postcondition \\
              \hline
            \end{tabular}
          \end{quote}

      \subsubsection{Policy Update Sequence Table.}

        The policy update sequence table is an ordered list of sequence
        structures, each with the following elements:

        \begin{quote}
          \begin{tabular}[t]{|l|l|l|}
            \hline
            \textbf{Field} & \textbf{Type} & \textbf{Description} \\
            \hline
            $name$ & string & update identifier \\
            \hline
            $ilist$ & ordered string list & identifiers \\
            \hline
          \end{tabular}
        \end{quote}


    \subsection{A Case Study: Web Server Application}

      \begin{figure}[ht]
        \begin{center}
          \epsfig{file=app.eps}
          \caption{PolicyUpdater module for Apache}
          \label{fig-3}
        \end{center}
      \end{figure}

      The expressiveness of language $\cal{L}$ and the effectiveness of the
      PolicyUpdater system can best be demonstrated by a web server
      authorisation application. In this application, PolicyUpdater serves as
      an authorisation module for the \emph{Apache}\footnotemark web server.

      \footnotetext{Apache Web Server (\tt http://www.apache.org).}

      Although the PolicyUpdater module do not provide the full functionality
      of Apache's built-in authorisation module \emph{mod\_auth}, it does
      provide a flexible logic-based authorisation mechanism.

      The PolicyUpdater module works by intercepting all authenticated HTTP
      requests made to the web server. Users and groups directly correspond to
      the language $\cal{L}$ subjects, HTTP request methods (i.e. GET, POST,
      etc.) are the access-rights, and files, directories and other resources
      in the document root are the objects. These entities plus any initial
      facts, constraints and update propositions in the policy base make up the
      domain of language $\cal{L}$.

      Figure \ref{fig-3} shows how the PolicyUpdater module works within a
      typical HTTP request. (1) User $s$ makes a HTTP request $a$ for file
      $o$ and is authenticated by Apache through the Basic HTTP Authentication
      Scheme. (2) Once properly authenticated, Apache passes the request tuple
      $\{s, a, o\}$ to the PolicyUpdater module. (3) PolicyUpdater then queries
      the policy base to verify the fact $holds(s, a, o)$ and returns a reply
      (4) back to Apache. If the request is allowed, as determined by the
      module through the policy base, Apache accepts and honours the request
      $a$ to the file $o$ (5) and sends the results back to user $s$ (6).
      Optionally, an Administrator, once properly authenticated can dynamically
      update the policy (7) by altering the update sequence in the policy base.

\end{document}
