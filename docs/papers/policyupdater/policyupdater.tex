\documentclass[10pt, twocolumn]{article}
\usepackage{latex8}
\usepackage{times}
\usepackage{amsmath}

\newtheorem{definition}{Definition}
\newtheorem{examp}{Example}
\newenvironment{example}{\begin{examp}\rm}{\rule{2mm}{2mm}\end{examp}}

\begin{document}
  \title{
    PolicyUpdater -- A System for Dynamic Access Control:  \\
    Formalization, Implementation and a Case Study
  }

  \author{
    Vino Fernando Crescini and Yan Zhang                   \\
    School of Computing and Information Technology         \\
    University of Western Sydney                           \\
    Penrith South DC, NSW 1797, Australia                  \\
    E-mail: \{jcrescin,yan\}@cit.uws.edu.au
  }

  \date{}

  \maketitle

  \begin{abstract}
    [text]
  \end{abstract}

  \section{Introduction}

    \subsection{Overview of Logic-Based Approaches}

    \subsection{Contribution}

    \subsection{Structure of this Paper}

  \section{Language $\cal{L}$}

    \subsection{Syntax}

      [language statements, statement terminators, and comments]

      \subsubsection{Components of Language $\cal{L}$}

        \paragraph{Identifiers.}
          The most basic unit of language $\cal{L}$ is an identifier.
          Identifiers are used to represent the different components of the
          language.  
    
          Identifiers are divided into three main classes:

          \begin{itemize}
            \item
              {\em Entity Identifiers} represent constant entities that make up
              a logical atom. They are divided further into three types, with
              each type again divided into the {\em singular entity} and
              {\em group entity} categories:

              \begin{itemize}
                \item
                  {\em Subjects}: privilege holders (e.g. alice, lecturers,
                  students).
                \item
                  {\em Access Rights}: privilege (e.g. read, write, own).
                \item
                  {\em Objects}: privilege entities (e.g. file, database,
                  directory).
              \end{itemize}

              An entity identifier is defined as a lower-case alpha character,
              followed by 0 to 127 characters of alpha, digit or underscore
              characters. The following regular expression shows the syntax
              of entity identifiers:

              \begin{verbatim}[a-z]([a-zA-Z0-9_]{0,127}\end{verbatim}

            \item
              {\em Policy Update Identifiers} are used for the sole purpose of
              naming a policy update. These identifier names are then used as
              labels to refer to policy update definitions and directives. As
              labels, identifiers of this class occupies a different namespace
              from entity identifiers. For this reason, policy update
              identifiers share the same syntax with entity identifiers:

              \begin{verbatim}[a-z]([a-zA-Z0-9_]{0,127}\end{verbatim}
 
            \item
              {\em Variable Identifiers} are used as entity identifier
              place-holers, and as such, are subject to the entity identifier
              types. Variable identifiers are prefixed with 1 or 2 upper-case
              characters to distinguish them from entity identifiers, followed
              by a number composed of 1 to 6 digits. The upper-case characters
              determines the type of the variable identifier. The following is
              a list of regular expressions for each variable identifier type:

              \begin{itemize}
                \item
                  Subject variables (singular and group)

                  \begin{verbatim}S([0-9]){1,6}\end{verbatim}
                \item
                  Subject variables (singular)

                  \begin{verbatim}SS([0-9]){1,6}\end{verbatim}
                \item
                  Subject variables (group)

                  \begin{verbatim}SG([0-9]){1,6}\end{verbatim}
                \item
                  Access Right variables (singular and group)

                  \begin{verbatim}A([0-9]){1,6}\end{verbatim}
                \item
                  Access Right variables (singular)

                  \begin{verbatim}AS([0-9]){1,6}\end{verbatim}
                \item
                  Access Right variables (group)

                  \begin{verbatim}AG([0-9]){1,6}\end{verbatim}
                \item
                  Object variables (singular and group)

                  \begin{verbatim}O([0-9]){1,6}\end{verbatim}
                \item
                  Object variables (singluar)

                  \begin{verbatim}OS([0-9]){1,6}\end{verbatim}
                \item
                  Object variables (group)

                  \begin{verbatim}OG([0-9]){1,6}\end{verbatim}
              \end{itemize}
          \end{itemize}

        \paragraph{Atoms.}
          An atom is composed of a relation with 2 to 3 entity or variable
          identifiers that represent a logical relationship between the
          entities. There are three types of atoms:

          \begin{itemize}
            \item
              {\em Holds.} An atom of this type states that the subject
              identifier $sub$ holds the access right identifier $acc$
              for the object identifier $obj$.
         
              \begin{verbatim}holds(<sub>, <acc>, <obj>)\end{verbatim}
            \item
              {\em Membership.} This type of atom states that the singular
              identifier $elt$ is a member or element of the group identifier
              $grp$. It is important to note that identifiers $elt$ and $grp$
              must be of the same base type (e.g. subject and subject group).
         
              \begin{verbatim}memb(<elt>, <grp>)\end{verbatim}
            \item
              {\em $Subset$.} The subset atom states that the group identifiers
              $grp1$ and $grp2$ are of the same types and that group $grp1$ is
              a subset of the group $grp2$.

              \begin{verbatim}subst(<grp1>, <grp2>)\end{verbatim}
          \end{itemize}

          Atoms that contain no variables, i.e. composed entirely of entity
          identifiers, are called {\em ground atoms}.

        \paragraph{Facts.}
          A fact makes a claim that the relationship represented by an atom or
          its negation holds in the current context. Facts are negated by the
          use of the negation operator ($!$). The following shows the formal
          syntax of a fact:
 
          \begin{verbatim}[!]<holds_atm>|<memb_atm>|<subst_atm>\end{verbatim}

          Note that facts may be made up of atoms that contain variable
          identifiers. Facts with no variable occurences are called
          {\em ground facts}.
 
        \paragraph{Expressions.}
          An expression is either a fact, or a logical conjunction of facts,
          separated by the double-ampersand characters $\&\&$.

          \begin{verbatim}<fact1> [&& <fact2> [&& ...]]\end{verbatim}

          Expressions that are made up of only ground facts are called
          {\em ground expressions}.

      \subsubsection{Definition Statements}

        \paragraph{Entity Identifier Definition.}

          All entity identifiers (subjects, access rights, objects and groups)
          must first be declared before any other statements to define the
          entity domain of the policy base. The following entity declaration
          syntax illustrates how to define one or more entity identifiers of a
          particular type.

          \begin{verbatim}ident sub|acc|obj[-grp] <e_id>[, ...]];\end{verbatim}

        \paragraph{Initial Fact Definition.}

          The initial facts of the policy base, facts that hold before any
          policy updates are performed, are defined by using the following
          definition syntax:

          \begin{verbatim}initially <ground-exp>;\end{verbatim}

        \paragraph{Constraint Definition.}

          Constraints are logical rules that holds regardless of any changes
          that may occur when the policy base is updated. The constraint rules
          are true in the initial state and remains true after any policy
          update.

          The constraint syntax below shows that for any state of the policy
          base, expression $exp1$ holds if expression $exp2$ is true and there
          is no evidence that $exp3$ is true. The {\em with absence} clause
          allows constraints to behave like default propositions, where the
          absence of proof that an expression holds implies that the default
          expression holds.

          It is important to note that the expressions $exp1$, $exp2$ and
          $exp3$ are non-ground expressions, which means identifiers within
          them may be variables.

          \begin{verbatim}
always <exp1>
  [implied by <exp2>
  [with absence <exp3>]];
          \end{verbatim}

        \paragraph{Policy Update Definition.}

          Before a policy update can be applied, it must first be defined by
          by using the following syntax:

          \begin{verbatim}
<up_id>([<var_id>[, ...]])
  causes <exp1>
  if <exp2>;
          \end{verbatim}

          $up\_id$ is the policy update identifier to be used in referencing
          this policy update. The optional $var\_id$ list are the variable
          identifiers occurring the expressions $exp1$ and $exp2$ and will
          eventually be replaced by entity identifiers when the update is
          referenced. The postcondition expression $exp1$ is an expression that
          will hold in the state after this update is applied. The expression
          $exp2$ is a precondition expression that must hold in the current
          state before this update is applied.

          It is important to not that a policy base definition will have no
          effect on the policy base until it is appled by one of the directives
          described in the following section.

        \subsubsection{Directive Statements}

        \paragraph{Policy Update Directives.}

        The policy update sequence list contains a list of references to
        defined policy updates in the domain. The policy updates in the
        sequence list are applied to the current state of the policy base one
        at a time to produce a policy base state upon which queries can be
        evaluated. The policy updates are applied to the policy base in the
        same order as they appear in the sequence list.

        The following four directives are the policy sequence manipulation
        features of language $\cal{L}$.

        \subparagraph{Adding an Update into the Sequence.}
          Defined policy updates are added into the sequence list through the
          use of the following directive:

          \begin{verbatim}seq add <up_id>([<e_id>[, ...]]);\end{verbatim}

          \noindent where $up\_id$ is the identifier of a defined policy
          update and the $e\_id$ list is a comma-separated list of entity
          identifiers that will replace the variable identifiers that occur in
          the definition of the policy update. 

        \subparagraph{Listing the Updates in the Sequence.}
          The following directive may be used to list the current contents of
          the policy update sequence list.

          \begin{verbatim}seq list;\end{verbatim}

          This directive is answered with an ordinal list of policy updates in
          the form:

          \begin{verbatim}<n> <up_id>([e_id[, ...]])\end{verbatim}

          \noindent where $n$ is the ordinal index of the policy update within
          the sequence list starting at 0. $up\_id$ is the policy update
          identifier and the $e\_id$ list is the list of entity identifiers
          used to replace the variable identifier place-holders.

        \subparagraph{Removing an Update from the Sequence.}
          The syntax below shows the directive to remove a policy update
          reference from the list. $n$ is the ordinal index of the policy
          update to be removed. Note that removing a policy update reference
          from the sequence list may change the ordinal index of other update
          references.

          \begin{verbatim}seq del <n>;\end{verbatim}

        \subparagraph{Computing after a Policy Update.}

          The policy updates in the sequence list does not get applied until
          the $compute$ directive is issued. The directive causes the policy
          update references in the sequence list to be applied one at a time in
          the same order that they appear in the list. The directive also
          causes the system to generate the policy base models against which
          query requests can be evaluated.

          \begin{verbatim}compute;\end{verbatim}

        \paragraph{Query Directive.}

          A ground query expression may be issued against the current state of
          the policy base. This current state is derived after all the updates
          in the update sequence has been applied, one at a time, upon the
          initial state. Query expressions are answered with a \emph{true},
          \emph{false} or an \emph{unknown}, depending on whether the queried
          expression holds, its negation holds, or neither, respectively.
          Syntax is as follows:

          \begin{verbatim}query <ground-exp>;\end{verbatim} 

        \begin{example}
          The following language ${\cal L}$ program code listing shows a simple
          rule-based document access control system scenario.

          In this example, the subject $alice$ initially holds a $read$ access
          right for the object $file$. The constraint states that if $alice$
          has $read$ access for $file$, and it cannot be proven that $alice$ do
          not have $write$ access for $file$, then $alice$ is granted $write$
          access for $file$.

          \begin{verbatim}
/* entity identifier definitions */

ident sub alice;
ident acc read, write;
ident obj file;

/* initial fact definitions */

initially holds(alice, read, file);

/* constraint definitions */

always holds(alice, write, file) 
  implied by
    holds(alice, read, file)
  with absence
    !holds(alice, write, file);

/* policy update definitions */

delete_read(SS0, OS0)
  causes !holds(SS0, read,  OS0);

/* sequence manipluation directives */

seq add delete_read(alice, file);
compute;

/* query directives */

query holds(alice, write, file);
query holds(alice, read, file);
          \end{verbatim}
        \end{example}

    \subsection{Semantics}

      [some text to explain translation]

      \subsubsection{Domain Description of Language ${\cal L}$}

        \begin{definition}
          The domain description ${\cal D}_{\cal L}$ of language ${\cal L}$ is
          defined as a finite set of the following:

          \begin{itemize}
            \item
              ground initial state facts
            \item
              ground constraint rules
            \item
              policy update definitions
          \end{itemize}
        \end{definition}

        In addition to the domain ${\cal D}_{\cal L}$, language ${\cal L}$
        also includes an additional ordered set: the sequence list $\psi$.
        The sequence list $\psi$ is an ordered set that contains a sequence of
        references to policy update definitions. Each policy update reference
        consists of the policy update identifier and a series of zero or more
        identifier entities to replace the variable place-holders in the policy
        update definitions.

        The total number of states $\Sigma$ is the number of policy updates in
        the sequence list $\psi$ plus the initial state.

        \begin{quote}
          $\Sigma$ = $|\psi|$ + $1$
        \end{quote}

      \subsubsection{Language ${\cal L}^{*}$}

        [Language ${\cal L}^{*}$ is an extended logic program...]

        The $result$ function takes a policy update reference $u$ and the
        current state $\sigma$ as input arguments and returns the resulting
        state $\sigma'$ after $u$ has been applied to $\sigma$.

        \begin{quote}
          $\sigma'$ = $result$($u$, $\sigma$)
        \end{quote}

        \paragraph{Entities.}

          The entity set ${\cal E}$ is the union of six disjoint entity sets:
          single subject ${\cal E}_{ss}$, group subject ${\cal E}_{sg}$,
          single access right ${\cal E}_{as}$, group access right
          ${\cal E}_{ag}$, single object ${\cal E}_{os}$ and group object
          ${\cal E}_{og}$.

          \begin{enumerate}
            \item
              ${\cal E} = {\cal E}_{s} \cup {\cal E}_{a} \cup {\cal E}_{o}$
            \item
              ${\cal E}_{s} = {\cal E}_{ss} \cup {\cal E}_{sg}$
            \item
              ${\cal E}_{a} = {\cal E}_{as} \cup {\cal E}_{ag}$
            \item
              ${\cal E}_{o} = {\cal E}_{os} \cup {\cal E}_{og}$
          \end{enumerate}

        \paragraph{Atoms.}

          An atom represents a logical relationship of two to three enitites
          in a particular policy base state. The atom set ${\cal A}^{\sigma}$
          is the set of all atoms in state $\sigma$.

          \begin{enumerate}
            \item
              ${\cal A}^{\sigma} = {\cal A}^{\sigma}_{h} \cup {\cal A}^{\sigma}_{m} \cup {\cal A}^{\sigma}_{s}$
            \item
              ${\cal A}^{\sigma}_{h} = \{\forall (s \in {\cal E}_{s}, a \in {\cal E}_{a}, o \in {\cal E}_{o}), holds(s, a, o, \sigma) \}$
            \item
              ${\cal A}^{\sigma}_{m} = {\cal A}^{\sigma}_{ms} \cup {\cal A}^{\sigma}_{ma} \cup {\cal A}^{\sigma}_{mo}$
            \item
              ${\cal A}^{\sigma}_{s} = {\cal A}^{\sigma}_{ss} \cup {\cal A}^{\sigma}_{sa} \cup {\cal A}^{\sigma}_{so}$
            \item
              ${\cal A}^{\sigma}_{ms} = \{\forall (e \in {\cal E}_{ss}, g \in {\cal E}_{sg}), memb(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{ma} = \{\forall (e \in {\cal E}_{as}, g \in {\cal E}_{ag}), memb(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{mo} = \{\forall (e \in {\cal E}_{os}, g \in {\cal E}_{og}), memb(e, g, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{ss} = \{\forall (g1, g2 \in {\cal E}_{sg}), subst(g1, g2, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{sa} = \{\forall (g1, g2 \in {\cal E}_{ag}), subst(g1, g2, \sigma)\}$
            \item
              ${\cal A}^{\sigma}_{so} = \{\forall (g1, g2 \in {\cal E}_{og}), subst(g1, g2, \sigma)\}$
          \end{enumerate}

          The function $base$ accepts an atom $a$ as an input argument and
          returns a set that contains the entity identifiers that make up the
          atom.

          \begin{quote}
            \begin{math}
              base(a) = 
              \begin{cases}
                \mbox{\{$s_{a}$, $a_{a}$, $o_{a}$\}, if $a$ is holds} \\
                \mbox{\{$m_{a}$, $g_{a}$\}, if $a$ is memb} \\
                \mbox{\{$g1_{a}$, $g2_{a}$\}, if $a$ is subst}
              \end{cases}
            \end{math}
          \end{quote}

        \paragraph{Facts.}
       
          A fact is a logical statement that makes a claim that an atom either
          holds or does not hold in a particular state $\sigma$. The following
          is the formal definition of a fact:

          \begin{quote}
            $f^{\sigma}$ = $[\lnot]$$a$, $a$ $\in$ ${\cal A}^{\sigma}$
          \end{quote}

        \paragraph{Expressions.}

          An expression is a fact in a particular state or a conjunction of
          facts for all states.

          \begin{quote}
            $e$ = $f_{0}$ $\land$ ... $\land$ $f_{n}$

            where

            $f_{i}$ = $[\lnot]$$a$

            $\forall$$i$, $\exists$($a$,$\sigma$)
            such that

            \begin{itemize}
              \item
                $0$ $\leq$ $i$ $\leq$ $n$
              \item
                $a$ $\in$ ${\cal A}^{\sigma}$
              \item
                $0$ $\leq$ $\sigma$ $\leq$ $\Sigma$
            \end{itemize}
          \end{quote}

        \paragraph{Propositions.}

          In language ${\cal L}^{*}$, propositions state logical facts and
          rules. A proposition is composed of a fact (the head) and an
          expression that makes up the body. The proposition below states that
          fact $f$ holds if all the facts in expression $e$ also hold.

          \begin{quote}
            $f$ $\leftarrow$ $e$
          \end{quote}

          A proposition without a body expression states that the head, fact
          $f$ holds, unconditionally.

          \begin{quote}
            $f$ $\leftarrow$
          \end{quote}

      \subsubsection{Translating Language ${\cal L}$ to Language ${\cal L^{*}}$}

        \begin{definition}
          Given the domain description ${\cal D}_{\cal L}$ of language
          ${\cal L}$, the function $trans$(${\cal D}_{\cal L}$) is defined as
          the extended logic program ${\cal L}^{*}$ translation of language
          ${\cal L}$.

          The domain description ${\cal D}_{\cal L}$ is said to be $consistent$
          if $trans$(${\cal D}_{\cal L}$) has at least one consistent answer
          set. 
        \end{definition}

        \paragraph{Initial Fact Expression.}

          Translating initial fact expressions of language ${\cal L}$ to
          language ${\cal L}^{*}$ is a trivial procedure: repleace each atom
          that makes up the initial fact expression of language ${\cal L}$
          with its corresponding equivalent initial state atom of language
          ${\cal L}^{*}$. The following shows the formal definition of initial
          fact expressions of language ${\cal L}^{*}$.

          \begin{quote}
            $f_{0}$ $\land$ .. $\land$ $f_{n}$, $n$ $\geq$ $0$

            where

              \begin{itemize}
                \item
                  $f_{i}$ = $[\lnot]$ $a$
                \item
                  $a$ $\in$ ${\cal A}^{S_{0}}$
                \item
                  $0$ $\leq$ $i$ $\leq$ $n$
              \end{itemize}
          \end{quote}

        \paragraph{Constraint Rules.}

          Given a constraint in language ${\cal L}$:

          \begin{quote}
            always $a_{0}$ $\land$ ... $\land$ $a_{m}$
            implied by $b_{0}$ $\land$ ... $\land$ $b_{n}$
            with absence $c_{0}$ $\land$ ... $\land$ $c_{o}$
          \end{quote}
         
          \begin{itemize}
            \item
              Each constraint rule in language ${\cal L}$ may be expressed
              as a logical rule. The expression $a$ in the $always$ clause
              is the head of the rule, expression $b$ in the $implied$ $by$
              clause is the positive body, and the expression $c$ in the
              $with$ $absence$ clause is the negative body.

              \begin{quote}
                \begin{math}
                  \begin{aligned}[t]
                    a_{0} \land ... \land a_{m} \leftarrow &
                    b_{0} \land ... \land b_{n} \land \\
                    & not c_{0} \land ... \land not c_{o}
                  \end{aligned}
                \end{math}
              \end{quote}
            \item
              The definition of rules in language ${\cal L}^{*}$ requires
              rules to have only a single fact in its head. Each rule in the
              above form corresponds to $m$ equivalent rules, each with a
              single fact $a_{i}$ ($0$ $\leq$ $i$ $\leq$ $m$) for its head.

              \begin{quote}
                $a_{0}$ $\leftarrow$
                $b_{0}$ $\land$ ... $\land$ $b_{n}$ $\land$
                $not$ $c_{0}$ $\land$ ... $\land$ $not$ $c_{o}$

                ...

                $a_{m}$ $\leftarrow$
                $b_{0}$ $\land$ ... $\land$ $b_{n}$ $\land$
                $not$ $c_{0}$ $\land$ ... $\land$ $not$ $c_{o}$
              \end{quote}
            \item
              Each rule above corresponds to $\Sigma$ equivalent constraint
              rules in language ${\cal L}^{*}$, for each state defined by the
              sequence list $\psi$ plus the initial state.
          \end{itemize}

          Given the method described above for translating constraint rules
          from language ${\cal L}$ to language ${\cal L}^{*}$, a constraint
          rule in language ${\cal L}^{*}$ is defined as follows:

          \begin{quote}
            $a$ $\leftarrow$
            $b_{0}$ $\land$ ... $\land$ $b_{m}$ $\land$
            $not$ $c_{0}$ $\land$ ... $\land$ $not$ $c_{n}$

            where:

            \begin{itemize}
              \item
                $a$ = $[\lnot]$ $a$, $a$ $\in$ ${\cal A}^{\sigma}$
              \item
                $b_{i}$ = $[\lnot]$ $b$, $b$ $\in$ ${\cal A}^{\sigma}$, $0$ $\leq$ $i$ $\leq$ $m$
              \item
                $c_{j}$ = $[\lnot]$ $c$, $c$ $\in$ ${\cal A}^{\sigma}$, $0$ $\leq$ $j$ $\leq$ $n$
              \item
                $\sigma$ = $S_{k}$, $0$ $\leq$ $k$ $\leq$ $\Sigma$
              \end{itemize}
          \end{quote}

        \paragraph{Policy Updates.}

          With all variable occurences grounded to entity identifiers, a
          policy update $u$, as defined by language ${\cal L}$ is in the form:

          \begin{quote}
            $u$ causes $a_{0}$ $\land$ ... $\land$ $a_{m}$ if $b_{0}$ $\land$ ... $\land$ $b_{n}$
          \end{quote}

          In language ${\cal L}^{*}$, a distinction must be made between the
          atoms before $u$ is applied and the atoms after $u$ has been applied.
          Furthermore, such distinction is also needed to represent a rule that
          states that all facts $a_{i}$ ($0$ $\leq$ $i$ $\leq$ $m$) hold in
          the resulting state if all facts $b_{j}$ ($0$ $\leq$ $j$ $\leq$ $n$)
          hold in the current state.

          Formally, a policy update $u$ applied to the current state $\sigma$,
          with a postcondition expression $a_{0}$ $\land$ ... $\land$ $a_{n}$
          and a precondition expression $b_{0}$ $\land$ ... $\land$ $b_{m}$, 
          is expressed in language ${\cal L}^{*}$ as follows:

          \begin{quote}
            $a_{0}$ $\leftarrow$ $b_{0}$ $\land$ ... $\land$ $b_{n}$

            ...

            $a_{m}$ $\leftarrow$ $b_{0}$ $\land$ ... $\land$ $b_{n}$

            where:

            \begin{itemize}
              \item
                $a_{i}$ = $[\lnot]$ $a$, $a$ $\in$ ${\cal A}^{\sigma'}$, $0$ $\leq$ $i$ $\leq$ $m$
              \item
                $b_{j}$ = $[\lnot]$ $b$, $b$ $\in$ ${\cal A}^{\sigma}$, $0$ $\leq$ $j$ $\leq$ $n$
              \item
                $\sigma'$ = $result$($u$, $\sigma$)
            \end{itemize}
          \end{quote}

        \paragraph{Additional Constraints.}

          In addition to the above translations, there are a few other implicit
          constraint rules implied by language ${\cal L}$ that needs to be
          explicitly defined in language ${\cal L}^{*}$.

          \subparagraph{Inheritance Rules.}

            All properties held by a group is inherited by all the members and
            subsets of that group. This rule is easy to apply for subject group
            entities. However, careful attention must be given to access right
            and object groups. A subject holding an access right for an object
            group implies that that subject also holds that access right for
            all objects in the object group. Similarly, a subject holding an
            access right group for a particular object implies that the subject
            holds all access rights contained in the access right group for
            that object.

            The following are the inheritance constriant rules to allow the
            properties held by a group to propagate to its members and
            subsets.

            \begin{enumerate}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    holds(s_{s}, a, o, \sigma) \leftarrow &
                    holds(s_{g}, a, o, \sigma) \land \\
                    & memb(s_{s}, s_{g}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (s_{s}, s_{g}, a, o, \sigma)$ where:

                \begin{itemize}
                  \item
                    $s_{s} \in {\cal A}^{\sigma}_{ss}$
                  \item
                    $s_{g} \in {\cal A}^{\sigma}_{sg}$
                  \item
                    $a \in {\cal A}^{\sigma}_{a}$
                  \item
                    $o \in {\cal A}^{\sigma}_{o}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    holds(s, a_{s}, o, \sigma) \leftarrow &
                    holds(s, a_{g}, o, \sigma) \land \\
                    & memb(a_{s}, a_{g}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (s, a_{s}, a_{g}, o, \sigma)$ where:

                \begin{itemize}
                  \item
                    $s \in {\cal A}^{\sigma}_{s}$
                  \item
                    $a_{s} \in {\cal A}^{\sigma}_{as}$
                  \item
                    $a_{g} \in {\cal A}^{\sigma}_{ag}$
                  \item
                    $o \in {\cal A}^{\sigma}_{o}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    holds(s, a, o_{s}, \sigma) \leftarrow &
                    holds(s, a, o_{g}, \sigma) \land \\
                    & memb(o_{s}, o_{g}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (s, a, o_{s}, o_{g}, \sigma)$ where:

                \begin{itemize}
                  \item
                    $s \in {\cal A}^{\sigma}_{s}$
                  \item
                    $a \in {\cal A}^{\sigma}_{a}$
                  \item
                    $o_{s} \in {\cal A}^{\sigma}_{os}$
                  \item
                    $o_{g} \in {\cal A}^{\sigma}_{og}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    holds(s_{g1}, a, o, \sigma) \leftarrow &
                    holds(s_{g2}, a, o, \sigma) \land \\
                    & subst(s_{g1}, s_{g2}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (s_{g1}, s_{g2}, a, o, \sigma)$ where:

                \begin{itemize}
                  \item
                    $s_{g1}, s_{g2} \in {\cal A}^{\sigma}_{sg}$
                  \item
                    $a \in {\cal A}^{\sigma}_{a}$
                  \item
                    $o \in {\cal A}^{\sigma}_{o}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    holds(s, a_{g1}, o, \sigma) \leftarrow &
                    holds(s, a_{g2}, o, \sigma) \land \\
                    & subst(a_{g1}, a_{g2}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (s, a_{g1}, a_{g2}, o, \sigma)$ where:

                \begin{itemize}
                  \item
                    $s \in {\cal A}^{\sigma}_{s}$
                  \item
                    $a_{g1}, a_{g2} \in {\cal A}^{\sigma}_{ag}$
                  \item
                    $o \in {\cal A}^{\sigma}_{o}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
                \item
                \begin{math}
                  \begin{aligned}[t]
                    holds(s, a, o_{g1}, \sigma) \leftarrow &
                    holds(s, a, o_{g2}, \sigma) \land \\
                    & subst(o_{g1}, o_{g2}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (s, a, o_{g1}, o_{g2}, \sigma)$ where:

                \begin{itemize}
                  \item
                    $s \in {\cal A}^{\sigma}_{s}$
                  \item
                    $a \in {\cal A}^{\sigma}_{a}$
                  \item
                    $o_{g1}, o_{g2} \in {\cal A}^{\sigma}_{og}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
            \end{enumerate}

          \subparagraph{Transitivity Rules.}

            Given three groups $G$, $G'$ and $G''$. If $G$ is a subset of $G'$
            and $G'$ is a subset of $G''$, then $G$ must also be a subset of
            $G''$. The following rules ensure that the transitive property of
            subject, access right and object groups hold:

            \begin{enumerate}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    subst(sg_{1}, sg_{3}, \sigma) \leftarrow &
                    subst(sg_{1}, sg_{2}, \sigma) \land \\
                    & subst(sg_{2}, sg_{3}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (sg_{1}, sg_{2}, sg_{3}, \sigma)$ where:

                \begin{itemize}
                  \item
                    $sg_{1}, sg_{2}, sg_{3} \in {\cal A}^{\sigma}_{sg}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    subst(ag_{1}, ag_{3}, \sigma) \leftarrow &
                    subst(ag_{1}, ag_{2}, \sigma) \land \\
                    & subst(ag_{2}, ag_{3}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (ag_{1}, ag_{2}, ag_{3}, \sigma)$ where:

                \begin{itemize}
                  \item
                    $ag_{1}, ag_{2}, ag_{3} \in {\cal A}^{\sigma}_{ag}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
              \item
                \begin{math}
                  \begin{aligned}[t]
                    subst(og_{1}, og_{3}, \sigma) \leftarrow &
                    subst(og_{1}, og_{2}, \sigma) \land \\
                    & subst(og_{2}, og_{3}, \sigma)
                  \end{aligned}
                \end{math}

                $\forall (og_{1}, og_{2}, og_{3}, \sigma)$ where:

                \begin{itemize}
                  \item
                    $og_{1}, og_{2}, og_{3} \in {\cal A}^{\sigma}_{og}$
                  \item
                    $0 \leq \sigma \leq \Sigma$
                \end{itemize}
            \end{enumerate}

          \subparagraph{Inertial Rules.}

            Intuitively, all facts in the current state that are not affected
            by a policy update should be carried over to the next state after
            the update. In language ${\cal L}^{*}$, this rule must be
            explicitly stated as a constraint.

            Formally, the intertial rules are expressed as follows:

            \begin{quote}
              $a'$ $\leftarrow$ $a$ $\land$ $not$ $\lnot$ $a'$

              $\lnot$ $a'$ $\leftarrow$ $\lnot$ $a$ $\land$ $not$ $a'$

              $\forall$($a$,$u$) where:

              \begin{itemize}
                \item
                  $u$ $\in$ $\psi$
                \item
                  $a$ $\in$ ${\cal A}^{\sigma}$
                \item
                  $a'$ $\in$ ${\cal A}^{\sigma'}$
                \item
                  $\sigma'$ = $result$($u$, $\sigma$)
                \item
                  $base$($a$) = $base$($a'$)
              \end{itemize}
            \end{quote}

        \begin{example}
          [Language ${\cal L}$ program in Example1 translated into
          ${\cal L}^{*}$.]

        \end{example}

      \subsection{Evaluation}

        \begin{definition}
          Given a consistent domain description ${\cal D}_{\cal L}$, ground
          query expression $\phi$ and a finite sequence list $\psi$, we say the
          query $\phi$ holds in ${\cal D}_{\cal L}$ after the policy updates
          in the sequence list $\phi$ has been applied:

          \begin{quote}
            ${\cal D}_{\cal L}$ $\models$ \{$\phi$, $\psi$\}
          \end{quote}

          \noindent if and only if for every atom $a$ in $\phi$, $a$ $\in$
          ${\cal A}^{\Sigma}$, [$\lnot$] $a$ holds in every answer set of
          $trans$(${\cal D}_{\cal L}$)
        \end{definition}

    \begin{example}
      [a full example (translation + result)]

    \end{example}

  \section{Semantic Properties}

  \section{Implementation}

    \subsection{System Structure}

    \subsection{Algorithms}

  \section{Case Study: Web Server Application}

  \section{Conclusion}

    [summary]

    [effectiveness of system/application]

    [future work]

\end{document}
