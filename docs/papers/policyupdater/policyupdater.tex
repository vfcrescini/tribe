\documentclass[global,twocolumn,final]{svjour}
\usepackage{times}
\usepackage{amsmath}
\usepackage{alltt}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage{multirow}

% defintion environment (from svglobal)
\newenvironment{vdefinition}
  {\begin{definition}\hspace{0.25em}}
  {\end{definition}}
% theorem environment (from svglobal)
\newenvironment{vtheorem}[1]
  {\begin{theorem}[#1]\hspace{0.25em}}
  {\end{theorem}}
% proof environment (from svglobal)
\newenvironment{vproof}
  {\begin{proof}\hspace{0.25em}}
  {\qed\end{proof}}
% example environment (from svglobal)
\newenvironment{vexample}
  {\begin{example}\hspace{0.25em}}
  {\end{example}}
% create a quote environment without a right-hand margin
\newenvironment{vquote}
  {\begin{list}{}{\leftmargin 1em}\item[]}
  {\end{list}}
% create a *smaller* alltt (verbatim) environment
\newenvironment{vverbatim}
  {\begin{alltt}}
  {\vspace{-\baselineskip}\end{alltt}}
% define a section command to be used in the appendices
\makeatletter
\newcommand{\vappsection}[1]{
  % change the numbering to Appendix *level*
  \renewcommand{\@seccntformat}[1]{
    \appendixname\hspace{0.5em}\csname the##1\endcsname \hspace{1em}
  }
  \section{#1}
  % change the numbering back
  \renewcommand{\@seccntformat}[1]{
    \csname the##1\endcsname\hspace{1em}
  }
}
\makeatother

\begin{document}
  \title{PolicyUpdater -- A System for Dynamic Access Control}
  \author{Vino Fernando Crescini and Yan Zhang}
  \institute{
    School of Computing and Information Technology \\
    University of Western Sydney                   \\
    Penrith South DC, NSW 1797, Australia          \\
    \email{\{jcrescin,yan\}@cit.uws.edu.au}
  }

  \maketitle

  \begin{abstract}
    {\em PolicyUpdater} is a fully-implemented authorisation system that
    provides policy evaluations as well as dynamic policy updates. These
    functions are achieved by the use of a logic-based language ${\cal L}$ to
    represent the underlying access control policies, constraints and update
    propositions. The system performs access control query evaluations and
    conditional policy updates by translating the language $\cal{L}$ to a
    normal logic program in a form suitable for evaluation using the
    {\em Stable Model} semantics.
  \end{abstract}

  \section{Introduction}

    The traditional access control mechanism is the {\em Access Control Matrix}
    where columns represent subjects, rows represent objects and each cell
    contains the access-rights of a subject over a particular object. However,
    flexibility and scalability issues arise when such method is used on
    real-world applications. A more effective paradigm of access control
    systems is the logic-based approach. In this approach, instead of
    explicitly defining all access-rights of all subjects for all objects
    in a domain, a set of logical facts and rules are used to define the
    policy base.

    Recent advances in the field have produced a number of different approaches
    to logic-based access control systems, e.g. \cite{HAL,LI}. Bertino, et. al.
    \cite{BE1} proposed such a system based on ordered logic with ordered
    domains. Jajodia, et. al. \cite{JAJ} on the other hand, proposed a general
    access control framework that features handling of multiple policies.
    Another important work is the system proposed by Bai and Varadharajan
    \cite{BA1,BA2}. Their system's key characteristic is the ability to
    dynamically update the otherwise static policy base. These systems,
    effective as they are, lack the details necessary to address the issues
    involved in the implementation of such a system.

    The {\em Policy Description Language}, or {\em PDL}, developed by Lobo,
    et. al. \cite{LOB}, is a language for representing event and action
    oriented generic policies. {\em PDL} is later extended by Chomicki, et. al.
    \cite{CHO} to include {\em policy monitors} which, in effect, are policy
    constraints. Bertino, et. al. \cite{BE2}, again took {\em PDL} a step
    further by extending {\em policy monitors} to allow users to express
    preferred constraints. While these generic languages are expressive enough
    to be used for access control systems, systems built for such languages
    will not have the ability to dynamically update the policies.

    To overcome these limitations, we propose the PolicyUpdater access control
    system, which, with its own access control language, provides a formal
    logic-based representation of policies, with variable resolution and
    default propositions, a mechanism to conditionally and dynamically
    perform a sequence of policy updates, and a means of evaluating queries
    against the policies.

     The rest of this paper is organised as follows. In Section \ref{sec-langl},
    the paper introduces language ${\cal L}$, with its formal syntax, semantics
    and some examples. In Section \ref{sec-cons}, the issues of consistency and
    query evaluation are addressed. The implementation, as discussed in Section
    \ref{sec-implement}, gives an overview of the PolicyUpdater system as
    a whole, its internal and external components, and most importantly, an
    outline of the underlying mechanisms responsible for processing of language
    ${\cal L}$ policies for query evaluation and dynamic updates. The case
    study presented in Section \ref{sec-case} shows a typical application of
    the PolicyUpdater system: an access control system for web servers. In
    Section \ref{sec-conclusion}, the concluding remarks address some
    possible extensions to this system.

    The PolicyUpdater system was originally introduced in the conference
    proceedings paper \cite{CR1}. Another conference proceedings paper
    \cite{CR2} focuses on a web server authorisation system based on the
    core PolicyUpdater system.

  \section{Language $\cal{L}$}
    \label{sec-langl}

    Language $\cal{L}$ is a first-order logic language that represents a policy
    base for an authorisation system. Two key features of the language are: (1)
    providing a means to conditionally and dynamically update the existing
    policy base and (2) having a mechanism by which queries may be evaluated
    from the updated policy base.

    \subsection{Syntax}
      \label{subsec-syntax}

      Logic programs of language ${\cal L}$ are composed of language
      statements, each terminated by a semicolon ";" character. C-style
      comments delimited by the "/*" and "*/" characters may appear anywhere in
      the logic program.

      \subsubsection{Components of Language $\cal{L}$}

        \paragraph{Identifiers.}
          The most basic unit of language $\cal{L}$ is the identifier.
          Identifiers are used to represent the different components of the
          language, and are divided into three main classes:

          \begin{itemize}
            \item
              {\em Entity Identifiers} represent constant entities that make up
              a logical atom. They are divided further into three types, with
              each type again divided into the {\em singular entity} and
              {\em group entity} categories:

              \begin{itemize}
                \item
                  {\em Subjects}: e.g. alice, lecturers, group.
                \item
                  {\em Access Rights}: e.g. read, write, own.
                \item
                  {\em Objects}: e.g. file, database, directory.
              \end{itemize}

              An entity identifier is defined as a lower-case alphabet
              character, followed by 0 to 127 characters of alphabet, digit or
              underscore characters. The following regular expression shows the
              syntax of entity identifiers:

              \begin{vverbatim}
  [a-z]([a-zA-Z0-9\_])\{0,127\}
              \end{vverbatim}

            \item
              {\em Policy Update Identifiers} are used for the sole purpose of
              naming a policy update. These identifier names are then used as
              labels to refer to policy update definitions and directives. As
              labels, identifiers of this class occupy a different namespace
              from entity identifiers. For this reason, policy update
              identifiers share the same syntax with entity identifiers:


              \begin{vverbatim}
  [a-z]([a-zA-Z0-9\_])\{0,127\}
              \end{vverbatim}

            \item
              {\em Variable Identifiers} are used as place-holders for entity
              identifiers. To distinguish them from entity and policy update
              identifiers, variable identifiers are prefixed with an upper-case
              character, followed by 0 to 127 alphanumeric and underscore
              characters. The following regular expression shows the syntax of
              variable identifiers:

              \begin{vverbatim}
  [A-Z]([a-zA-Z0-9\_])\{0,127\}
              \end{vverbatim}
          \end{itemize}

        \paragraph{Atoms.}
          An atom is composed of a relation with 2 to 3 entity or variable
          identifiers that represent a logical relationship between the
          entities. There are three types of atoms:

          \begin{itemize}
            \item
              {\em Holds.} An atom of this type states that the subject
              identifier $sub$ holds the access right identifier $acc$
              for the object identifier $obj$.

              \begin{vverbatim}
  holds(<sub>, <acc>, <obj>)
              \end{vverbatim}
            \item
              {\em Membership.} This type of atom states that the singular
              identifier $elt$ is a member or element of the group identifier
              $grp$. It is important to note that identifiers $elt$ and $grp$
              must be of the same base type (e.g. subject and subject group).

              \begin{vverbatim}
  memb(<elt>, <grp>)
              \end{vverbatim}
            \item
              {\em Subset.} The subset atom states that the group identifiers
              $grp1$ and $grp2$ are of the same types and that group $grp1$ is
              a subset of the group $grp2$.

              \begin{vverbatim}
  subst(<grp1>, <grp2>)
              \end{vverbatim}
          \end{itemize}

          Atoms that contain no variables, i.e. composed entirely of entity
          identifiers, are called {\em ground atoms}.

        \paragraph{Facts.}
          A fact states that the relationship represented by an atom or
          its negation holds in the current context. Facts are negated by the
          use of the negation operator ($!$). The following shows the formal
          syntax of a fact:

          \begin{vverbatim}
  [!]<holds\_atom>|<memb\_atom>|
     <subst\_atom>
          \end{vverbatim}

          Note that facts may be made up of atoms that contain variable
          identifiers. Facts with no variable occurrences are called
          {\em ground facts}.

        \paragraph{Expressions.}
          An expression is either a fact, or a logical conjunction of facts,
          separated by the double-ampersand characters $\&\&$.

          \begin{vverbatim}
  <fact1> [&& <fact2> [&& ...]]
          \end{vverbatim}

          Expressions that are made up of only ground facts are called
          {\em ground expressions}.

      \subsubsection{Definition Statements}

        \paragraph{Entity Identifier Definition.}

          All entity identifiers (subjects, access rights, objects and groups)
          must first be declared before any other statements to define the
          entity domain of the policy base. The following entity declaration
          syntax illustrates how to define one or more entity identifiers of a
          particular type.

          \begin{vverbatim}
  ident sub|acc|obj[-grp]
    <entity\_id>[, ...];
          \end{vverbatim}

        \paragraph{Initial Fact Definition.}

          The initial facts of the policy base, those that hold before any
          policy updates are performed, are defined by using the following
          definition syntax:

          \begin{vverbatim}
  initially <ground-exp>;
          \end{vverbatim}

        \paragraph{Constraint Definition.}

          A constraint statement is a logical rule that holds regardless of any
          changes that may occur when the policy base is updated. Constraint
          rules are true in the initial state and remain true after any policy
          update.

          The constraint syntax below shows that for any state of the policy
          base, expression $exp1$ holds if expression $exp2$ is true and there
          is no evidence that $exp3$ is true. The $with$ $absence$ clause
          allows constraints to have a default proposition behaviour, where
          the absence of proof that an expression holds  satisfies the clause
          condition of the proposition.

          It is important to note that the expressions $exp1$, $exp2$ and
          $exp3$ may be non-ground expressions, which allows identifiers
          occurring in these expressions to be variables.

          \begin{vverbatim}
  always <exp1>
    [implied by <exp2>
    [with absence <exp3>]];
          \end{vverbatim}

        \paragraph{Policy Update Definition.}

          Before a policy update can be applied, it must first be defined by
          using the following syntax:

          \begin{vverbatim}
  <up\_id>([<var\_id>[, ...]])
    causes <exp1>
    [if <exp2>];
          \end{vverbatim}

          $up\_id$ is the policy update identifier to be used in referencing
          this policy update. The optional $var\_id$ list are the variable
          identifiers occurring in the expressions $exp1$ and $exp2$ and will
          eventually be replaced by entity identifiers when the update is
          referenced. The postcondition expression $exp1$ is an expression that
          will hold in the state after this update is applied. The expression
          $exp2$ is a precondition expression that must hold in the current
          state before this update is applied.

          Note that a policy update definition will have no effect on the
          policy base until it is applied by one of the directives described in
          the following section.

        \subsubsection{Directive Statements}

        \paragraph{Policy Update Directives.}

        The policy update sequence list contains a list of references to
        defined policy updates in the domain. The policy updates in the
        sequence list are applied to the current state of the policy base one
        at a time to produce a policy base state upon which queries can be
        evaluated.

        The following four directives are the policy sequence manipulation
        features of language $\cal{L}$.

        \begin{itemize}
          \item
            {\em Adding an update into the sequence.}
            Defined policy updates are added into the sequence list through the
            use of the following directive:

            \begin{vverbatim}
  seq add <up\_id>([<e\_id>[, ...]]);
            \end{vverbatim}

            \noindent where $up\_id$ is the identifier of a defined policy
            update and the $e\_id$ list is a comma-separated list of entity
            identifiers that will replace the variable identifiers that occur in
            the definition of the policy update.

          \item
            {\em Listing the updates in the sequence.}
            The following directive may be used to list the current contents of
            the policy update sequence list.

            \begin{vverbatim}
  seq list;
            \end{vverbatim}

            This directive is answered with an ordinal list of policy updates
            in the form:

            \begin{vverbatim}
  <n> <up\_id>([<e\_id>[, ...]])
            \end{vverbatim}

            \noindent where $n$ is the ordinal index of the policy update
            within the sequence list starting at 0. $up\_id$ is the policy
            update identifier and the $e\_id$ list is the list of entity
            identifiers used to replace the variable identifier place-holders.

          \item
            {\em Removing an update from the sequence.}
            The syntax below shows the directive to remove a policy update
            reference from the list. $n$ is the ordinal index of the policy
            update to be removed. Note that removing a policy update reference
            from the sequence list may change the ordinal index of other update
            references.

            \begin{vverbatim}
  seq del <n>;
            \end{vverbatim}

          \item
            {\em Computing an update sequence.}
            The policy updates in the sequence list does not get applied until
            the $compute$ directive is issued. The directive causes the policy
            update references in the sequence list to be applied one at a time
            in the same order that they appear in the list. The directive also
            causes the system to generate the policy base models against which
            query requests can be evaluated.

            \begin{vverbatim}
  compute;
            \end{vverbatim}
        \end{itemize}

        \paragraph{Query Directive.}

          A ground query expression may be issued against the current state of
          the policy base. This current state is derived after all the updates
          in the update sequence have been applied, one at a time, upon the
          initial state. Query expressions are answered with a $true$, $false$
          or an $unknown$, depending on whether the queried expression holds,
          its negation holds, or neither, respectively. Syntax is as follows:

          \begin{vverbatim}
  query <ground-exp>;
          \end{vverbatim}

        \begin{vexample}
          \label{ex-1}
          The following language ${\cal L}$ program code listing shows a simple
          rule-based document access control system scenario.

          In this example, the subject $alice$ is initially a member of the
          subject group $grp2$, which is a subset of group $grp1$. The group
          $grp1$ also initially holds a $read$ access right for the object
          $file$. The constraint states that if the group $grp1$ has $read$
          access for $file$, and no other information is present to conclude
          that $grp3$ do not have $write$ access for $file$, then the group
          $grp1$ is granted $write$ access for $file$. For simplicity, we only
          consider one policy update $delete\_read$ and a few queries that are
          evaluated after the policy update is performed.

          \begin{vverbatim}
  ident sub alice;
  ident sub-grp grp1, grp2, grp3;
  ident acc read, write;
  ident obj file;

  initially
    memb(alice, grp2) &&
    holds(grp1, read, file) &&
    subst(grp2, grp1);

  always holds(grp1, write, file)
    implied by
      holds(grp1, read, file)
    with absence
      !holds(grp3, write, file);

  delete\_read(SG0, OS0)
    causes !holds(SG0, read, OS0);

  seq add delete\_read(grp1, file);

  compute;

  query holds(grp1, write, file);
  query holds(grp1, read, file);
  query holds(alice, write, file);
  query holds(alice, read, file);
          \end{vverbatim}
        \end{vexample}

    \subsection{Semantics}
      \label{subsec-semantics}

      After giving a detailed syntactic definition of language ${\cal L}$,
      we now define its formal semantics.

      The semantics for language ${\cal L}$ is based on the well-known answer
      set (stable model) semantics of extended logic programs proposed by
      Gelfond and Lifschitz \cite{GEL}. The definition below formally defines
      the answer set of a logic program.

      \begin{vdefinition}
        \label{def-ans}
        Given an extended logic program $\Pi$ composed of ground facts and
        rules that do not have the negation-as-failure operator $not$ and a set
        ${\cal F}$ of all ground facts in $\Pi$. A set $S$ is then said to be
        an answer set of $\Pi$ if it is the smallest set that satisfies the
        following conditions:

        \begin{enumerate}
          \item
            For any rule of the form $\rho_{0}$ $\leftarrow$ $\rho_{1}$,
            $\hdots$, $\rho_{n}$ where $n$ $>$ 1, if $\rho_{1}$, $\hdots$,
            $\rho_{n}$ $\in$ $S$, then
            $\rho_{0}$ $\in$ $S$.
          \item
            If $S$ contains a pair of complementary facts (i.e. a fact and
            its negation), then $S$ = ${\cal F}$.
        \end{enumerate}

        For a ground extended logic program $\Pi$ that is composed of rules
        that may have the negation-as-failure operator $not$, a set $S$ is the
        answer set of $\Pi$ if and only if $S$ is the answer set of $\Pi'$,
        where $\Pi'$ is obtained from $\Pi$ by deleting the following:

        \begin{enumerate}
          \item
            Each rule that contains a fact of the form $not$ $\rho$ in its body
            where $\rho$ $\in$ $S$.
          \item
            All facts of the form $not$ $\rho$ in the bodies of the remaining
            rules.
        \end{enumerate}
      \end{vdefinition}

      \subsubsection{Domain Description of Language ${\cal L}$}
        \begin{vdefinition}
          \label{def-domain}
          The domain description ${\cal D}_{\cal L}$ of language ${\cal L}$ is
          defined as a finite set of ground initial state facts, constraint
          rules and policy update definitions.
        \end{vdefinition}

        In addition to the domain description ${\cal D}_{\cal L}$, language
        ${\cal L}$ also includes an additional ordered set: the sequence list
        $\psi$. The sequence list $\psi$ is an ordered set that contains a
        sequence of references to policy update definitions. Each policy update
        reference consists of the policy update identifier and a series of zero
        or more identifier entities to replace the variable place-holders in
        the policy update definitions.

      \subsubsection{Language ${\cal L}^{*}$}
        In language ${\cal L}$, the policy base is subject to change, which is
        triggered by the application of policy updates. Such changes bring
        forth the concept of policy base states. Conceptually, a state may be
        thought of as a set of facts and constraints of the policy base at a
        particular instant. The state transition notation below shows that a
        new state $PB'$ is generated from the current state $PB$ after the
        policy update $u$ is applied.

        \begin{vquote}
          $PB$ $\overrightarrow{_{u}}$ $PB'$
        \end{vquote}

        This concept of a state means that for every policy update applied
        to the policy base, a new instance of the policy base or a new set of
        facts and constraints are generated. To precisely define the underlying
        semantics of domain description ${\cal D}_{\cal L}$ in language
        ${\cal L}$, we introduce language ${\cal L}^{*}$, which is an extended
        logic program representation of language ${\cal L}$, with state as an
        explicit sort.

        Language ${\cal L}^{*}$ contains only one special state constant
        $S_{0}$ to represent the initial state of a given domain description.
        All other states are represented as a resulting state obtained by
        applying the $Res$ function.

        The $Res$ function takes a policy update reference $u$ ($u$ $\in$
        $\psi$) and the current state $\sigma$ as input arguments and
        returns the resulting state $\sigma'$ after update $u$ has been applied
        to state $\sigma$:

        \begin{vquote}
          $\sigma'$ = $Res$($u$, $\sigma$)
        \end{vquote}

        Given an initial state $S_{0}$ and a sequence list $\psi$, each state
        $\sigma_{i}$ ($0$ $\leq$ $i$ $\leq$ $|\psi|$) may be represented as
        follows:

        \begin{vquote}
          $\sigma_{0}$ = $S_{0}$

          $\sigma_{1}$ = $Res$($u_{0}$, $\sigma_{0}$)

          $\ldots$

          $\sigma_{|\psi|}$ = $Res$($u_{|\psi| - 1}$, $\sigma_{|\psi| - 1}$)
        \end{vquote}

        Substituting each state with a recursive call to the $Res$ function,
        the final state $S_{|\psi|}$ is defined as follows:

        \begin{vquote}
          $S_{|\psi|}$ = $Res$($u_{|\psi| - 1}$, $Res$($\ldots$, $Res$($u_{0}$, $S_{0}$)))
        \end{vquote}

        \paragraph{Entities.}

          The entity set ${\cal E}$ is the union of six disjoint entity sets:
          single subject ${\cal E}_{ss}$, group subject ${\cal E}_{sg}$,
          single access right ${\cal E}_{as}$, group access right
          ${\cal E}_{ag}$, single object ${\cal E}_{os}$ and group object
          ${\cal E}_{og}$. Each entity in set ${\cal E}$ corresponds directly
          to the {\em entity identifiers} of language ${\cal L}$.

          \begin{vquote}
            ${\cal E} = {\cal E}_{s} \cup {\cal E}_{a} \cup {\cal E}_{o}$

            ${\cal E}_{s} = {\cal E}_{ss} \cup {\cal E}_{sg}$

            ${\cal E}_{a} = {\cal E}_{as} \cup {\cal E}_{ag}$

            ${\cal E}_{o} = {\cal E}_{os} \cup {\cal E}_{og}$
          \end{vquote}

        \paragraph{Atoms.}

          The main difference between language ${\cal L}$ and language
          ${\cal L}^{*}$ lies in the definition of an atom. Atoms in language
          ${\cal L}^{*}$ represent a logical relationship of two to three
          entities, as with atoms of language ${\cal L}$. Furthermore, atoms of
          language ${\cal L}^{*}$ extends this definition by defining the
          state of the policy base in which the relationship holds. In this
          paper, atoms of language ${\cal L}^{*}$ are written with the
          hat character ($\hat{holds}$, $\hat{memb}$ and $\hat{subst}$) to
          differentiate from the atoms of language ${\cal L}$.

          The atom set ${\cal A}^{\sigma}$ is the set of all atoms in state
          $\sigma$.

          \begin{vquote}
            ${\cal A}^{\sigma} = {\cal A}^{\sigma}_{h} \cup {\cal A}^{\sigma}_{m} \cup {\cal A}^{\sigma}_{s}$

            ${\cal A}^{\sigma}_{h} = \{\hat{holds}(s, a, o, \sigma) \mid s \in {\cal E}_{s}, a \in {\cal E}_{a}, o \in {\cal E}_{o}\}$

            ${\cal A}^{\sigma}_{m} = {\cal A}^{\sigma}_{ms} \cup {\cal A}^{\sigma}_{ma} \cup {\cal A}^{\sigma}_{mo}$

            ${\cal A}^{\sigma}_{s} = {\cal A}^{\sigma}_{ss} \cup {\cal A}^{\sigma}_{sa} \cup {\cal A}^{\sigma}_{so}$

            ${\cal A}^{\sigma}_{ms} = \{\hat{memb}(e, g, \sigma) \mid e \in {\cal E}_{ss}, g \in {\cal E}_{sg}\}$

            ${\cal A}^{\sigma}_{ma} = \{\hat{memb}(e, g, \sigma) \mid e \in {\cal E}_{as}, g \in {\cal E}_{ag}\}$

            ${\cal A}^{\sigma}_{mo} = \{\hat{memb}(e, g, \sigma) \mid e \in {\cal E}_{os}, g \in {\cal E}_{og}\}$

            ${\cal A}^{\sigma}_{ss} = \{\hat{subst}(g1, g2, \sigma) \mid g1, g2 \in {\cal E}_{sg}\}$

            ${\cal A}^{\sigma}_{sa} = \{\hat{subst}(g1, g2, \sigma) \mid g1, g2 \in {\cal E}_{ag}\}$

            ${\cal A}^{\sigma}_{so} = \{\hat{subst}(g1, g2, \sigma) \mid g1, g2 \in {\cal E}_{og}\}$
          \end{vquote}

        \paragraph{Facts.}

          A fact is a logical statement that makes a claim that an atom either
          holds or does not hold at a particular state. The following is the
          formal definition of fact $f$ in state $\sigma$:

          \begin{vquote}
            $f^{\sigma}$ = $[\lnot]$$\alpha$, $\alpha$ $\in$ ${\cal A}^{\sigma}$
          \end{vquote}

      \subsubsection{Translating Language ${\cal L}$ to Language ${\cal L^{*}}$}

        Given a domain description ${\cal D_{L}}$ of language ${\cal L}$, we
        translate ${\cal D_{L}}$ into an extended logic program of language
        ${\cal L^{*}}$, as denoted by $Trans$(${\cal D_{L}}$). The semantics of
        ${\cal D_{L}}$ are provided by the answer sets of the extended logic
        program $Trans$(${\cal D_{L}}$). Before we can fully define
        $Trans$(${\cal D}_{\cal L}$), we must first define the following
        functions:

        The $CopyAtom$ function takes two arguments: an atom $\hat{\alpha}$
        of language ${\cal L}^{*}$ at some state $\sigma$ and another state
        $\sigma'$. The function returns an equivalent atom of the same type
        and with the same entities, but in the new state specified.

        \begin{vquote}
          $CopyAtom$($\hat{\alpha}$, $\sigma'$)

          \hspace{1em}
          =
          \begin{math}
            \begin{cases}
              \mbox{$\hat{holds}$($s$, $a$, $o$, $\sigma'$), if $\hat{\alpha}$ = $\hat{holds}$($s$, $a$, $o$, $\sigma$)} \\
              \mbox{$\hat{memb}$($e$, $g$, $\sigma'$), if $\hat{\alpha}$ = $\hat{memb}$($e$, $g$, $\sigma$)} \\
              \mbox{$\hat{subst}$($g_{1}$, $g_{2}$, $\sigma'$), if $\hat{\alpha}$ = $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$)}
            \end{cases}
          \end{math}
        \end{vquote}

        Another function, $TransAtom$, takes an atom $\alpha$ of language
        ${\cal L}$ and an arbitrary state $\sigma$ and returns the equivalent
        atom of language ${\cal L}^{*}$.

        \begin{vquote}
          $TransAtom$($\alpha$, $\sigma$)

          \hspace{1em}
          =
          \begin{math}
            \begin{cases}
              \mbox{$\hat{holds}$($s$, $a$, $o$, $\sigma$), if $\alpha$ = $holds$($s$, $a$, $o$)} \\
              \mbox{$\hat{memb}$($e$, $g$, $\sigma$), if $\alpha$ = $memb$($e$, $g$)} \\
              \mbox{$\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$), if $\alpha$ = $subst$($g_{1}$, $g_{2}$)}
            \end{cases}
          \end{math}
        \end{vquote}

        The $TransFact$ function is similar to the $TransAtom$
        function, but instead of translating an atom, it takes a fact
        from language ${\cal L}$ and a state then returns the equivalent
        fact in language ${\cal L}^{*}$.

        \paragraph{Initial Fact Rules.}

          The process of franslating initial fact expressions of language
          ${\cal L}$ to language ${\cal L}^{*}$ rules is trivial:
          translate each fact that make up the initial fact expression of
          language ${\cal L}$ with its corresponding equivalent initial state
          atom of language ${\cal L}^{*}$.

          Given an initial fact expression of language ${\cal L}$ that is
          composed of $n$ facts:

          \begin{vverbatim}
  \(f\sb{0}\) && \ldots && \(f\sb{n}\)
          \end{vverbatim}

          In language ${\cal L}^{*}$, the statement above is translated to:

          \begin{vquote}
            $\hat{f_{0}}$ $\leftarrow$

            $\vdots$

            $\hat{f_{n}}$ $\leftarrow$
          \end{vquote}

          \begin{vquote}
            where

            $\hat{f_{i}}$ $=$ $TransFact$($f_{i}$, $S_{0}$),

            $0$ $\leq$ $i$ $\leq$ $n$
          \end{vquote}

          As shown above, the number of initial fact rules generated from the
          translation is the number of facts $n$ in the given language
          ${\cal L}$ initial fact expression.

          The following code shows an example of a language ${\cal L}$
          $initially$ statement:

          \begin{vverbatim}
  initially
    holds(admins, read, sys\_data) &&
    memb(alice, admins) &&
    memb(bob, admins);
          \end{vverbatim}

        In language ${\cal L}^{*}$, the above statements are translated to:

        \begin{vquote}
          $\hat{holds}$($admins$, $read$, $sys\_data$, $S_{0}$) $\leftarrow$

          $\hat{memb}$($alice$, $admins$, $S_{0}$) $\leftarrow$

          $\hat{memb}$($bob$, $admins$, $S_{0}$) $\leftarrow$
        \end{vquote}

        \paragraph{Constraint Rules.}

          Each constraint rule in language ${\cal L}$ is expressed as a series
          of logical rules in language ${\cal L}^{*}$. Given that all variable
          occurrences have been grounded to entity identifiers, a constraint in
          language ${\cal L}$, with $m$, $n$, $o$ $\geq$ $0$ may be represented
          as:

          \begin{vverbatim}
  always \(a\sb{0}\) && \ldots && \(a\sb{m}\)
    implied by \(b\sb{0}\) && \ldots && \(b\sb{n}\)
    with absence \(c\sb{0}\) && \ldots && \(c\sb{o}\);
          \end{vverbatim}

          Each fact in the $always$ clause of language ${\cal L}$ corresponds
          to a new rule, where it is the consequent. Each of these new rules
          will have expression $b$ in the $implied$ $by$ clause as the positive
          premise and the expression $c$ in the $with$ $absence$ clause as the
          negative premise.

          \begin{vquote}
            $a_{0}$ $\leftarrow$
            $b_{0}$, \ldots, $b_{n}$,
            $not$ $c_{0}$, \ldots, $not$ $c_{o}$

            $\vdots$

            $a_{m}$ $\leftarrow$
            $b_{0}$, \ldots, $b_{n}$,
            $not$ $c_{0}$, \ldots, $not$ $c_{o}$
          \end{vquote}

          Under the definition of constraints, each of the rules listed above
          must be made to hold in all states as defined by the sequence list
          $\psi$. This can be accomplished by translating each of the above
          rules to a set of $|\psi|$ rules, one for each state.

           \begin{vquote}
            $\hat{a}^{S_{0}}_{0}$ $\leftarrow$
            $\hat{b}^{S_{0}}_{0}$, \ldots, $\hat{b}^{S_{0}}_{n}$,
            $not$ $\hat{c}^{S_{0}}_{0}$, \ldots, $not$ $\hat{c}^{S_{0}}_{o}$

            $\vdots$

            $\hat{a}^{S_{|\psi|}}_{0}$ $\leftarrow$
            $\hat{b}^{S_{|\psi|}}_{0}$, \ldots, $\hat{b}^{S_{|\psi|}}_{n}$,
            $not$ $\hat{c}^{S_{|\psi|}}_{0}$, \ldots, $not$ $\hat{c}^{S_{|\psi|}}_{o}$

            $\vdots$

            $\hat{a}^{S_{0}}_{m}$ $\leftarrow$
            $\hat{b}^{S_{0}}_{0}$, \ldots, $\hat{b}^{S_{0}}_{n}$,
            $not$ $\hat{c}^{S_{0}}_{0}$, \ldots, $not$ $\hat{c}^{S_{0}}_{o}$

            $\vdots$

            $\hat{a}^{S_{|\psi|}}_{m}$ $\leftarrow$
            $\hat{b}^{S_{|\psi|}}_{0}$, \ldots, $\hat{b}^{S_{|\psi|}}_{n}$,
            $not$ $\hat{c}^{S_{|\psi|}}_{0}$, \ldots, $not$ $\hat{c}^{S_{|\psi|}}_{o}$
          \end{vquote}

          \begin{vquote}
            where

            $\hat{a}^{\sigma}_{i}$ $=$ $TransFact$($a_{i}$, $\sigma$),
            $0$ $\leq$ $i$ $\leq$ $m$,

            $\hat{b}^{\sigma}_{j}$ $=$ $TransFact$($b_{j}$, $\sigma$),
            $0$ $\leq$ $j$ $\leq$ $n$,

            $\hat{c}^{\sigma}_{k}$ $=$ $TransFact$($c_{k}$, $\sigma$),
            $0$ $\leq$ $k$ $\leq$ $o$,

            $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
          \end{vquote}

          For a given language ${\cal L}$ constraint rule, the number of
          constraint rules generated in the translation is:

          \begin{quote}
            $m$ $|\psi|$
          \end{quote}

          The example below shows how the following language ${\cal L}$ code
          fragment is translated to language ${\cal L}^{*}$:

          \begin{vverbatim}
  always
    holds(alice, read, data) &&
    holds(alice, write, data)
  implied by
    memb(alice, admin)
  with absence
    !holds(alice, own, data);
          \end{vverbatim}

          Given a policy update reference in the sequence list $\psi$ (i.e.
          $|\psi|$ $=$ $1$), the language ${\cal L}^{*}$ equivalent is as
          follows:

          \begin{vquote}
            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, data, S_{0}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{0}), \\
                 & not \lnot \hat{holds}(alice, own, data, S_{0})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, data, S_{0}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{0}), \\
                 & not \lnot \hat{holds}(alice, own, data, S_{0})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, data, S_{1}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{1}), \\
                 & not \lnot \hat{holds}(alice, own, data, S_{1})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, data, S_{1}) \leftarrow \\
                 & \hat{memb}(alice, admin, S_{1}), \\
                 & not \lnot \hat{holds}(alice, own, data, S_{1})
              \end{aligned}
            \end{math}
          \end{vquote}

        \paragraph{Policy Update Rules.}

          Given that $m$, $n$ $\geq$ $0$, all occurences of variable
          place-holders grounded to entity identifiers, a policy update $u$ in
          language ${\cal L}$ is in the form:

          \begin{vverbatim}
  \(u\) causes \(a\sb{0}\) && \ldots && \(a\sb{m}\)
  if \(b\sb{0}\) && \ldots && \(b\sb{n}\);
          \end{vverbatim}

          In language ${\cal L}^{*}$, such policy updates may be represented as
          a set of implications, with each fact $a$ in the postcondition
          expression as the consequent and precondition expression $b$ as the
          premise. However, the translation process must also take into account
          that the premise of the implication holds in the state before the
          policy update is applied and that the consequent holds in the state
          after the application.

          \begin{vquote}
            $\hat{a}_{0}$ $\leftarrow$ $\hat{b}_{0}$, \ldots, $\hat{b}_{n}$

            $\vdots$

            $\hat{a}_{m}$ $\leftarrow$ $\hat{b}_{0}$, \ldots, $\hat{b}_{n}$
          \end{vquote}

          \begin{vquote}
            where

            $\hat{a}_{i}$ $=$ $TransFact$($a_{i}$, $Res$($u$, $\sigma$)),
            $0$ $\leq$ $i$ $\leq$ $m$,

            $\hat{b}_{j}$ $=$ $TransFact$($b_{j}$, $\sigma$),
            $0$ $\leq$ $j$ $\leq$ $n$
          \end{vquote}

          Intuitively, the number of language ${\cal L}^{*}$ rules generated
          in the translation is $m$, which is the number of facts in the
          postcondition expression of a given language ${\cal L}$ policy update
          rule.

          For example, given the following 2 language ${\cal L}$ policy update
          definitions:

          \begin{vverbatim}
  grant\_read()
    causes holds(alice, read, file)
    if memb(alice, readers);

  grant\_write()
    causes holds(alice, write, file)
    if memb(alice, writers);
          \end{vverbatim}

          Given the update sequence list $\psi$ constains
          \{$grant\_read$, $grant\_write$\}, the above statements are written
          in language ${\cal L}^{*}$ as:

          \begin{vquote}
            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                & \hat{memb}(alice, readers, S_{0})
              \end{aligned}
            \end{math}

            \begin{math}
              \begin{aligned}[t]
                \hat{holds}&(alice, write, file, S_{2}) \leftarrow \\
                & \hat{memb}(alice, writers, S_{1})
              \end{aligned}
            \end{math}
          \end{vquote}

        \paragraph{Additional Constraints.}

          In addition to the translations discussed above, there are a few
          other implicit constraint rules implied by language ${\cal L}$
          that need to be explicitly defined in language ${\cal L}^{*}$.

          \begin{itemize}
            \item
              {\em Inheritance rules.}
              All properties held by a group is inherited by all the members
              and subsets of that group. This rule is easy to apply for subject
              group entities. However, careful attention must be given to access
              right and object groups. A subject holding an access right for an
              object group implies that the subject also holds that access
              right for all objects in the object group. Similarly, a subject
              holding an access right group for a particular object implies
              that the subject holds all access rights contained in the access
              right group for that object.

              A conflict is encountered when a particular property is to be
              inherited by an entity from a group of which it is a member or
              subset, and the contained entity already holds the negation of
              that property. This conflict is resolved by giving negative facts
              higher precedence over its positive counterpart: by allowing
              member or subset entities to inherit its parent group's
              properties only if the entities do not already hold the negation
              of those properties.

              The following are the inheritance constraint rules to allow the
              properties held by a group to propagate to its members and
              subsets that do not already hold the negation of the properties.

              \begin{enumerate}
                \item
                  Subject Group Membership Inheritance

                  \begin{vquote}
                    $\forall$ ($s_{s}$, $s_{g}$, $a$, $o$, $\sigma$),
                    where

                    $s_{s} \in {\cal E}_{ss}$,
                    $s_{g} \in {\cal E}_{sg}$,
                    $a \in {\cal E}_{a}$,
                    $o \in {\cal E}_{o}$,
                    $S_{0}{\leq}{\sigma}{\leq}S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{holds}&(s_{s}, a, o, \sigma) \leftarrow \\
                        & \hat{holds}(s_{g}, a, o, \sigma), \\
                        & \hat{memb}(s_{s}, s_{g}, \sigma), \\
                        & not \lnot \hat{holds}(s_{s}, a, o, \sigma) \\
                        \lnot \hat{holds}&(s_{s}, a, o, \sigma) \leftarrow \\
                        & \lnot \hat{holds}(s_{g}, a, o, \sigma), \\
                        & \hat{memb}(s_{s}, s_{g}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}
                \item
                  Access Right Group Membership Inheritance

                  \begin{vquote}
                    $\forall$ ($s$, $a_{s}$, $a_{g}$, $o$, $\sigma$),
                    where

                    $s \in {\cal E}_{s}$,
                    $a_{s} \in {\cal E}_{as}$,
                    $a_{g} \in {\cal E}_{ag}$,
                    $o \in {\cal E}_{o}$,
                    $S_{0}{\leq}{\sigma}{\leq}S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{holds}&(s, a_{s}, o, \sigma) \leftarrow \\
                        & \hat{holds}(s, a_{g}, o, \sigma), \\
                        & \hat{memb}(a_{s}, a_{g}, \sigma), \\
                        & not \lnot \hat{holds}(s, a_{s}, o, \sigma) \\
                        \lnot \hat{holds}&(s, a_{s}, o, \sigma) \leftarrow \\
                        & \lnot \hat{holds}(s, a_{g}, o, \sigma), \\
                        & \hat{memb}(a_{s}, a_{g}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}

                 \item
                  Object Group Membership Inheritance

                  \begin{vquote}
                    $\forall$ ($s$, $a$, $o_{s}$, $o_{g}$, $\sigma$),
                    where

                    $s \in {\cal E}_{s}$,
                    $a \in {\cal E}_{a}$,
                    $o_{s} \in {\cal E}_{os}$,
                    $o_{g} \in {\cal E}_{og}$,
                    $S_{0}{\leq}{\sigma}{\leq}S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{holds}&(s, a, o_{s}, \sigma) \leftarrow \\
                        & \hat{holds}(s, a, o_{g}, \sigma), \\
                        & \hat{memb}(o_{s}, o_{g}, \sigma), \\
                        & not \lnot \hat{holds}(s, a, o_{s}, \sigma) \\
                        \lnot \hat{holds}&(s, a, o_{s}, \sigma) \leftarrow \\
                        & \lnot \hat{holds}(s, a, o_{g}, \sigma), \\
                        & \hat{memb}(o_{s}, o_{g}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}

                \item
                  Subject Group Subset Inheritance

                  \begin{vquote}
                    $\forall$ ($s_{g1}$, $s_{g2}$, $a$, $o$, $\sigma$),
                    where

                    $s_{g1}, s_{g2} \in {\cal E}_{sg}$,
                    $a \in {\cal E}_{a}$,
                    $o \in {\cal E}_{o}$,
                    $S_{0} \leq \sigma \leq S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{holds}&(s_{g1}, a, o, \sigma) \leftarrow \\
                        & \hat{holds}(s_{g2}, a, o, \sigma), \\
                        & \hat{subst}(s_{g1}, s_{g2}, \sigma), \\
                        & not \lnot \hat{holds}(s_{g1}, a, o, \sigma) \\
                        \lnot \hat{holds}&(s_{g1}, a, o, \sigma) \leftarrow \\
                        & \lnot \hat{holds}(s_{g2}, a, o, \sigma), \\
                        & \hat{subst}(s_{g1}, s_{g2}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}

                \item
                  Access Right Group Subset Inheritance

                  \begin{vquote}
                    $\forall$ ($s$, $a_{g1}$, $a_{g2}$, $o$, $\sigma$),
                    where

                    $s \in {\cal E}_{s}$,
                    $a_{g1}, a_{g2} \in {\cal E}_{ag}$,
                    $o \in {\cal E}_{o}$,
                    $S_{0} \leq \sigma \leq S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{holds}&(s, a_{g1}, o, \sigma) \leftarrow \\
                        & \hat{holds}(s, a_{g2}, o, \sigma), \\
                        & \hat{subst}(a_{g1}, a_{g2}, \sigma), \\
                        & not \lnot \hat{holds}(s, a_{g1}, o, \sigma) \\
                        \lnot \hat{holds}&(s, a_{g1}, o, \sigma) \leftarrow \\
                        & \lnot \hat{holds}(s, a_{g2}, o, \sigma), \\
                        & \hat{subst}(a_{g1}, a_{g2}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}

                \item
                  Object Group Subset Inheritance

                  \begin{vquote}
                    $\forall$ ($s$, $a$, $o_{g1}$, $o_{g2}$, $\sigma$),
                    where

                    $s \in {\cal E}_{s}$,
                    $a \in {\cal E}_{a}$,
                    $o_{g1}, o_{g2} \in {\cal E}_{og}$,
                    $S_{0} \leq \sigma \leq S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{holds}&(s, a, o_{g1}, \sigma) \leftarrow \\
                        & \hat{holds}(s, a, o_{g2}, \sigma), \\
                        & \hat{subst}(o_{g1}, o_{g2}, \sigma), \\
                        & not \lnot \hat{holds}(s, a, o_{g1}, \sigma) \\
                        \lnot \hat{holds}&(s, a, o_{g1}, \sigma) \leftarrow \\
                        & \lnot \hat{holds}(s, a, o_{g2}, \sigma), \\
                        & \hat{subst}(o_{g1}, o_{g2}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}
              \end{enumerate}

            \item
              {\em Transitivity rules.}
              Given three groups $G$, $G'$ and $G''$. If $G$ is a subset of
              $G'$ and $G'$ is a subset of $G''$, then $G$ must also be a
              subset of $G''$. The following rules ensure that the transitive
              property of subject, access right and object groups hold:

              \begin{enumerate}
                \item
                  Subject Group Transitivity

                  \begin{vquote}
                    $\forall$ ($sg_{1}$, $sg_{2}$, $sg_{3}$, $\sigma$),
                    where

                    $sg_{1}, sg_{2}, sg_{3} \in {\cal E}_{sg}$,
                    $S_{0} \leq \sigma \leq S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{subst}&(sg_{1}, sg_{3}, \sigma) \leftarrow \\
                        & \hat{subst}(sg_{1}, sg_{2}, \sigma), \\
                        & \hat{subst}(sg_{2}, sg_{3}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}

                \item
                  Access Right Group Transitivity

                  \begin{vquote}
                    $\forall$ ($ag_{1}$, $ag_{2}$, $ag_{3}$, $\sigma$),
                    where

                    $ag_{1}, ag_{2}, ag_{3} \in {\cal E}_{ag}$,
                    $S_{0} \leq \sigma \leq S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{subst}&(ag_{1}, ag_{3}, \sigma) \leftarrow \\
                        & \hat{subst}(ag_{1}, ag_{2}, \sigma), \\
                        & \hat{subst}(ag_{2}, ag_{3}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}

                \item
                  Object Group Transitivity

                  \begin{vquote}
                    $\forall$ ($og_{1}$, $og_{2}$, $og_{3}$, $\sigma$),
                    where

                    $og_{1}, og_{2}, og_{3} \in {\cal E}_{og}$,
                    $S_{0} \leq \sigma \leq S_{|\psi|}$
                  \end{vquote}

                  \begin{vquote}
                    \begin{math}
                      \begin{aligned}[t]
                        \hat{subst}&(og_{1}, og_{3}, \sigma) \leftarrow \\
                        & \hat{subst}(og_{1}, og_{2}, \sigma), \\
                        & \hat{subst}(og_{2}, og_{3}, \sigma)
                      \end{aligned}
                    \end{math}
                  \end{vquote}
               \end{enumerate}

            \item
              {\em Inertial rules.}
              Intuitively, all facts in the current state that are not affected
              by a policy update should be carried over to the next state after
              the update. In language ${\cal L}^{*}$, this rule must be
              explicitly stated as a constraint. Formally, the inertial rules
              are expressed as follows:

              \begin{vquote}
                $\forall$($\hat{\alpha}$,$u$) $\exists$$\hat{\alpha}'$,
                where

                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$,
                $u$ $\in$ $\psi$,
                $\hat{\alpha}'$ = $CopyAtom$($\hat{\alpha}$, $Res$($u$, $\sigma$))
              \end{vquote}

              \begin{vquote}
                $\hat{\alpha}'$ $\leftarrow$ $\hat{\alpha}$, $not$ $\lnot$ $\hat{\alpha}'$

                $\lnot$ $\hat{\alpha}'$ $\leftarrow$ $\lnot$ $\hat{\alpha}$, $not$ $\hat{\alpha}'$
              \end{vquote}
          \end{itemize}

        \begin{vdefinition}
          \label{def-trans}
          Given a domain description ${\cal D_{L}}$ of language ${\cal L}$, its
          ${\cal L^{*}}$ translation $Trans$(${\cal D_{L}}$) is an extended
          logic program of language ${\cal L}$ consisting of: (1) initial fact
          rules, (2) constraint rules, (3) policy update rules, (4) inheritance
          rules, (5) transitivity rules, and (6) inertial rules, as described
          above.

          The domain description ${\cal D_{L}}$ of language ${\cal L}$ is said
          to be {\em consistent} if and only if the translation
          $Trans$(${\cal D_{L}}$) has a consistent answer set.
        \end{vdefinition}

        \begin{vexample}
          \label{ex-2}
          The following shows the language ${\cal L}$ program listing in
          Example \ref{ex-1},  translated into language ${\cal L}^{*}$.

          \begin{enumerate}
            \item
              Initial Fact Rules

              \begin{vquote}
                $\hat{memb}(alice, grp2, S_{0}) \leftarrow$

                $\hat{holds}(grp1, read, file,S_{0}) \leftarrow$

                $\hat{subst}(grp2, grp1, S_{0}) \leftarrow$
              \end{vquote}

            \item
              Constraint Rules

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % constraints (S0)
                    \hat{holds}&(grp1, write, file, S_{0}) \leftarrow \\
                    & \hat{holds}(grp1, read, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp3, write, file, S_{0}) \\
                    % constraints (S1)
                    \hat{holds}&(grp1, write, file, S_{1}) \leftarrow \\
                    & \hat{holds}(grp1, read, file, S_{1}), \\
                    & not \lnot \hat{holds}(grp3, write, file, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

            \item
              Policy Update Rules

              \begin{vquote}
                \begin{math}
                  \lnot \hat{holds}(grp1, read, file, S_{1}) \leftarrow
                \end{math}
              \end{vquote}

            \item
              Inheritance Rules

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inheritance rules (positive, read, S0)
                    \hat{holds}&(alice, read, file, S_{0}) \leftarrow \\
                    & \hat{holds}(grp1, read, file, S_{0}), \\
                    & \hat{memb}(alice, grp1, S_{0}), \\
                    & not \lnot \hat{holds}(alice, read, file, S_{0}) \\
                    % inheritance rules (negative, read, S0)
                    \lnot \hat{holds}&(alice, read, file, S_{0}) \leftarrow \\
                    & \lnot \hat{holds}(grp1, read, file, S_{0}), \\
                    & \hat{memb}(alice, grp1, S_{0})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inheritance rules (positive, write, S0)
                    \hat{holds}&(alice, write, file, S_{0}) \leftarrow \\
                    & \hat{holds}(grp1, write, file, S_{0}), \\
                    & \hat{memb}(alice, grp1, S_{0}), \\
                    & not \lnot \hat{holds}(alice, write, file, S_{0}) \\
                    % inheritance rules (negative, write, S0)
                    \lnot \hat{holds}&(alice, write, file, S_{0}) \leftarrow \\
                    & \lnot \hat{holds}(grp1, write, file, S_{0}), \\
                    & \hat{memb}(alice, grp1, S_{0})
                  \end{aligned}
                \end{math}
               \end{vquote}

              \begin{vquote}
                \hspace{5em}$\vdots$
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inheritance rules (positive, read, S1)
                    \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                    & \hat{holds}(grp3, read, file, S_{1}), \\
                    & \hat{memb}(alice, grp3, S_{1}), \\
                    & not \lnot \hat{holds}(alice, read, file, S_{1}) \\
                    % inheritance rules (negative, read, S1)
                    \lnot \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(grp3, read, file, S_{1}), \\
                    & \hat{memb}(alice, grp3, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inheritance rules (positive, write, S1)
                    \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                    & \hat{holds}(grp3, write, file, S_{1}), \\
                    & \hat{memb}(alice, grp3, S_{1}), \\
                    & not \lnot \hat{holds}(alice, write, file, S_{1}) \\
                    % inheritance rules (negative, write, S1)
                    \lnot \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(grp3, write, file, S_{1}), \\
                    & \hat{memb}(alice, grp3, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

            \item
              Transitivity Rules

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    \hat{subst}&(grp1, grp1, S_{0}) \leftarrow \\
                    & \hat{subst}(grp1, grp1, S_{0}), \\
                    & \hat{subst}(grp1, grp1, S_{0})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \hspace{5em}$\vdots$
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    \hat{subst}&(grp3, grp3, S_{1}) \leftarrow \\
                    & \hat{subst}(grp3, grp3, S_{1}), \\
                    & \hat{subst}(grp3, grp3, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

            \item
              Inertial Rules

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule holds(alice, read, file)
                    \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                    & \hat{holds}(alice, read, file, S_{0}), \\
                    & not \lnot \hat{holds}(alice, read, file, S_{1}) \\
                    % inertial rule !holds(alice, read, file)
                    \lnot \hat{holds}&(alice, read, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(alice, read, file, S_{0}), \\
                    & not \lnot \hat{holds}(alice, read, file, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule holds(alice, write, file)
                    \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                    & \hat{holds}(alice, write, file, S_{0}), \\
                    & not \lnot \hat{holds}(alice, write, file, S_{1}) \\
                    % inertial rule !holds(alice, write, file)
                    \lnot \hat{holds}&(alice, write, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(alice, write, file, S_{0}), \\
                    & not \lnot \hat{holds}(alice, write, file, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule holds(grp1, read, file)
                    \hat{holds}&(grp1, read, file, S_{1}) \leftarrow \\
                    & \hat{holds}(grp1, read, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp1, read, file, S_{1}) \\
                    % inertial rule !holds(grp1, read, file)
                    \lnot \hat{holds}&(grp1, read, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(grp1, read, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp1, read, file, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \hspace{5em}$\vdots$
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule holds(grp3, read, file)
                    \hat{holds}&(grp3, read, file, S_{1}) \leftarrow \\
                    & \hat{holds}(grp3, read, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp3, read, file, S_{1}) \\
                    % inertial rule !holds(grp3, read, file)
                    \lnot \hat{holds}&(grp3, read, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(grp3, read, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp3, read, file, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule holds(grp1, write, file)
                    \hat{holds}&(grp1, write, file, S_{1}) \leftarrow \\
                    & \hat{holds}(grp1, write, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp1, write, file, S_{1}) \\
                    % inertial rule !holds(grp1, write, file)
                    \lnot \hat{holds}&(grp1, write, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(grp1, write, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp1, write, file, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \hspace{5em}$\vdots$
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule holds(grp3, write, file)
                    \hat{holds}&(grp3, write, file, S_{1}) \leftarrow \\
                    & \hat{holds}(grp3, write, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp3, write, file, S_{1}) \\
                    % inertial rule !holds(grp3, write, file)
                    \lnot \hat{holds}&(grp3, write, file, S_{1}) \leftarrow \\
                    & \lnot \hat{holds}(grp3, write, file, S_{0}), \\
                    & not \lnot \hat{holds}(grp3, write, file, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule memb(alice, grp1)
                    \hat{memb}&(alice, grp1, S_{1}) \leftarrow \\
                    & \hat{memb}(alice, grp1, S_{0}), \\
                    & not \lnot \hat{memb}(alice, grp1, S_{1}) \\
                    % inertial rule !memb(alice, grp1)
                    \lnot \hat{memb}&(alice, grp1, S_{1}) \leftarrow \\
                    & \lnot \hat{memb}(alice, grp1, S_{0}), \\
                    & not \hat{memb}(alice, grp1, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \hspace{5em}$\vdots$
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule memb(alice, grp3)
                    \hat{memb}&(alice, grp3, S_{1}) \leftarrow \\
                    & \hat{memb}(alice, grp3, S_{0}), \\
                    & not \lnot \hat{memb}(alice, grp3, S_{1}) \\
                    % inertial rule !memb(alice, grp3)
                    \lnot \hat{memb}&(alice, grp3, S_{1}) \leftarrow \\
                    & \lnot \hat{memb}(alice, grp3, S_{0}), \\
                    & not \hat{memb}(alice, grp3, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule subst(grp1, grp1)
                    \hat{subst}&(grp1, grp1, S_{1}) \leftarrow \\
                    & \hat{subst}(grp1, grp1, S_{0}), \\
                    & not \lnot \hat{subst}(grp1, grp1, S_{1}) \\
                    % inertial rule !subst(grp1, grp1)
                    \lnot \hat{subst}&(grp1, grp1, S_{1}) \leftarrow \\
                    & \lnot \hat{memb}(grp1, grp1, S_{0}), \\
                    & not \hat{memb}(grp1, grp1, S_{1})
                  \end{aligned}
                \end{math}
              \end{vquote}

              \begin{vquote}
                \hspace{5em}$\vdots$
              \end{vquote}

              \begin{vquote}
                \begin{math}
                  \begin{aligned}[t]
                    % inertial rule subst(grp3, grp3)
                    \hat{subst}&(grp3, grp3, S_{1}) \leftarrow \\
                    & \hat{subst}(grp3, grp3, S_{0}), \\
                    & not \lnot \hat{subst}(grp3, grp3, S_{1}) \\
                    % inertial rule !subst(grp3, grp3)
                    \lnot \hat{subst}&(grp3, grp3, S_{1}) \leftarrow \\
                    & \lnot \hat{memb}(grp3, grp3, S_{0}), \\
                    & not \hat{memb}(grp3, grp3, S_{1}) \\
                  \end{aligned}
                \end{math}
              \end{vquote}
          \end{enumerate}
        \end{vexample}

        From the above example, it may be observed that given a domain
        description ${\cal D_{L}}$, the translation $Trans$(${\cal D_{L}}$) may
        contain more rules than the original statements in ${\cal D_{L}}$.
        However, as the theorem below defines the maximum number of rules
        generated in a translation $Trans$(${\cal D_{L}}$), it shows that
        the size of a translated domain $|$$Trans$(${\cal D_{L}}$)$|$ is only
        polynomially larger than the size of the given domain
        $|$${\cal D_{L}}$$|$. Therefore, from a computational viewpoint,
        computing the answer sets of $Trans$(${\cal D_{L}}$) is always
        feasible.

        \begin{vtheorem}{Translation Size}
          \label{the-size}
          Given a domain description ${\cal D_{L}}$; the sets ${\cal S}_{i}$,
          ${\cal S}_{c}$ and ${\cal S}_{u}$ containing the initially,
          constraint and policy update statements in ${\cal D_{L}}$,
          respectively; the set ${\cal E}$ containing all the entities in
          ${\cal D_{L}}$, including its subsets ${\cal E}_{s}$, ${\cal E}_{a}$,
          ${\cal E}_{s}$, ${\cal E}_{ss}$, ${\cal E}_{as}$, ${\cal E}_{os}$,
          ${\cal E}_{sg}$, ${\cal E}_{ag}$, ${\cal E}_{og}$; the set ${\cal A}$
          containing all the atoms in ${\cal D_{L}}$; the maximum number
          of facts $M_{i}$ in the expression of any $initially$ statement in
          ${\cal S}_{i}$; the maximum number of facts $M_{c}$ in the $always$
          clause expression of any constraint statement in ${\cal S}_{c}$;
          the maximum number of facts $M_{u}$ in the postcondition expression
          of any policy update statement in ${\cal S}_{u}$; and finally the
          policy update sequence list $\psi$, then the maximum size of the
          translation $Trans$(${\cal D_{L}}$) is:

         \begin{vquote}
            $|$$Trans$(${\cal D_{L}}$)$|$ $\leq$

            \hspace{1em}
            % initially
            $M_{i}$ $|{\cal S}_{i}|$ +
            % constraints
            $M_{c}$ $|{\cal S}_{c}|$ $|\psi|$ +
            % policy updates
            $M_{u}$ $|\psi|$ +

            % membership inheritance
            \hspace{1em}
            $2|\psi|$$|{\cal E}_{ss}|$ $|{\cal E}_{sg}|$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{as}|$ $|{\cal E}_{ag}|$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{os}|$ $|{\cal E}_{og}|$

            % subset inheritance
            \hspace{1em}
            $2|\psi|$$|{\cal E}_{sg}|^{2}$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{ag}|^{2}$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{og}|^{2}$

            % transitivity rules
            \hspace{1em}
            $|\psi|$ $($$|{\cal E}_{sg}|^{3}$ +
            $|{\cal E}_{ag}|^{3}$ +
            $|{\cal E}_{og}|^{3}$$)$ +

            % inertial rules
            \hspace{1em}
            $2$ $|{\cal A}|$ $|\psi|$ +
          \end{vquote}
        \end{vtheorem}

        \begin{vproof}
          From Definition \ref{def-trans}, it follows that the size of a
          language ${\cal L}^{*}$ translation is:

          \begin{vquote}
            $|$$Trans$(${\cal D_{L}}$)$|$ =

            \hspace{1em}
            $|$${\cal R}_{int}$$|$ +
            $|$${\cal R}_{con}$$|$ +
            $|$${\cal R}_{upd}$$|$ +
            $|$${\cal R}_{inh}$$|$ +
            $|$${\cal R}_{tra}$$|$ +
            $|$${\cal R}_{ine}$$|$
          \end{vquote}

          where ${\cal R}_{int}$, ${\cal R}_{con}$, ${\cal R}_{upd}$,
          ${\cal R}_{inh}$, ${\cal R}_{tra}$, ${\cal R}_{ine}$ are the sets of
          initial fact rules, constraint rules, policy update rules,
          inheritance rules, transitivity rules and inertial rules,
          respectively.

          As no $initially$ statement in ${\cal S}_{i}$ contain an expression
          with more than $M_{i}$ facts, the maximum number of initial fact
          rules generated in the translation is:

          \begin{vquote}
            $|$${\cal R}_{int}$$|$ $\leq$ $M_{i}$ $|$${\cal S}_{i}$$|$
          \end{vquote}

          Each language ${\cal L}$ constraint statement in ${\cal S}_{c}$
          corresponds to $n$ rules in language ${\cal L}^{*}$, where $n$ is
          the number of policy update states times the number of facts in the
          {\em always} clause of the statement. With $M_{c}$ as the maximal
          number of facts in the {\em always} clause of any constraint
          statement, we have:

          \begin{vquote}
            $|$${\cal R}_{con}$$|$ $\leq$ $M_{c}$ $|$${\cal S}_{c}$$|$ $|\psi|$
          \end{vquote}

          For policy update statements, only those that are applied are
          actually translated to language ${\cal L}^{*}$. With $M_{u}$ as the
          maximal number of facts in the postcondition expression of any
          applied policy update statement, we have:

          \begin{vquote}
            $|$${\cal R}_{con}$$|$ $\leq$ $M_{u}$ $|\psi|$
          \end{vquote}

          The total number of inheritance rules generated in the translation is
          the sum of the number of member inheritance rules and the number of
          subset inheritance rules:

          \begin{vquote}
            $|$${\cal R}_{inh}$$|$ =
            $|$${\cal R}_{inh_{m}}$$|$ +
            $|$${\cal R}_{inh_{s}}$$|$
          \end{vquote}

          Since the membership inheritance rules show the relationships between
          every possible combination of single and group entities times the
          number of states times 2 (for negative facts), we have:

          \begin{vquote}
            $|$${\cal R}_{inh_{m}}$$|$ =

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{ss}|$ $|{\cal E}_{sg}|$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{as}|$ $|{\cal E}_{ag}|$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{os}|$ $|{\cal E}_{og}|$
          \end{vquote}

          For subset inheritance rules, only the relationships between group
          entities are considered:

          \begin{vquote}
            $|$${\cal R}_{inh_{s}}$$|$ =

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{sg}|^{2}$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{ag}|^{2}$ $|{\cal E}_{o}|$ +

            \hspace{1em}
            $2|\psi|$$|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{og}|^{2}$
          \end{vquote}

          As transitivity rules enumerate every possible combinations of any
          three group entities, for each entity type, the total number of
          transitivity rules is shown below:

          \begin{vquote}
            $|$${\cal R}_{tra}$$|$ =
            $|\psi|$ $($$|{\cal E}_{sg}|^{3}$ +
            $|{\cal E}_{ag}|^{3}$ +
            $|{\cal E}_{og}|^{3}$$)$
          \end{vquote}

          Finally, a single atom in language ${\cal L}$ corresponds to $n$
          inertial rules, where $n$ is the number of states times 2 (for
          negative facts):

          \begin{vquote}
            $|$${\cal R}_{ine}$$|$ =
            $2$ $|{\cal A}|$ $|\psi|$
          \end{vquote}
        \end{vproof}

  \section{Domain Consistency Checking and Evaluation}
    \label{sec-cons}

    A domain description of language ${\cal L}$ must be consistent in order
    generate a consistent answer set for the evaluation of queries. This
    section considers two issues: the problem of identifying whether a given
    domain description is consistent, and how query evaluation is performed
    given a consistent language domain description.

    Before the above issues can be considered, a few notational constructs
    must first be introduced. Given a domain description ${\cal D_{L}}$
    composed of the following language ${\cal L}$ statements:

    \begin{vverbatim}
  initially
    \(a\sb{0}\) && \ldots && \(a\sb{n}\) && !\(b\sb{0}\) && \ldots && !\(b\sb{m}\)

  always
    \(c\sb{0}\) && \ldots && \(c\sb{o}\) && !\(d\sb{0}\) && \ldots && !\(d\sb{p}\)
    implied by
    \(e\sb{0}\) && \ldots && \(e\sb{q}\) && !\(f\sb{0}\) && \ldots && !\(f\sb{r}\)
    with absence
    \(g\sb{0}\) && \ldots && \(g\sb{s}\) && !\(h\sb{0}\) && \ldots && !\(h\sb{t}\)

  update()
    causes
    \(i\sb{0}\) && \ldots && \(i\sb{u}\) && !\(j\sb{0}\) && \ldots && !\(j\sb{v}\)
    if
    \(k\sb{0}\) && \ldots && \(k\sb{w}\) && !\(l\sb{0}\) && \ldots && !\(l\sb{x}\)
    \end{vverbatim}

    We define the following sets of ground facts:

    \begin{vquote}
      ${\cal F}^{+}_{int}$ = \{$a_{z}$ $\mid$ $0$ $\leq$ $z$ $\leq$ $n$\}

      ${\cal F}^{-}_{int}$ = \{$b_{z}$ $\mid$ $0$ $\leq$ $z$ $\leq$ $m$\}

      ${\cal F}^{+}_{con}$ = \{$c_{z}$ $\mid$ $0$ $\leq$ $z$ $\leq$ $o$\}

      ${\cal F}^{-}_{con}$ = \{$d_{z}$ $\mid$ $0$ $\leq$ $z$ $\leq$ $p$\}

      ${\cal F}^{+}_{upd}$ = \{$i_{z}$ $\mid$ $0$ $\leq$ $z$ $\leq$ $u$\}

      ${\cal F}^{-}_{upd}$ = \{$j_{z}$ $\mid$ $0$ $\leq$ $z$ $\leq$ $v$\}
    \end{vquote}

    Additionally, we use the complementary set notation
    $\overline{{\cal F}}$ to denote a set containing the negation of
    facts in set ${\cal F}$, i.e. $\overline{{\cal F}}$ =
    \{$\lnot\rho$ $\mid$ $\rho$ $\in$ ${\cal F}$\}.

    Let $\gamma$ be an initial, constraint or policy update definition
    statement of language ${\cal L}$. We then define the following functions:

    \begin{vquote}
      $Eff$($\gamma$)

      \hspace{1em}
      =
      \begin{math}
        \begin{cases}
          \mbox{\{$a_{0}$, \ldots, $a_{n}$, $\lnot$$b_{0}$, \ldots, $\lnot$$b_{m}$\}, if $\gamma$ is initially} \\
          \mbox{\{$c_{0}$, \ldots, $c_{o}$, $\lnot$$d_{0}$, \ldots, $\lnot$$d_{p}$\}, if $\gamma$ is constraint} \\
          \mbox{\{$i_{0}$, \ldots, $i_{u}$, $\lnot$$j_{0}$, \ldots, $\lnot$$j_{v}$\}, if $\gamma$ is update}
        \end{cases}
      \end{math}
    \end{vquote}

    \begin{vquote}
      $Def$($\gamma$)

      \hspace{1em}
      =
      \begin{math}
        \begin{cases}
          \mbox{$\emptyset$, if $\gamma$ is initially} \\
          \mbox{\{$g_{0}$, \ldots, $g_{s}$, $\lnot$$h_{0}$, \ldots, $\lnot$$h_{t}$\}, if $\gamma$ is constraint} \\
          \mbox{$\emptyset$, if $\gamma$ is update}
        \end{cases}
      \end{math}
    \end{vquote}

    \begin{vquote}
      $Pre$($\gamma$)

      \hspace{1em}
      =
      \begin{math}
        \begin{cases}
          \mbox{$\emptyset$, if $\gamma$ is initially} \\
          \mbox{\{$e_{0}$, \ldots, $e_{q}$, $\lnot$$f_{0}$, \ldots, $\lnot$$f_{r}$\}, if $\gamma$ is constraint} \\
          \mbox{\{$k_{0}$, \ldots, $k_{w}$, $\lnot$$l_{0}$, \ldots, $\lnot$$l_{x}$\}, if $\gamma$ is update}
        \end{cases}
      \end{math}
    \end{vquote}

    \begin{vdefinition}
      \label{def-mutex}
      Given a domain description ${\cal D_{L}}$ of language ${\cal L}$,
      two ground facts $\rho$ and $\rho'$ are {\em mutually exclusive}
      in ${\cal D_{L}}$ if:
      \begin{vquote}
        $\rho$ $\in$ \{${\cal F}^{+}_{int}$ $\cup$
        $\overline{{\cal F}^{-}_{int}}$ $\cup$ ${\cal F}^{+}_{con}$ $\cup$
        $\overline{{\cal F}^{-}_{con}}$ $\cup$ ${\cal F}^{+}_{upd}$ $\cup$
        $\overline{{\cal F}^{-}_{upd}}$\}

        implies

        $\rho'$ $\not\in$ \{${\cal F}^{+}_{int}$ $\cup$
        $\overline{{\cal F}^{-}_{int}}$ $\cup$ ${\cal F}^{+}_{con}$ $\cup$
        $\overline{{\cal F}^{-}_{con}}$ $\cup$ ${\cal F}^{+}_{upd}$ $\cup$
        $\overline{{\cal F}^{-}_{upd}}$\}
      \end{vquote}
    \end{vdefinition}

    Simply stated, a pair of mutually exclusive facts cannot both be true
    in any given state. The following two definitions refer to language
    ${\cal L}$ statements.

    \begin{vdefinition}
      \label{def-comp}
      Given a domain description ${\cal D_{L}}$ of language ${\cal L}$,
      two statements $\gamma$ and $\gamma'$ are {\em complementary} in
      ${\cal D_{L}}$ if one of the following conditions holds:
      \begin{enumerate}
        \item
          $\gamma$ and $\gamma'$ are both constraint statements and
          $Eff(\gamma)$ = $\overline{Eff(\gamma')}$.
        \item
          $\gamma$ is a constraint statement, $\gamma'$ is an update
          statement and $Eff(\gamma)$ = $\overline{Eff(\gamma')}$.
      \end{enumerate}
    \end{vdefinition}

    \begin{vdefinition}
      \label{def-norm}
      Given a domain description ${\cal D_{L}}$, ${\cal D_{L}}$ is said to
      be {\em normal} if it satisfies all of the following conditions:
      \begin{enumerate}
        \item
          \label{def-norm-1}
          ${\cal F}^{+}_{int}$ $\cap$ ${\cal F}^{-}_{int}$ = $\emptyset$
        \item
          \label{def-norm-2}
          For any two constraint statements $\gamma$ and $\gamma'$ in
          ${\cal D_{L}}$, including $\gamma$ = $\gamma'$, $Def(\gamma)$ $\cap$
          $Eff(\gamma')$ = $\emptyset$.
        \item
          \label{def-norm-3}
          For all constraint statements $\gamma$ in ${\cal D_{L}}$,
          $\overline{Eff(\gamma)}$ $\cap$ $Pre(\gamma)$ = $\emptyset$.
        \item
          \label{def-norm-4}
          For any two {\em complementary} statements $\gamma$ and $\gamma'$ in
          ${\cal D_{L}}$, there exists a pair of ground expression $\epsilon$
          $\in$ $Pre(\gamma)$ and $\epsilon'$ $\in$ $Pre(\gamma')$ such that
          $\epsilon$ and $\epsilon'$ are {\em mutually exclusive}.
      \end{enumerate}
    \end{vdefinition}

    With the above definitions, we can now provide a sufficient condition to
    ensure the consistency of a domain description.

    \begin{vtheorem}{Domain Consistency}
      \label{the-cons}
      A {\em normal} domain description of language ${\cal L}$ is also
      {\em consistent}.
    \end{vtheorem}

    \begin{vproof}
      From Definition \ref{def-trans}, given a normal domain description
      ${\cal D}_{\cal L}$, we only need to show that
      $Trans$(${\cal D}_{\cal L}$) has at least one consistent answer set to
      prove that ${\cal D}_{\cal L}$ is also consistent.

      Given a normal domain description ${\cal D}_{\cal L}$, Condition
      \ref{def-norm-2} in Definition \ref{def-norm} ensures that the
      translation $Trans$(${\cal D}_{\cal L}$) do not contain rules of the
      following form:

      \begin{vquote}
        $\hat{f_{0}}$ $\leftarrow$ $\hdots$, $not$ $\hat{f_{k}}$, $\hdots$

        $\hat{f_{1}}$ $\leftarrow$ $\hdots$, $\hat{f_{0}}$, $\hdots$

        $\vdots$

        $\hat{f_{k - 1}}$ $\leftarrow$ $\hdots$, $\hat{f_{k - 2}}$, $\hdots$

        $\hat{f_{k}}$ $\leftarrow$ $\hdots$, $\hat{f_{k - 1}}$, $\hdots$
      \end{vquote}

      The absence these rules means $Trans$(${\cal D}_{\cal L}$) is an
      {\em acyclic} program. As no other rules in ${\cal D}_{\cal L}$ can
      cause $Trans$(${\cal D}_{\cal L}$) to have these rules, we can conclude
      that under Defintion \ref{def-norm}, a normal domain description
      ${\cal D}_{\cal L}$ will generate an acyclic extended logic program
      $Trans$(${\cal D}_{\cal L}$). Also, from \cite{BAR}, we can further
      conclude that $Trans$(${\cal D}_{\cal L}$) must have an answer set.

      Condition \ref{def-norm-1} of Definition \ref{def-norm} prevents rules
      of the following form from occurring in $Trans$(${\cal D}_{\cal L}$):

      \begin{vquote}
        $\hat{f^{S_{0}}}$ $\leftarrow$

        $\lnot\hat{f^{S_{0}}}$ $\leftarrow$
      \end{vquote}

      This shows that a subset of the answer set which contains facts from the
      initial state $S_{0}$ is consistent.

      Condition \ref{def-norm-3} of Definition \ref{def-norm} guarantees that
      rules of the following form do not occur in $Trans$(${\cal D}_{\cal L}$):

      \begin{vquote}
        $\hat{f}$ $\leftarrow$ $\hdots$, $\lnot\hat{f}$, $\hdots$
      \end{vquote}

      This ensures that all constraint rules translated from
      ${\cal D}{\cal L}$ are consistent.

      Finally, Condition \ref{def-norm-4} of Definition \ref{def-norm}
      ensures that rules in $Trans$(${\cal D}_{\cal L}$) of the following form:

      \begin{vquote}
        $\hat{f}$ $\leftarrow$ $\hdots$, $\hat{f'}$, $\hdots$

        $\lnot \hat{f}$ $\leftarrow$ $\hdots$, $\hat{f''}$, $\hdots$
      \end{vquote}

      \noindent
      cannot both affect the answer set as the premises $f'$ and $f''$ are
      mutually exclusive and therefore only one is true in any given state.

      These guarantee that the answer set do not contain complementary facts,
      and therefore guarantee that the answer set is consistent.

    \end{vproof}

    As only consistent domain descriptions can be evaluated in terms of user
    queries, Theorem \ref{the-cons} may be used to check whether a domain
    description is consistent.

    \begin{vdefinition}
      \label{def-eval}
      Given a {\em consistent} domain description ${\cal D}_{\cal L}$, a ground
      query expression $\phi$ and a finite sequence list $\psi$, we say
      {\em query $\phi$ holds in ${\cal D}_{\cal L}$ after the policy updates
      in sequence list $\psi$ have been applied}, denoted as

      \begin{vquote}
        ${\cal D}_{\cal L}$ $\models$ \{$\phi$, $\psi$\},
      \end{vquote}

      \noindent if and only if for every atom [$\lnot$]$\alpha$ in $\phi$,
      where $\alpha$ $\in$ ${\cal A}^{|\psi|}$, [$\lnot$]$\alpha$ is in
      every answer set of $Trans$(${\cal D}_{\cal L}$).
    \end{vdefinition}

    Definition \ref{def-eval} shows that given a finite list of policy updates
    $\psi$, a query expression $\phi$ may be evaluated from a consistent
    language ${\cal L}$ domain ${\cal D_{L}}$. This is achieved by generating a
    set of answer sets from the normal logic program translation
    $Trans$(${\cal D_{L}}$). $\phi$ is then said to hold in ${\cal D_{L}}$
    after the policy updates in $\psi$ have been applied if and only if every
    answer set generated contains every fact in the query expression $\phi$.

    \begin{vexample}
      \label{ex-3}
      Given the language ${\cal L}$ code listing in Example \ref{ex-1} and its
      semantic translation in Example \ref{ex-2}, where the update sequence
      list $\psi$ = \{$delete\_read$($grp1$, $file$)\}. The following shows the
      results of each query $\phi$:

      \begin{vquote}
        \begin{math}
          \begin{aligned}[t]
            &\phi_{0} = holds(grp1, write, file) : TRUE \\
            &\phi_{1} = holds(grp1, read, file) : FALSE \\
            &\phi_{2} = holds(alice, write, file) : TRUE \\
            &\phi_{3} = holds(alice, read, file) : FALSE
          \end{aligned}
        \end{math}
      \end{vquote}
    \end{vexample}

  \section{Implementation}
    \label{sec-implement}

    As mentioned earlier, {\em PolicyUpdater} is a fully implemented system.
    In this section, we describe the implementation details of this system.
    Details of the application and the core system program may be found in
    the project homepage at:

    \begin{vquote}
      {\tt\scriptsize http://www.cit.uws.edu.au/\~{}jcrescin/projects/} \\
      {\tt\scriptsize PolicyUpdater/index.html}
    \end{vquote}

    \subsection{System Structure}

    \begin{figure}[ht]
      \begin{center}
        \includegraphics{figure-01}
        \caption{Structure of PolicyUpdater}
        \label{fig-1}
      \end{center}
    \end{figure}

      As shown in Figure \ref{fig-1}, the PolicyUpdater system works in
      conjunction with an authorisation agent program that queries the
      policy base to determine whether to allow users access to resources.
      Through an authorisation agent program, the PolicyUpdater system also
      allows administrators to dynamically update the policy base by adding
      or removing update directives in the policy update table.

      \subsubsection{Parsers}

        \paragraph{Policy Parser.}

          The policy parser is responsible for correctly reading the policy
          file into the core PolicyUpdater system. The parser ensures that
          the policy file strictly adheres to the language $\cal{L}$ syntax
          then systematically stores entity identifiers into the symbol table
          and initial state facts, constraint expressions and policy update
          definitions are stored into their respective tables in the policy
          base.

        \paragraph{Agent Parser.}

          The agent parser is the direct link between the core PolicyUpdater
          system and the authorisation agent program. The parser's sole purpose
          is to receive language $\cal{L}$ directives from an agent, perform
          the directive upon the policy base and return a reply if the
          directive requires one. Such directives may be to query the policy
          base or to manipulate the policy update sequence table.

      \subsubsection{Data Structures}

        As language ${\cal L}$ program is parsed, each statement containing
        entity declarations, initial facts, constraint rules and policy
        updates must first be stored into a structure before the translation
        process is started. As shown in Appendix \ref{app-store}, the structure
        is composed of the symbol table, the policy base and the policy update
        sequence table.

        The symbol table is used to store all entity identifiers defined in the
        policy, while the rest of the policy definitions are stored into the
        policy base. On the other hand, the sequence of policy update
        directives are stored separately into the update table.

    \subsection{System Processes}

      The processes presented in this section shows how the language
      ${\cal L}$ policy stored in the data structures is translated into a
      normal logic program and how it can be dynamically updated and
      manipulated to evaluate queries. The flowchart in Figure \ref{fig-2}
      gives an overview of the system processes.

      \begin{figure}[ht]
        \begin{center}
          \includegraphics{figure-02}
          \caption{System Flowchart}
          \label{fig-2}
        \end{center}
      \end{figure}

      \subsubsection{Grounding Constraint Variables}

        While the constraint statements are in the process of being added into
        the constraints table, each variable identifier that occurs within each
        constraint is grounded by replacing that constraint with a set of
        constraints wherein each instance of the variable is replaced by all
        entity identifiers defined in the symbol table. Note that only those
        entity identifiers that are valid for each fact in the current
        constraint are used to replace the variable (e.g. only singular
        subject entity identifiers are used to replace an element variable
        occurring in a subject member fact).

        For example, given that the symbol table contains three singular
        subject entity identifiers: $alice$, $bob$ and $charlie$, and the
        following constraint:

        \begin{vverbatim}
  always holds(SSUB, write, file)
    implied by
      holds(SSUB, read, file) &&
      memb(SSUB, students)
    with absence
      !holds(SSUB, write, file);
        \end{vverbatim}

        Grounding the constraint statement above will yield three new
        constraint rules, each replacing occurrences of the variable $SSUB$
        with $alice$, $bob$ and $charlie$, respectively.

      \subsubsection{Policy Updates}

        In Section \ref{subsec-semantics}, it is shown that policy updates are
        performed by treating each update as a constraint. This constraint is
        composed of a premise, which are the preconditions in the current state
        and a consequent, which is the postcondition of the resulting state
        after the application of the policy update. The resulting state in this
        procedure represents the updated policy.

        The most crucial step in performing a policy update is the translation
        of the policy updates into normal logic program constraints. This step
        involves identifying which policy updates are to be applied from the
        update sequence table and then composing the required constraint from
        the update definition the policy base. Once the policy update
        constraints are composed, they are then treated as any other
        constraint rules and are translated with the rest of the policy into
        a normal logic program.

      \subsubsection{Translation to Normal Logic Program}

        The semantics of language ${\cal L}$ shows that any consistent language
        ${\cal L}$ program can be translated into an equivalent extended logic
        program then translated again into an equivalent normal logic program.
        However, the implementation of such translations can be greatly
        simplified by translating language ${\cal L}$ programs directly into
        normal logic programs.

        \paragraph{Removal of Classical Negation.}

          In order to remove classical negation from facts of language
          ${\cal L}$, each classically negated fact $\lnot$$f$ is replaced by
          a new and unique positive fact $f'$ that represents the negation of
          fact $f$. To preserve the consistency of the policy base for all
          facts $f$ in the domain, the following constraint rule must be added:

          \begin{vquote}
            $FALSE$ $\leftarrow$ $f$, $f'$
          \end{vquote}

          The removal process involves adding a boolean parameter to each fact
          to indicate whether the fact is classically negated or not. For
          example, given the fact:

          \begin{vquote}
            $\lnot$ $holds$($alice$, $exec$, $file$)
          \end{vquote}

          To remove classical negation, it is replaced by:

          \begin{vquote}
            $holds$($alice$, $exec$, $file$, $false$)
          \end{vquote}

          For consistency, the following constraint is added:

          \begin{vquote}
            \begin{math}
              \begin{aligned}[t]
                FALSE & \leftarrow \\
                & holds(alice, exec, file, true), \\
                & holds(alice, exec, file, false)
              \end{aligned}
            \end{math}
          \end{vquote}

        \paragraph{Representing Facts in Propositional Form.}

          A fact expressed in normal logic program form is composed of the
          atom relation, the state in which it holds and a boolean flag to
          indicate classical negation. For notational simplicity, this tuple
          may be represented by a unique positive integer $i$, where $0$ $\leq$
          $i$ $<$ $n$ ($n$ is the total number of possible facts in the
          domain). The process of translating facts of language ${\cal L}$
          into normal logic program form is achieved by performing the
          following steps:

          \begin{itemize}

            \item
              {\em Enumerate all possible atoms.}
              By using all the entities in the symbol table, all possible
              language ${\cal L}$ atoms may be enumerated by grouping together
              2 to 3 entities together. All possible atoms of type $holds$ are
              generated by enumerating all possible combinations of subject,
              access right and object entities. The set of $member$ atoms is
              generated from all the different combinations of singular and
              group entities of types subject, access right and object.
              Similarly, the set of $subset$ atoms is derived from different
              subject, access right and object group pair combinations.

            \item
              {\em Arrange the atoms in a predefined order.}
              This procedure relies on the assumption that the list of all
              possible atoms derived from the step above is arranged in a
              predefined order. In this step we ensure that the atoms are
              enumerated in the following order: $holds$, $subject$ $member$,
              $access$ $right$ $member$, $object$ $member$, $subject$
              $subset$, $access$ $right$ $subset$ and $object$ $subset$. In
              addition to the ordering of atom types, atoms of each type are
              themselves sorted according to the order in which their entities
              appear in the symbol table.

            \item
              {\em Assign an ordinal index for each enumerated atom.}
              Since the enumerated list of atoms are ordered, consecutive
              positive integers may be assigned to each atom as an ordinal
              index $i$, where $0$ $\leq$ $i$ $<$ $n$ ($n$ is the total
              number of atoms enumerated).

            \item
              {\em Extend indexing procedure to represent facts.} Since
              negative facts are just mirror images of their positive
              counterparts, their indices are calculated by adding $n$ to the
              indices of the corresponding positive facts. Thus, indices $i$
              ($n$ $\leq$ $i$ $<$ $2n$) are negative facts. Furthermore, this
              procedure is again extended to represent the states of the
              facts. The process is similar: indices $i$ ($0$ $\leq$ $i$ $<$
              $2n$) represent facts of state $S_{0}$, indices $i$ ($2n$ $\leq$
              $i$ $<$ $4n$) represent facts of state $S_{1}$, and so on.
          \end{itemize}

          The steps outlined above may be summarised by the function below:

          \begin{vquote}
            $index$ = $encode$($ent1$, $ent2$, $ent3$, $state$, $truth$)
          \end{vquote}

        \paragraph{Generating the Normal Logic Program from the Policy Base.}

          With the language ${\cal L}$ policy elements stored into the storage
          structure (see Appendix \ref{app-store}), a normal logic program can
          then be generated for evaluation. Using the translation methods
          described in Section \ref{subsec-semantics} and the method for
          eliminating classical negation, each initial state expression,
          constraint rule and policy update becomes a set of simple logical
          rules. By applying the $encode$ function above for each fact in each
          of these rules, a normal logic program is generated.

      \subsubsection{Query Evaluation}

        Once a normal logic program has been generated from the policy stored
        in the storage structure, a set of answer sets may then be generated
        by using the stable model semantics \cite{SIM} with the
        {\em smodels}\footnotemark program. Query evaluation then becomes
        possible by checking whether each fact of a given query holds in each
        generated answer set of the normal logic program.

        \footnotetext{
          Smodels ({\tt \scriptsize http://www.tcs.hut.fi/Software/smodels})
        }

        If a given fact indeed holds in all the answer sets, it is then
        evaluated to be true. On the other hand, if the negation of a fact
        holds in every answer set, then it is evaluated to be false. A fact
        or its negation that does not hold in every answer set is neither true
        nor false.

  \section{Case Study: Web Server Application}
    \label{sec-case}

    \begin{figure}[ht]
      \begin{center}
        \includegraphics{figure-03}
        \caption{PolicyUpdater module for Apache}
        \label{fig-3}
      \end{center}
    \end{figure}

    The expressiveness of language $\cal{L}$ and the effectiveness of the
    PolicyUpdater system can be demonstrated by a web server authorisation
    application. In this application, the core PolicyUpdater system serves as
    an authorisation module for the {\em Apache}\footnotemark web server.

    \footnotetext{Apache Web Server ({\tt \scriptsize http://www.apache.org})}

    The Apache web server provides a generic access control system as provided
    by its {\em mod\_auth} and {\em mod\_access} modules \cite{AP,LAU}. With
    this built-in access control system, Apache provides the standard HTTP
    {\em Basic} and {\em Digest} authentication schemes \cite{HTTP2}, as well
    as an authorisation system to enforce access control policies. Although the
    PolicyUpdater module do not provide the full functionality of Apache's
    built-in authorisation module {\em mod\_auth}, it does provide a flexible
    logic-based authorisation mechanism.

    As shown in Figure \ref{fig-3}, Apache's Access Control module, together
    with its policy base, is replaced by the PolicyUpdater module and its own
    policy base. The sole purpose of the PolicyUpdater module is to act as an
    interface between the web server and the core PolicyUpdater system. The
    system works as follows: as the server is started, the PolicyUpdater
    module initialises the core PolicyUpdater system by sending the policy
    base. When a client makes an arbitrary HTTP request for a resource from
    the server (1), the client (user) is authenticated against the password
    table by the built-in authentication module; once the client is properly
    authenticated (2) the request is transferred to the PolicyUpdater module,
    which in turn generates a language ${\cal L}$ query (3) from the request
    details, then sends the query to the core PolicyUpdater system for
    evaluation; if the query is successful and access control is granted,
    the original request is sent to the other request handlers of the web
    server (4) where the request is eventually honoured; then finally (5),
    the resource (or acknowledgement for HTTP requests other than GET) is sent
    back to the client. Optionally, client can be an administrator who,
    after being authenticated, is presented with a special administrator
    interface by the module to allow the policy base to be updated.

    \subsection{Policy Description in Language ${\cal L'}$}

      The policy description in the policy base is written in language
      ${\cal L'}$, which is syntactically and semantically similar to
      language ${\cal L}$ except for the lack of entity identifier
      definitions. Entity identifiers need not be explicitly defined in
      the policy definition:

      \begin{itemize}
        \item
          {\em Subjects} of the access control policies are the users. Since
          all users must first be authenticated, the password table used
          in authentication may also be used to extract the list of subjects.
        \item
          {\em Access Rights} are built in: they are the HTTP request methods
          as defined by the HTTP 1.1 standard \cite{HTTP1} (i.e. OPTIONS, GET,
          HEAD, POST, PUT, DELETE, TRACE and CONNECT).
        \item
          {\em Objects} are the resources available in the server themselves.
          Assuming that the document root is a hierarchy of directories and
          files, each of these are mapped as a unique object of language
          ${\cal L'}$.
      \end{itemize}

      Like language ${\cal L}$, language ${\cal L'}$ allows the definition of
      initial state facts, constraint rules and policy update definitions.

    \subsection{Mapping the Policies to Language ${\cal L}$}

      As mentioned above, one task of the PolicyUpdater module is to generate
      a language ${\cal L}$ policy from the given language ${\cal L'}$ to be
      evaluated by the core PolicyUpdater system. This process is outlined
      below:

      \begin{itemize}
        \item
          {\em Generating entity identifier definitions.} Subject entities are
          taken from the authentication (password) table; access rights are
          hard-coded built-ins; and the list of objects are generated by
          traversing the document root for files and directories.
        \item
          {\em Generating additional constraints.} Additional constraints are
          generated to preserve the relationship between groups and elements.
          This is useful to model the assertion that unless explicitly stated,
          users holding particular access rights to a directory automatically
          hold those access rights to every file in that directory
          (recursively, if with subdirectories). The module makes this
          assertion by generating non-conditional constraint rules that state
          that each file (object) is a member of the directory (object group)
          in which it is contained.
      \end{itemize}

      All other language ${\cal L'}$ statements (initial state definitions,
      constraint definitions and policy update definitions) are already in
      language ${\cal L}$ form.

    \subsection{Evaluation of HTTP Requests}

      A HTTP request may be represented as a simplified tuple:

      \begin{quote}
        $<$$usr$, $req\_meth$, $req\_res$$>$
      \end{quote}

      $usr$ is the authenticated username that made the request (subject);
      $req\_meth$ is a standard HTTP request method (access right); and
      $req\_res$ is the resource associated with the request (object).
      Intuitively, such a tuple may be expressed as a language ${\cal L}$ atom:

      \begin{vverbatim}
  holds(usr, req\_meth, req\_res)
      \end{vverbatim}

      With each request expressed as language ${\cal L}$ atoms, a language
      ${\cal L}$ query statement can be composed to check if the request is
      to be honoured:

      \begin{vverbatim}
  query
    holds(usr, req\_meth, req\_res);
      \end{vverbatim}

      Once the query statement is composed, it is then sent by the
      PolicyUpdater module to the core PolicyUpdater system for evaluation
      against the policy base.

    \subsection{Policy Updates by Administrators}

      After being properly authenticated, an administrator can perform policy
      updates through the use of a special interface generated by the
      PolicyUpdater module. This interface lists all the predefined policy
      updates that are allowed, as defined in the policy description in
      language ${\cal L'}$, as well as all the policy updates that have been
      previously applied and are in effect. As with the core PolicyUpdater
      system, administrators are allowed only the following operations:

      \begin{itemize}
        \item
          Apply a policy update or a sequence of policy updates to the policy
          base. Note that like language ${\cal L}$, in language ${\cal L'}$
          policy updates are predefined within the policy base themselves.
        \item
          Revert to a previous state of the policy base by removing a
          previously applied policy update from the policy base.
      \end{itemize}

  \section{Conclusion}
    \label{sec-conclusion}

    In this paper, we have presented the PolicyUpdater system, a logic-based
    authorisation system that features query evaluation and dynamic policy
    updates. This is made possible by the use of a first-order logic
    authorisation language, language ${\cal L}$, for the definition, updating
    and querying of access control policies. As we have shown, language
    ${\cal L}$ is expressive enough to represent constraints and default rules.

    The case study in Section \ref{sec-case} demonstrates how the PolicyUpdater
    system can be adapted to be used in a real-world web server authorisation
    application. As mentioned earlier, while other logic based access control
    approaches have been proposed recently, most of these cannot deal with
    dynamic policy updates. Furthermore, most of these approaches rarely
    address implementation issues. To the best of our knowledge, the
    PolicyUpdater system is the first fully implemented logic based access
    control system with a comprehensive web server security application.

    One possible future extension to this work is the integration of temporal
    logic to language ${\cal L}$ to allow time properties to be expressed in
    access control policies. Such extension will be useful in access control
    systems such as e-commerce applications where authorisations are granted
    or denied based on policies that are time dependent.

  \appendix

  \vappsection{Storage Structures}

    \label{app-store}

    The data structures outlined in this section are used as a storage
    structure to hold the elements of language ${\cal L}$ before any
    operations are performed.

    Each of the tables and lists used in the system inherits from a generic
    ordered and indexed list implementation. Each node in this list holds a
    generic data type that can be used to store strings, an arbitrary data
    type or another list type.

    \subsection{Symbol Table}

      The symbol table is used to store the identifier entities defined in
      the entity identifier declaration section of language ${\cal L}$
      programs. The symbol table is composed of 6 separate string lists:

      \begin{vquote}
        \begin{tabular}[t]{|l|l|l|}
          \hline
          \textbf{Field} & \textbf{Type} & \textbf{Description} \\
          \hline
          $ss$ & string list & single subject \\
          \hline
          $sg$ & string list & group subject \\
          \hline
          $as$ & string list & single access right \\
          \hline
          $ag$ & string list & group access right \\
          \hline
          $os$ & string list & single object \\
          \hline
          $og$ & string list & group object \\
          \hline
        \end{tabular}
      \end{vquote}

      Each entity identifier are sorted in the above lists according to
      their type, and ordered according to the order in which they are
      declared in the program. Each list is indexed by consecutive
      positive integers starting from zero.

    \subsection{Policy Base}

      When a language ${\cal L}$ program is parsed, each of the facts,
      rules and policy updates must first be stored into the policy base.
      The policy base is composed of 4 tables to store the following:
      initial state facts, constraint rules, policy update definitions and
      the policy update sequence.

      \subsubsection{Atoms.}

        The three types of atoms (subject, access right and object) are
        represented as structures of 2 to 3 strings, with each string
        matching an entity identifier in the symbol table.

        \begin{vquote}
          \begin{tabular}[t]{|l|l|l|l|}
            \hline
            \textbf{Field} & \textbf{Type} & \textbf{Description} & \\
            \hline
            $sub$ & string & subject entity & {\multirow{3}{*}{hol}} \\
            \cline{1-3}
            $acc$ & string & access right entity & \\
            \cline{1-3}
            $obj$ & string & object entity & \\
            \hline
            \hline
            $elt$ & string & single entity & {\multirow{2}{*}{mem}} \\
            \cline{1-3}
            $grp$ & string & group entity & \\
            \hline
            \hline
            $grp1$ & string & subgroup entity & {\multirow{2}{*}{sub}} \\
            \cline{1-3}
            $grp2$ & string & supergroup entity & \\
            \hline
          \end{tabular}
        \end{vquote}

      \subsubsection{Facts.}

        Facts are stored in a three-element structure composed of the
        following: polymorphic type which can be any of the three atom
        structures above; a type indicator to specify whether the fact is
        $holds$, $member$ or $subset$; and a truth flag, to indicate whether the
        atom is classically negated or not ($true$ if the fact holds
        and $false$ if the classical negation of the fact holds).

        \begin{vquote}
          \begin{tabular}[t]{|l|l|l|}
            \hline
            \textbf{Field} & \textbf{Type} & \textbf{Description} \\
            \hline
            $atom$ & atom type & polymorphic structure \\
            \hline
            $type$ & \{h$|$m$|$s\} & holds, member or subset \\
            \hline
            $truth$ & boolean & negation indicator \\
            \hline
          \end{tabular}
        \end{vquote}

      \subsubsection{Expressions.}

        Since expressions are simply conjunctions of facts, they are
        represented as a list of fact structures.

      \subsubsection{Initial State Facts Table.}

        The initial state facts table is represented as a single list of
        fact structures, or an expression. Each fact in all {\em initially}
        statements are added into the initial state facts table.

      \subsubsection{Constraint Table.}

        The constraint table is represented as a list of constraint
        structures, with each structure composed of the following:

        \begin{vquote}
          \begin{tabular}[t]{|l|l|l|}
            \hline
            \textbf{Field} & \textbf{Type} & \textbf{Description} \\
            \hline
            $exp$ & expression type & consequent \\
            \hline
            $pcond$ & expression type & positive premise \\
            \hline
            $ncond$ & expression type & negative premise \\
            \hline
          \end{tabular}
        \end{vquote}

      \subsubsection{Policy Update Definition Table.}

        Another list of structures is the policy update table. Each element
        structure of this table is composed of the following 4 fields:

        \begin{vquote}
          \begin{tabular}[t]{|l|l|l|}
            \hline
            \textbf{Field} & \textbf{Type} & \textbf{Description} \\
            \hline
            $name$ & string & update identifier \\
            \hline
            $vlist$ & ordered string list & variables \\
            \hline
            $pre$ & expression type & precondition \\
            \hline
            $post$ & expression type & postcondition \\
            \hline
          \end{tabular}
        \end{vquote}

    \subsection{Policy Update Sequence Table}

      The policy update sequence table is an ordered list of sequence
      structures, each with the following elements:

      \begin{vquote}
        \begin{tabular}[t]{|l|l|l|}
          \hline
          \textbf{Field} & \textbf{Type} & \textbf{Description} \\
          \hline
          $name$ & string & update identifier \\
          \hline
          $ilist$ & ordered string list & identifiers \\
          \hline
        \end{tabular}
      \end{vquote}

  \begin{thebibliography}{5}
    \bibitem{AP}
      Apache Software Foundation,
      Authentication, Authorization and Access Control.
      {\em Apache HTTP Server 2.1 Documentation},
      {\tt \scriptsize http://httpd.apache.org/docs-2.1/}, 2004.

    \bibitem{BA1}
      Bai, Y., Varadharajan, V.,
      On Formal Languages for Sequences of Authorization Transformations.
      In {\em Proceedings of Safety, Reliability and Security of Computer
      Systems}. Also in {\em Lecture Notes in Computer Science},
      Vol. 1698, pp. 375-384. Springer-Verlag, 1999.

    \bibitem{BA2}
      Bai, Y., Varadharajan, V.,
      On Transformation of Authorization Policies.
      In {\em Data and Knowledge Engineering},
      Vol. 45, No. 3, pp. 333-357, 2003.

    \bibitem{BAR}
      Baral, C.,
      {\em Knowledge, Representation, Reasoning and Declarative Problem
      Solving}.
      pp. 99-100, Cambridge University Press, UK, 2003.

    \bibitem{BE1}
      Bertino, E., Buccafurri, F., Ferrari, E., Rullo, P.,
      A Logic-based Approach for Enforcing Access Control.
      {\em Journal of Computer Security},
      Vol. 8, No. 2-3, pp. 109-140, IOS Press, 2000.

    \bibitem{BE2}
      Bertino, E., Mileo, A., Provetti, A.
      Policy Monitoring with User-Preferences in PDL.
      In {\em Proceedings of IJCAI-03 Workshop for Nonmonotonic Reasoning,
      Action and Change},
      pp. 37-44, 2003.

    \bibitem{CHO}
      Chomicki, J., Lobo, J., Naqvi, S.,
      A Logic Programming Approach to Conflict Resolution in Policy Management.
      In {\em Proceedings of KR2000, 7th International Conference on Principles
      of Knowledge Representation and Reasoning},
      pp. 121-132, Kaufmann, 2000.

    \bibitem{CR1}
      Crescini, V. F., Zhang, Y.,
      A Logic Based Approach for Dynamic Access Control.
      In {\em Proceedings of the 17th Australian Joint Conference on Artificial
      Intelligence},
      2004. (to be published)

    \bibitem{CR2}
      Crescini, V. F., Zhang, Y., Wang, W.,
      Web Server Authorisation with the PolicyUpdater Access Control System.
      In {\em Proceedings of the 2004 IADIS WWW/Internet Conference},
      2004. (to be published)

    \bibitem{GEL}
      Gelfond, M., Lifschitz, V.,
      The Stable Model Semantics for Logic Programming.
      In {\em Proceedings of the 5th Joint International Conference and
      Symposium},
      pp. 1070-1080, MIT Press, 1998.

    \bibitem{HAL}
      Halpern, J. Y., Weissman, V.,
      Using First-Order Logic to Reason About Policies.
      In {\em Proceedings of the 16th IEEE Computer Security Foundations
      Workshop}, pp. 187-201, 2003.

    \bibitem{JAJ}
      Jajodia, S., Samarati, P., Sapino, M. L., Subrahmanian, V. S.,
      Flexible Support for Multiple Access Control Policies.
      {\em ACM Transactions on Database Systems},
      Vol. 29, No. 2, pp. 214-260, ACM, 2001.

    \bibitem{LAU}
      Laurie, B., Laurie, P.,
      {\em Apache: The Definitive Guide} (3rd Edition).
      O'Reilly \& Associates Inc., 2003.

    \bibitem{LI}
      Li, N., Grosof, B. N., Feigenbaum, J.,
      Delegation Logic: A Logic-based Approach to Distributed Authorization.
      {\em ACM Transactions on Information and System Security (TISSEC)},
      Vol. 6, No. 1, pp. 128-171, 2003.

    \bibitem{LOB}
      Lobo, J., Bhatia, R., Naqvi, S.,
      A Policy Description Language.
      In {\em Proceedings of AAAI 16th National Conference on Artificial
      Intelligence and 11th Conference on Innovative Applications of Artificial
      Intelligence }, pp. 291-298, AAAI Press, 1999.

    \bibitem{HTTP1}
      Network Working Group,
      {\em HTTP 1.1 (RFC 2616)}.
      The Internet Society,
      {\tt \scriptsize ftp://ftp.isi.edu/in-notes/rfc2616.txt},
      1999.

    \bibitem{HTTP2}
      Network Working Group,
      {\em HTTP Authentication (RFC 2617)}.
      The Internet Society,
      {\tt \scriptsize ftp://ftp.isi.edu/in-notes/rfc2617.txt},
      1999.

    \bibitem{SIM}
      Simons., P.,
      Efficient Implementation of the Stable Model Semantics for Normal Logic
      Programs.
      {\em Research Reports, Helsinki University of Technology},
      No. 35, 1995.
  \end{thebibliography}
\end{document}
