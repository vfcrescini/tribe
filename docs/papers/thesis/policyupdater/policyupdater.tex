\documentclass[11pt]{report}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{alltt}
\usepackage{float}
\usepackage{calc}

% a variable margin environment
\newenvironment{vvarmargin}[2]
{
  \begin{list}{}
  {
    \setlength{\topsep}{0pt}
    \setlength{\leftmargin}{0pt}
    \setlength{\rightmargin}{0pt}
    \setlength{\listparindent}{\parindent}
    \setlength{\itemindent}{\parindent}
    \setlength{\parsep}{0pt plus 1pt}
    \addtolength{\leftmargin}{#1}\addtolength{\rightmargin}{#2}
  }
  \item
}
{
  \end{list}
}

% definition environment
\newtheorem{vdefinition}{Definition}[chapter]

% theorem environment
\newtheorem{vvtheorem}{Theorem}[chapter]
\newenvironment{vtheorem}[1]
{
  \begin{vvtheorem}{{\bf (#1)}}
}
{
  \end{vvtheorem}
}

% proof environment
\newenvironment{vproof}
{
  \noindent
  {\em Proof}\hspace{0.5em}
}
{

  \noindent
  \rule{0.5em}{0.5em}
}

% example environment
\newtheorem{vexample}{Example}[chapter]

% verbatim environment
\newenvironment{vverbatim}
{
  \begin{alltt}
}
{
    \vspace{-\baselineskip}
  \end{alltt}
}

% algorithm environment
\floatstyle{plain}
\floatname{valgorithmfloat}{Algorithm}
\newfloat{valgorithmfloat}{tbph}{alg}[chapter]
\newsavebox{\valgorithmbox}
\newlength{\valgorithmboxwidth}

\newenvironment{valgorithm}[3][tbhp]
{
  \setlength{\valgorithmboxwidth}{\linewidth-2em}

  \begin{valgorithmfloat}[#1]
    \caption{#2}
    \label{#3}
    \hspace{1em}
    \begin{lrbox}{\valgorithmbox}
      \begin{minipage}[l]{\valgorithmboxwidth}
        \small
        \begin{vverbatim}
}
{
        \end{vverbatim}
      \end{minipage}
    \end{lrbox}
    \framebox[\valgorithmboxwidth][l]{\usebox{\valgorithmbox}}
  \end{valgorithmfloat}
}

% create a quote environment without a right-hand margin
\newenvironment{vquote}
{
  \begin{list}{}{\leftmargin 1em}\item[]
}
{
  \end{list}
}

\begin{document}
  \onehalfspacing

  \tableofcontents

  \chapter{Introduction}

  \chapter{Logic-Based Authorisation Language}

    \section{Language $\cal{L}$}
      \label{sec-langl}

      Language $\cal{L}$ is a first-order logic language that represents a
      policy base for an authorisation system. Two key features of the
      language are: (1) providing a means to conditionally and dynamically
      update the existing policy base and (2) having a mechanism by which
      queries may be evaluated from the updated policy base.

      \subsection{Syntax}
        \label{subsect-langl-syntax}

        Logic programs of language ${\cal L}$ are composed of language
        statements, each terminated by a semicolon ";" character. C-style
        comments delimited by the "/*" and "*/" characters may appear anywhere
        in the logic program.
   
        \subsubsection{Components of Language $\cal{L}$}

          Each language ${\cal L}$ statement is composed of the following
          components: identifiers, atoms, facts and expressions.
   
          \begin{itemize}
            \item
              {\bf Identifiers}

              The most basic unit of language $\cal{L}$ is the identifier.
              Identifiers are used to represent the different components of
              the language. They are classified into three main categories:
   
              \begin{enumerate}
                \item
                  {\em Entity Identifiers} are used to represent constant
                  entities that make up a logical atom. They are divided into
                  three types, with each type divided further into the
                  {\em singular} and {\em group} entity sub-types:
   
                  \begin{enumerate}
                    \item
                      {\em Subjects}: e.g. alice, lecturers, user-group.
                    \item
                      {\em Access Rights}: e.g. read, write, own.
                    \item
                      {\em Objects}: e.g. file, database, directory.
                  \end{enumerate}
   
                  An entity identifier is defined as a single, lower-case
                  alphabetic character, followed by 0 or more alphanumeric and
                  underscore characters. The following regular expression
                  shows the syntax of entity identifiers:
   
                  \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
                  \end{vverbatim}
   
                \item
                  {\em Policy Update Identifiers} are used for the sole
                  purpose of naming a policy update. These identifier names
                  are then used as labels to refer to policy update
                  declarations and directives. As labels, identifiers of this
                  class occupy a different namespace from entity identifiers.
                  For this reason, policy update identifiers share the same
                  syntax with entity identifiers:
   
                  \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
                  \end{vverbatim}
   
                \item
                  {\em Variable Identifiers} are used as place-holders for
                  entity identifiers. To distinguish them from entity and
                  policy update identifiers, variable identifiers are prefixed
                  with an upper-case character, followed by 0 or more
                  alphanumeric and underscore characters. The first character
                  of a variable identifier indicates its type ("S" for
                  subject, "A" for access right and "O" for object). If the
                  second character is an "S", then the variable is a
                  place-holder for a singular entity while a "G" indicates
                  that it is a place-holder for a group entity. The following
                  regular expression shows the syntax of variable identifiers:
   
                  \begin{vverbatim}
   [SAO][SG][a-zA-Z0-9\_]
                  \end{vverbatim}
              \end{enumerate}

            \item
              {\bf Atoms}

              An atom is composed of a relation with 2 to 3 entity or
              variable identifiers that represents a logical relationship
              between the entities. There are three types of atoms:

              \begin{enumerate}
                \item
                  {\em Holds.} An atom of this type states that the subject
                  identifier $sub$ holds the access right identifier $acc$
                  for the object identifier $obj$.

                 \begin{vverbatim}
  holds(<sub>, <acc>, <obj>)
                 \end{vverbatim}

                \item
                  {\em Membership.} This type of atom states that the
                  singular identifier $elt$ is a member or element of the
                  group identifier $grp$. It is important to note that
                  identifiers $elt$ and $grp$ must be of the same base type
                  (e.g. singular subject and group subject).

                  \begin{vverbatim}
  memb(<elt>, <grp>)
                  \end{vverbatim}

                \item
                  {\em Subset.} The subset atom states that the group
                  identifiers $grp_0$ and $grp_1$ are of the same types and
                  that group $grp_0$ is a subset of the group $grp_1$.

                  \begin{vverbatim}
  subst(<grp-0>, <grp-1>)
                  \end{vverbatim}

              \end{enumerate}

            \item
              {\bf Facts}

              A fact states that the relationship represented by an atom or
              its negation holds in the current context. Facts are negated by
              the use of the negation operator "!". The following shows the
              formal syntax of a fact:

              \begin{vverbatim}
  [!]<holds-atom>|<memb-atom>|<subst-atom>
              \end{vverbatim}

              Note that facts may be made up of atoms that contain variable
              identifiers. Facts with no variable occurrences are called
              {\em ground facts}.

            \item
              {\bf Expressions}

              An expression is either a fact or a logical conjunction of facts,
              separated by the comma "," character:

              \begin{vverbatim}
  <fact-0> [, <fact-1> [, ...]]
              \end{vverbatim}

              Expressions that are made up of only ground facts are called
              {\em ground expressions}.
          \end{itemize}

        \subsubsection{Declaration Statements}

          These statements are used to declare the different rules that make up
          the policy base.

          \begin{itemize}
            \item
              {\bf Entity Identifier Declarations}

              All entity identifiers (subjects, access rights, objects and
              groups) must first be declared before any other statements to
              define the entity domain of the policy base. The following entity
              declaration syntax illustrates how to define one or more entity
              identifiers of a particular type.

              \begin{vverbatim}
  ident sub|acc|obj[-grp] <entity-id>[, ...];
              \end{vverbatim}

            \item
              {\bf Initial Fact Declarations}

              The initial facts of the policy base, those that hold before any
              policy updates are performed, are declared by using the following
              syntax:

              \begin{vverbatim}
  initially <ground-exp>;
              \end{vverbatim}

            \item
              {\bf Constraint Declarations}

              A constraint statement is a logical rule that holds regardless
              of any changes that may occur when the policy base is updated.
              Constraint rules are true in the initial state and remain true
              after any policy update.

              The constraint syntax below shows that in any state of the policy
              base, expression $exp_0$ holds if expression $exp_1$ is true and
              there is no evidence that $exp_2$ is true. The {\em with absence}
              clause allows constraints to have a default proposition
              behaviour, where the absence of proof that an expression holds
              satisfies the clause condition of the proposition.

              It is important to note that the expressions $exp_0$, $exp_1$ and
              $exp_2$ may be non-ground expressions, which means an identifier
              occurring within these expressions may be a variable.

              \begin{vverbatim}
  always <exp-0>
    [implied by <exp-0>
    [with absence <exp-1>]];
              \end{vverbatim}

            \item
              {\bf Policy Update Declarations}

              Before a policy update can be applied, it must first be declared
              by using the following syntax:

              \begin{vverbatim}
  <update-id>([<var-id>[, ...]])
    causes <exp-0>
    [if <exp-1>];
              \end{vverbatim}

              $upd$-$id$ is the policy update identifier to be used in
              referencing this policy update. The optional parameter
              $var$-$id$ is a list which contains the variable identifiers
              occurring in expressions $exp_0$ and $exp_1$ and will be
              eventually replaced by entity identifiers when the update is
              referenced. The postcondition expression $exp_1$ is an expression
              that will hold in the state after this update is applied.
              The expression $exp_1$ is a precondition expression that must
              hold in the current state before this update is applied.

              Note that a policy update definition will have no effect on the
              policy base until it is applied by the update directive
              described in the following section.

          \end{itemize}

        \subsubsection{Directive Statements}

          These statements are used to issue policy update and query directives
          to the PolicyUpdater system.

          \begin{itemize}

            \item
              {\bf Policy Update Directives}

              The policy update sequence list contains a list of references to
              define policy updates in the domain. The policy updates in the
              sequence list are applied to the current state of the policy
              base one at a time to produce a policy base state against which
              queries can be evaluated.

              The following four directives are used for policy update
              sequence list manipulation.

              \begin{enumerate}
                \item
                  {\em Adding an update into the sequence.}
                  Defined policy updates are added into the sequence list
                  through the use of the following directive:

                  \begin{vverbatim}
  seq add <update-id>([<entity-id>[, ...]]);
                  \end{vverbatim}

                  \noindent where $update$-$id$ is the identifier of a declared
                  policy update and the $entity$-$id$ list is a comma-separated
                  list of entity identifiers that will replace the variable
                  identifiers that occur in the declaration of the policy
                  update.

                \item
                  {\em Listing the updates in the sequence.}
                  The following directive may be used to list the current
                  contents of the policy update sequence list.

                  \begin{vverbatim}
  seq list;
                  \end{vverbatim}

                  This directive is answered with an ordinal list of policy
                  updates in the form

                  \begin{vverbatim}
  <n> <update-id>([<entity-id>[, ...]])
                  \end{vverbatim}

                  \noindent where $n$ is the ordinal index of the policy update
                  in the sequence list starting at 0. $update$-$id$ is the
                  policy update identifier and the $entity$-$id$ list is the
                  comma-separated list of entity identifiers used to replace
                  the variable identifier place-holders.

                \item
                  {\em Removing an update from the sequence.}
                  The syntax below shows the directive used to remove a
                  policy update reference from the list. $n$ is the ordinal
                  index of the policy update to be removed. Note that removing
                  a policy update reference from the sequence list may change
                  the ordinal index of other update references.

                  \begin{vverbatim}
  seq del <n>;
                  \end{vverbatim}

                \item
                  {\em Computing an update sequence.}
                  The policy updates in the sequence list does not get applied
                  until the $compute$ directive is issued. The directive causes
                  the policy update references in the sequence list to be
                  applied one at a time in the same order that they appear in
                  the list. The directive also causes the system to generate
                  the policy base models against which query requests can be
                  evaluated.

                  \begin{vverbatim}
  compute;
                  \end{vverbatim}
              \end{enumerate}

            \item
              {\bf Query Directives}

              A ground query expression may be issued against the current state
              of the policy base. This current state is derived after all the
              updates in the update sequence have been applied, one at a time,
              to the initial state. Query expressions are answered with a
              {\em true}, {\em false} or {\em unknown}, depending on whether
              the queried expression holds, its negation holds, or neither,
              respectively. Syntax is as follows:

              \begin{vverbatim}
  query <ground-exp>;
              \end{vverbatim}

          \end{itemize}

          \begin{vexample}
            \label{ex-2-1}
            The following language ${\cal L}$ program code listing shows a
            simple rule-based document access control system scenario.

            In this example, the subject $alice$ is initially a member of the
            subject group $grp_2$, which is a subset of group $grp_1$. The
            group $grp_1$ also initially holds a $read$ access right for the
            object $file$. The constraint states that if the group $grp_1$ has
            $read$ access for $file$, and no other information is present to
            indicate that $grp_3$ does not have $write$ access for $file$, then
            the group $grp_1$ is granted $write$ access for $file$. For
            simplicity, we only consider one policy update $delete\_read$ and a
            few queries that are evaluated after the policy update is
            performed.

            \begin{vverbatim}
  ident sub alice;
  ident sub-grp grp1, grp2, grp3;
  ident acc read, write;
  ident obj file;

  initially
    memb(alice, grp2),
    holds(grp1, read, file),
    subst(grp2, grp1);

  always holds(grp1, write, file)
    implied by
      holds(grp1, read, file)
    with absence
      !holds(grp3, write, file);

  delete\_read(SG0, OS0)
    causes !holds(SG0, read, OS0);

  seq add delete\_read(grp1, file);

  compute;

  query holds(grp1, write, file);
  query holds(grp1, read, file);
  query holds(alice, write, file);
  query holds(alice, read, file);
            \end{vverbatim}
          \end{vexample}

      \subsection{Semantics}
        \label{subsec-langl-semantics}

        After giving a detailed syntactic definition of language ${\cal L}$,
        we now define its formal semantics.

        The semantics of language ${\cal L}$ is based on the well-known answer
        set (stable model) semantics of extended logic programs proposed by
        Gelfond and Lifschitz \cite{GE}. The definition below formally defines
        the answer set of a logic program.

        \begin{vdefinition}
          \label{def-ans}

          Given an extended logic program $\pi$ composed of ground facts and
          rules that do not have the negation-as-failure operator $not$ and a
          set ${\cal F}$ of all ground facts in $\pi$. A set $\lambda$ is
          then said to be an answer set of $\pi$ if it is the smallest set
          that satisfies the following conditions:

          \begin{enumerate}
            \item
              For any rule of the form $\rho_{0}$ $\leftarrow$ $\rho_{1}$,
              $\hdots$, $\rho_{n}$ where $n$ $\geq$ 1, if $\rho_{1}$, $\hdots$,
              $\rho_{n}$ $\in$ $\lambda$, then
              $\rho_{0}$ $\in$ $\lambda$.

            \item
              If $\lambda$ contains a pair of complementary facts (i.e. a fact
              and its negation), then $\lambda$ = ${\cal F}$.
          \end{enumerate}

          For a ground extended logic program $\pi$ that is composed of rules
          that may have the negation-as-failure operator $not$, a set $\lambda$
          is the answer set of $\pi$ if and only if $\lambda$ is the answer set
          of $\pi'$, where $\pi'$ is obtained from $\pi$ by deleting the
          following:

          \begin{enumerate}
            \item
              Each rule that contains a fact of the form $not$ $\rho$ in its
              body where $\rho$ $\in$ $\lambda$.
            \item
              All facts of the form $not$ $\rho$ in the bodies of the remaining
              rules.
          \end{enumerate}
        \end{vdefinition}

        \subsubsection{Domain Description of Language ${\cal L}$}

          The definition below gives a formal definition of the domain
          description of language ${\cal L}$.

          \begin{vdefinition}
            \label{def-langl-domain}
            The domain description ${\cal D}_{\cal L}$ of language ${\cal L}$
            is defined as a finite set of ground initial state facts,
            constraint rules and policy update definitions.
          \end{vdefinition}

          In addition to the domain description ${\cal D}_{\cal L}$, language
          ${\cal L}$ also includes an additional ordered set: the sequence list
          $\psi$. The sequence list $\psi$ is an ordered set that contains a
          sequence of references to policy update definitions. Each policy
          update reference consists of the policy update identifier and a
          series of zero or more identifier entities to replace the variable
          place-holders in the policy update definitions.

        \subsubsection{Language ${\cal L}^{*}$}

          In language ${\cal L}$, the policy base is subject to change, which
          is triggered by the application of policy updates. Such changes bring
          forth the concept of policy base states. Conceptually, a state may be
          thought of as a set of facts and constraints of the policy base at a
          particular instant. The state transition notation below shows that a
          new state $PB'$ is generated from the current state $PB$ after the
          policy update $u$ is applied.

          \begin{vquote}
            $PB$ $\overrightarrow{_{u}}$ $PB'$
          \end{vquote}

          This concept of a state means that for every policy update applied
          to the policy base, a new instance of the policy base or a new set of
          facts and constraints are generated. To precisely define the
          underlying semantics of domain description ${\cal D}_{\cal L}$ in
          language ${\cal L}$, we introduce language ${\cal L}^{*}$, which is
          an extended logic program representation of language ${\cal L}$, with
          state as an explicit sort.

          Language ${\cal L}^{*}$ contains only one special state constant
          $S_{0}$ to represent the initial state of a given domain description.
          All other states are represented as a resulting state obtained by
          applying the $Res$ function. The $Res$ function takes a policy update
          reference $u$ ($u$ $\in$ $\psi$) and the current state $\sigma$ as
          input arguments and returns the resulting state $\sigma'$ after
          update $u$ has been applied to state $\sigma$:

          \begin{vquote}
            $\sigma'$ $=$ $Res$($u$, $\sigma$)
          \end{vquote}

          \noindent
          Given an initial state $S_{0}$ and a policy update sequence list
          $\psi$, each state $\sigma_{i}$ ($0$ $\leq$ $i$ $\leq$ $|\psi|$)
          may be represented as follows:

          \begin{vquote}
            $\sigma_{0}$ $=$ $S_{0}$

            $\sigma_{1}$ $=$ $Res$($u_{0}$, $\sigma_{0}$)

            $\vdots$

            $\sigma_{|\psi|}$ $=$
              $Res$($u_{|\psi| - 1}$, $\sigma_{|\psi| - 1}$)
          \end{vquote}

          \noindent
          Substituting each state with a recursive call to the $Res$ function,
          the final state $S_{|\psi|}$ is defined as follows:

          \begin{vquote}
            $S_{|\psi|}$ $=$
              $Res$($u_{|\psi| - 1}$, $Res$($\ldots$, $Res$($u_{0}$, $S_{0}$)))
          \end{vquote}

          \paragraph{Entities.}

            The entity set ${\cal E}$ is the union of six disjoint entity sets:
            single subject ${\cal E}_{ss}$, group subject ${\cal E}_{sg}$,
            single access right ${\cal E}_{as}$, group access right
            ${\cal E}_{ag}$, single object ${\cal E}_{os}$ and group object
            ${\cal E}_{og}$. Each entity in set ${\cal E}$ corresponds directly
            to the entity identifiers of language ${\cal L}$.

            \begin{vquote}
              ${\cal E}$ $=$
              ${\cal E}_{s}$ $\cup$ ${\cal E}_{a}$ $\cup$ ${\cal E}_{o}$

              ${\cal E}_{s}$ $=$ ${\cal E}_{ss}$ $\cup$ ${\cal E}_{sg}$

              ${\cal E}_{a}$ $=$ ${\cal E}_{as}$ $\cup$ ${\cal E}_{ag}$

              ${\cal E}_{o}$ $=$ ${\cal E}_{os}$ $\cup$ ${\cal E}_{og}$
            \end{vquote}

          \paragraph{Atoms.}

            The main difference between language ${\cal L}$ and language
            ${\cal L}^{*}$ lies in the definition of an atom. Atoms in language
            ${\cal L}^{*}$ represent a logical relationship of two to three
            entities, as with atoms of language ${\cal L}$. Furthermore, atoms
            of language ${\cal L}^{*}$ extends this definition by defining the
            state of the policy base in which the relationship holds. In this
            paper, atoms of language ${\cal L}^{*}$ are written with the
            hat character ($\hat{holds}$, $\hat{memb}$ and $\hat{subst}$) to
            differentiate from the atoms of language ${\cal L}$. The atom set
            ${\cal A}^{\sigma}$ is the set of all atoms in state $\sigma$.

            \begin{vquote}
              ${\cal A}^{\sigma}$ $=$
                ${\cal A}^{\sigma}_{h}$ $\cup$
                ${\cal A}^{\sigma}_{m}$ $\cup$
                ${\cal A}^{\sigma}_{s}$
    
              ${\cal A}^{\sigma}_{h}$ $=$
                $\{\hat{holds}$($s$, $a$, $o$, $\sigma$) $\mid$
                  $s$ $\in$ ${\cal E}_{s}$,
                  $a$ $\in$ ${\cal E}_{a}$,
                  $o$ $\in$ ${\cal E}_{o}\}$
    
              ${\cal A}^{\sigma}_{m}$ $=$
               ${\cal A}^{\sigma}_{ms}$ $\cup$
               ${\cal A}^{\sigma}_{ma}$ $\cup$
               ${\cal A}^{\sigma}_{mo}$
    
              ${\cal A}^{\sigma}_{s}$ $=$
                ${\cal A}^{\sigma}_{ss}$ $\cup$
                ${\cal A}^{\sigma}_{sa}$ $\cup$
                ${\cal A}^{\sigma}_{so}$
    
              ${\cal A}^{\sigma}_{ms}$ $=$
                $\{\hat{memb}$($e$, $g$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{ss}$,
                  $g$ $\in$ ${\cal E}_{sg}\}$
    
              ${\cal A}^{\sigma}_{ma}$ $=$
                $\{\hat{memb}$($e$, $g$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{as}$,
                  $g$ $\in$ ${\cal E}_{ag}\}$
    
              ${\cal A}^{\sigma}_{mo}$ $=$
                $\{\hat{memb}$($e$, $g$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{os}$,
                  $g$ $\in$ ${\cal E}_{og}\}$
    
              ${\cal A}^{\sigma}_{ss}$ $=$
                $\{\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{sg}\}$
    
              ${\cal A}^{\sigma}_{sa}$ $=$
                $\{\hat{subst}(g_{1}, g_{2}, \sigma)$ $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{ag}\}$
    
              ${\cal A}^{\sigma}_{so}$ $=$
                $\{\hat{subst}(g_{1}, g_{2}, \sigma)$ $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{og}\}$
            \end{vquote}

          \paragraph{Facts.}

            A fact is a logical statement that makes a claim that an atom
            either holds or does not hold at a particular state. The
            following is the formal definition of fact $\hat{\rho}$ in
            state $\sigma$:

            \begin{vquote}
              $\hat{\rho}^{\sigma}$ $=$
                $[\lnot]$$\hat{\alpha}$,
                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$
            \end{vquote}

        \subsubsection{Translating Language ${\cal L}$ to Language ${\cal L^{*}}$}

          Given a domain description ${\cal D_{L}}$ of language ${\cal L}$, we
          translate ${\cal D_{L}}$ into an extended logic program of language
          ${\cal L^{*}}$, as denoted by $Trans$(${\cal D_{L}}$). The semantics
          of ${\cal D_{L}}$ are provided by the answer sets of the extended
          logic program $Trans$(${\cal D_{L}}$). Before we can fully define
          $Trans$(${\cal D}_{\cal L}$), we must first define the following
          functions:

          The $CopyAtom$() function takes two arguments: an atom $\hat{\alpha}$
          of language ${\cal L}^{*}$ at some state $\sigma$ and another state
          $\sigma'$. The function returns an equivalent atom of the same type
          and with the same entities, but in the new state specified.

          \begin{vquote}
            $CopyAtom$($\hat{\alpha}$, $\sigma'$)
            $=$
            \begin{math}
              \begin{cases}
                \mbox{
                  $\hat{holds}$($s$, $a$, $o$, $\sigma'$),
                    if $\hat{\alpha}$ $=$
                      $\hat{holds}$($s$, $a$, $o$, $\sigma$)
                } \\
                \mbox{
                  $\hat{memb}$($e$, $g$, $\sigma'$),
                    if $\hat{\alpha}$ $=$
                      $\hat{memb}$($e$, $g$, $\sigma$)
                } \\
                \mbox{
                  $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma'$),
                    if $\hat{\alpha}$ $=$
                      $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$)
                }
              \end{cases}
            \end{math}
          \end{vquote}

          Another function, $TransAtom$(), takes an atom $\alpha$ of language
          ${\cal L}$ and an arbitrary state $\sigma$ and returns the equivalent
          atom of language ${\cal L}^{*}$.

          \begin{vquote}
            $TransAtom$($\alpha$, $\sigma$)
            $=$
            \begin{math}
              \begin{cases}
                \mbox{
                  $\hat{holds}$($s$, $a$, $o$, $\sigma$),
                    if $\alpha$ $=$ $holds$($s$, $a$, $o$)
                } \\
                \mbox{
                  $\hat{memb}$($e$, $g$, $\sigma$),
                    if $\alpha$ $=$ $memb$($e$, $g$)
                } \\
                \mbox{
                  $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$),
                    if $\alpha$ $=$ $subst$($g_{1}$, $g_{2}$)
                }
              \end{cases}
            \end{math}
          \end{vquote}

          The $TransFact$() function is similar to the $TransAtom$()
          function, but instead of translating an atom, it takes a fact
          from language ${\cal L}$ and a state then returns the equivalent
          fact in language ${\cal L}^{*}$.

          \paragraph{Initial Fact Rules.}

            The process of translating initial fact expressions of language
            ${\cal L}$ to language ${\cal L}^{*}$ rules is a trivial procedure:
            translate each fact that make up the initial fact expression of
            language ${\cal L}$ with its corresponding equivalent initial state
            atom of language ${\cal L}^{*}$. Given the following
            {\em initially} statement in language ${\cal L}$:

            \begin{vverbatim}
  initially \(\rho\sb{0}\), \ldots, \(\rho\sb{n}\);
            \end{vverbatim}

            \noindent
            The language ${\cal L}^{*}$ translation of this statement is shown
            below:

            \begin{vquote}
              $\hat{\rho}_{0}$ $\leftarrow$

              $\vdots$

              $\hat{\rho}_{n}$ $\leftarrow$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\hat{\rho}_{i}$ $=$ $TransFact$($\rho_{i}$, $S_{0}$),

              \hspace{1em}
              $0$ $\leq$ $i$ $\leq$ $n$
            \end{vquote}

            As shown above, the number of initial fact rules generated from the
            translation is the number of facts $n$ in the given language
            ${\cal L}$ initial fact expression. The following code shows a
            more realistic example of language ${\cal L}$ {\em initially}
            statements:

            \begin{vverbatim}
  initially
    holds(admins, read, sys\_data),
    memb(alice, admins);

  initially
    memb(bob, admins);
            \end{vverbatim}

            \noindent
            In language ${\cal L}^{*}$, the above statements are translated to:

            \begin{vquote}
              $\hat{holds}$($admins$, $read$, $sys\_data$, $S_{0}$)
                $\leftarrow$

              $\hat{memb}$($alice$, $admins$, $S_{0}$) $\leftarrow$

              $\hat{memb}$($bob$, $admins$, $S_{0}$) $\leftarrow$
            \end{vquote}

          \paragraph{Constraint Rules.}

            Each constraint rule in language ${\cal L}$ is expressed as a
            series of logical rules in language ${\cal L}^{*}$. Given that all
            variable occurrences have been grounded to entity identifiers, a
            constraint in language ${\cal L}$, with $n_0$, $n_1$, $n_2$ $\geq$
            $0$ may be represented as:

            \begin{vverbatim}
  always \(\rho\sb{0\sb{0}}\), \ldots, \(\rho\sb{0\sb{n\sb{0}}}\)
    implied by \(\rho\sb{1\sb{0}}\), \ldots, \(\rho\sb{1\sb{n\sb{1}}}\)
    with absence \(\rho\sb{2\sb{0}}\), \ldots, \(\rho\sb{2\sb{n\sb{2}}}\);
            \end{vverbatim}

            Each fact in the {\em always} clause of language ${\cal L}$
            corresponds to a new rule, where it is the consequent. Each of
            these new rules will have expression $\rho_{1}$ in the
            {\em implied by} clause as the positive premise and the expression
            $\rho_{2}$ in the {\em with absence} clause as the negative
            premise.

            \begin{vquote}
              $\rho_{0_{0}}$ $\leftarrow$
                $\rho_{1_{0}}$, \ldots, $\rho_{1_{n_1}}$,
                $not$ $\rho_{2_{0}}$, \ldots, $not$ $\rho_{2_{n_2}}$

              $\vdots$

              $\rho_{0_{n_{0}}}$ $\leftarrow$
                $\rho_{1_{0}}$, \ldots, $\rho_{1_{n_1}}$,
                $not$ $\rho_{2_{0}}$, \ldots, $not$ $\rho_{2_{n_2}}$
            \end{vquote}

            Under the definition of constraint rules, each of the rules listed
            above must be made to hold in all states as defined by the sequence
            list $\psi$. This can be accomplished by translating each of the
            above rules to a set of $|\psi|$ rules, one for each state.

            \begin{vquote}
              $\hat{\rho}^{S_{0}}_{0_{0}}$ $\leftarrow$
                $\hat{\rho}^{S_{0}}_{1_{0}}$, \ldots,
                  $\hat{\rho}^{S_{0}}_{1_{n_1}}$,
                $not$ $\hat{\rho}^{S_{0}}_{2_{0}}$, \ldots,
                  $not$ $\hat{\rho}^{S_{0}}_{2_{n_2}}$

              $\vdots$

              $\hat{\rho}^{S_{|\psi|}}_{0_{0}}$ $\leftarrow$
                $\hat{\rho}^{S_{|\psi|}}_{1_{0}}$, \ldots,
                  $\hat{\rho}^{S_{|\psi|}}_{1_{n_1}}$,
                $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{0}}$, \ldots,
                  $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{n_2}}$

              $\vdots$

              $\hat{\rho}^{S_{0}}_{0_{n_0}}$ $\leftarrow$
                $\hat{\rho}^{S_{0}}_{1_{0}}$, \ldots,
                  $\hat{\rho}^{S_{0}}_{1_{n_1}}$,
                $not$ $\hat{\rho}^{S_{0}}_{2_{0}}$, \ldots,
                  $not$ $\hat{\rho}^{S_{0}}_{2_{n_2}}$

              $\vdots$

              $\hat{\rho}^{S_{|\psi|}}_{0_{n_0}}$ $\leftarrow$
                $\hat{\rho}^{S_{|\psi|}}_{1_{0}}$, \ldots,
                  $\hat{\rho}^{S_{|\psi|}}_{1_{n_1}}$,
                $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{0}}$, \ldots,
                  $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{n_2}}$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\hat{\rho}^{\sigma}_{0_i}$ $=$
                $TransFact$($\rho_{0_i}$, $\sigma$), $0$ $\leq$ $i$ $\leq$ $n_0$,

              \hspace{1em}
              $\hat{\rho}^{\sigma}_{1_j}$ $=$
                $TransFact$($\rho_{1_j}$, $\sigma$), $0$ $\leq$ $j$ $\leq$ $n_1$,

              \hspace{1em}
              $\hat{\rho}^{\sigma}_{2_k}$ $=$
                $TransFact$($\rho_{2_k}$, $\sigma$), $0$ $\leq$ $k$ $\leq$ $n_2$,

              \hspace{1em}
              $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
            \end{vquote}

            For a given language ${\cal L}$ constraint rule, the number of
            constraint rules generated in the translation is:

            \begin{quote}
              $n_0$ $|\psi|$
            \end{quote}

            \begin{quote}
              where

              \hspace{1em}
              $n_0$ is the number of facts in the {\em always} clause

              \hspace{1em}
              $|\psi|$ is the number of states
            \end{quote}

            The example below shows how the following language ${\cal L}$ code
            fragment is translated to language ${\cal L}^{*}$:

            \begin{vverbatim}
  always
    holds(alice, read, data),
    holds(alice, write, data)
  implied by
    memb(alice, admin)
  with absence
    !holds(alice, own, data);
            \end{vverbatim}

            \noindent
            Given a policy update reference in the sequence list $\psi$ (i.e.
            $|\psi|$ = $1$), the language ${\cal L}^{*}$ equivalent is as
            follows:

            \begin{vquote}
              $\hat{holds}$($alice$, $read$, $data$, $S_{0}$) $\leftarrow$

              \hspace{1em}
              $\hat{memb}$($alice$, $admin$, $S_{0}$),
              $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{0}$)

              $\hat{holds}$($alice$, $write$, $data$, $S_{0}$) $\leftarrow$

              \hspace{1em}
              $\hat{memb}$($alice$, $admin$, $S_{0}$),
              $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{0}$)
            \end{vquote}

            \begin{vquote}
              $\hat{holds}$($alice$, $read$, $data$, $S_{1}$) $\leftarrow$
 
              \hspace{1em}
              $\hat{memb}$($alice$, $admin$, $S_{1}$),
              $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{1}$)
 
              $\hat{holds}$($alice$, $write$, $data$, $S_{1}$) $\leftarrow$
 
              \hspace{1em}
              $\hat{memb}$($alice$, $admin$, $S_{1}$),
              $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{1}$)
            \end{vquote}

          \paragraph{Policy Update Rules.}
            
            Given that $n_0$, $n_1$ $\geq$ $0$, all occurrences of variable
            place-holders grounded to entity identifiers, a policy update $u$
            in language ${\cal L}$ is in the form:

            \begin{vverbatim}
  \(u\) causes \(\rho\sb{0\sb{0}}\), \ldots, \(\rho\sb{0\sb{n\sb{0}}}\)
  if \(\rho\sb{1\sb{0}}\), \ldots, \(\rho\sb{1\sb{n\sb{1}}}\);
            \end{vverbatim}

            In language ${\cal L}^{*}$, such policy updates may be represented
            as a set of implications, with each fact $\rho_{0}$ in the
            postcondition expression as the consequent and precondition
            expression $\rho_{1}$ as the premise. However, the translation
            process must also take into account that the premise of the
            implication holds in the state before the policy update is applied
            and that the consequent holds in the state after the application.

            \begin{vquote}
              $\hat{\rho}_{0_{0}}$ $\leftarrow$
                $\hat{\rho}_{1_{0}}$, \ldots, $\hat{\rho}_{1_{n_1}}$

              $\vdots$

              $\hat{\rho}_{0_{n_0}}$ $\leftarrow$
                $\hat{\rho}_{1_{0}}$, \ldots, $\hat{\rho}_{1_{n_1}}$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\hat{\rho}_{0_i}$ $=$
                $TransFact$($\rho_{0_i}$, $Res$($u$, $\sigma$)),
                $0$ $\leq$ $i$ $\leq$ $n_0$,

              \hspace{1em}
              $\hat{\rho}_{1_j}$ $=$
                $TransFact$($\rho_{1_j}$, $\sigma$),
                $0$ $\leq$ $j$ $\leq$ $n_1$
            \end{vquote}

            Intuitively, a given langauge ${\cal L}$ policy update definition
            will generate $n_0$ policy update rules in language ${\cal L^{*}}$,
            where $n_0$ is the number of facts in the postcondition expression.
            For example, given the following 2 language ${\cal L}$ policy
            update definitions:

            \begin{vverbatim}
  grant\_read()
    causes holds(alice, read, file)
    if memb(alice, readers);

  grant\_write()
    causes holds(alice, write, file)
    if memb(alice, writers);
            \end{vverbatim}

            Given the update sequence list $\psi$ contains
            \{$grant\_read$, $grant\_write$\}, the above statements are written
            in language ${\cal L}^{*}$ as:

            \begin{vquote}
              $\hat{holds}$($alice$, $read$, $file$, $S_{1}$) $\leftarrow$
              $\hat{memb}$($alice$, $readers$, $S_{0}$)
            \end{vquote}

            \begin{vquote}
              $\hat{holds}$($alice$, $write$, $file$, $S_{2}$) $\leftarrow$
              $\hat{memb}$($alice$, $writers$, $S_{1}$)
            \end{vquote}

          \paragraph{Additional Constraints.}

            In addition to the translations discussed above, there are a few
            other implicit constraint rules implied by language ${\cal L}$
            that need to be explicitly defined in language ${\cal L}^{*}$.

            \begin{enumerate}
              \item
                {\em Inheritance Rules.}
                All properties held by a group is inherited by all the members
                and subsets of that group. This rule is easy to apply for
                subject group entities. However, careful attention must be
                given to access right and object groups. A subject holding an
                access right for an object group implies that the subject also
                holds that access right for all objects in the object group.
                Similarly, a subject holding an access right group for a
                particular object implies that the subject holds all access
                rights contained in the access right group for that object.

                A conflict is encountered when a particular property is to be
                inherited by an entity from a group of which it is a member or
                subset, and the contained entity already holds the negation of
                that property. This conflict is resolved by giving negative
                facts higher precedence over its positive counterpart: by
                allowing member or subset entities to inherit its parent
                group's properties only if the entities do not already hold
                the negation of those properties.

                The following are the inheritance constraint rules to allow the
                properties held by a group to propagate to its members and
                subsets that do not already hold the negation of the
                properties.

                \begin{enumerate}
                  \item
                    Subject Group Membership Inheritance Rules

                    \begin{vquote}
                      $\forall$ ($s_{s}$, $s_{g}$, $a$, $o$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s_{s}$, $a$, $o$, $\sigma$) $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s_{g}$, $a$, $o$, $\sigma$),
                      $\hat{memb}$($s_{s}$, $s_{g}$, $\sigma$),
                      $not$ $\lnot\hat{holds}$($s_{s}$, $a$, $o$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s_{s}$, $a$, $o$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s_{g}$, $a$, $o$, $\sigma$),
                      $\hat{memb}$($s_{s}$, $s_{g}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s_{s}$ $\in$ ${\cal E}_{ss}$,

                      \hspace{1em}
                      $s_{g}$ $\in$ ${\cal E}_{sg}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    Access Right Group Membership Inheritance Rules

                    \begin{vquote}
                      $\forall$ ($s$, $a_{s}$, $a_{g}$, $o$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s$, $a_{s}$, $o$, $\sigma$) $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $a_{g}$, $o$, $\sigma$),
                      $\hat{memb}$($a_{s}$, $a_{g}$, $\sigma$),
                      $not$ $\lnot\hat{holds}$($s$, $a_{s}$, $o$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a_{s}$, $o$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a_{g}$, $o$, $\sigma$),
                      $\hat{memb}$($a_{s}$, $a_{g}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $a_{s}$ $\in$ ${\cal E}_{as}$,

                      \hspace{1em}
                      $a_{g}$ $\in$ ${\cal E}_{ag}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $S_{0}$ ${\leq}$ ${\sigma}$ ${\leq}$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    Object Group Membership Inheritance Rules

                    \begin{vquote}
                      $\forall$ ($s$, $a$, $o_{s}$, $o_{g}$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s$, $a$, $o_{s}$, $\sigma$) $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $a$, $o_{g}$, $\sigma$),
                      $\hat{memb}$($o_{s}$, $o_{g}$, $\sigma$),
                      $not$ $\lnot\hat{holds}$($s$, $a$, $o_{s}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a$, $o_{s}$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a$, $o_{g}$, $\sigma$),
                      $\hat{memb}$($o_{s}$, $o_{g}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $o_{s}$ $\in$ ${\cal E}_{os}$,

                      \hspace{1em}
                      $o_{g}$ $\in$ ${\cal E}_{og}$,

                      \hspace{1em}
                      $S_{0}$ ${\leq}$ ${\sigma}$ ${\leq}$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    Subject Group Subset Inheritance Rules

                    \begin{vquote}
                      $\forall$ ($s_{g1}$, $s_{g2}$, $a$, $o$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s_{g1}$, $a$, $o$, $\sigma$) $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s_{g2}$, $a$, $o$, $\sigma$),
                      $\hat{subst}$($s_{g1}$, $s_{g2}$, $\sigma$),
                      $not$ $\lnot\hat{holds}$($s_{g1}$, $a$, $o$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s_{g1}$, $a$, $o$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s_{g2}$, $a$, $o$, $\sigma$),
                      $\hat{subst}$($s_{g1}$, $s_{g2}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s_{g1}$, $s_{g2}$ $\in$ ${\cal E}_{sg}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $s_{g1}$ $\neq$ $s_{g2}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq S_{|\psi|}$
                    \end{vquote}

                  \item
                    Access Right Group Subset Inheritance Rules

                    \begin{vquote}
                      $\forall$ ($s$, $a_{g1}$, $a_{g2}$, $o$, $\sigma$),
                    \end{vquote}
 
                    \begin{vquote}
                      $\hat{holds}$($s$, $a_{g1}$, $o$, $\sigma$) $\leftarrow$
 
                      \hspace{1em}
                      $\hat{holds}$($s$, $a_{g2}$, $o$, $\sigma$),
                      $\hat{subst}$($a_{g1}$, $a_{g2}$, $\sigma$),
                      $not$ $\lnot$ $\hat{holds}$($s$, $a_{g1}$, $o$, $\sigma$)
                    \end{vquote}
 
                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a_{g1}$, $o$, $\sigma$)
                      $\leftarrow$
 
                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a_{g2}$, $o$, $\sigma$),
                      $\hat{subst}$($a_{g1}$, $a_{g2}$, $\sigma$)
                    \end{vquote}
 
                    \begin{vquote}
                      where
 
                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,
 
                      \hspace{1em}
                      $a_{g1}$, $a_{g2}$ $\in$ ${\cal E}_{ag}$,
 
                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,
 
                      \hspace{1em}
                      $a_{g1}$ $\neq$ $a_{g2}$,
 
                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    Object Group Subset Inheritance Rules

                    \begin{vquote}
                      $\forall$ ($s$, $a$, $o_{g1}$, $o_{g2}$, $\sigma$),
                    \end{vquote}
 
                    \begin{vquote}
                      $\hat{holds}$($s$, $a$, $o_{g1}$, $\sigma$) $\leftarrow$
 
                      \hspace{1em}
                      $\hat{holds}$($s$, $a$, $o_{g2}$, $\sigma$),
                      $\hat{subst}$($o_{g1}$, $o_{g2}$, $\sigma$),
                      $not$ $\lnot\hat{holds}$($s$, $a$, $o_{g1}$, $\sigma$)
                    \end{vquote}
 
                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a$, $o_{g1}$, $\sigma$)
                      $\leftarrow$
 
                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a$, $o_{g2}$, $\sigma$),
                      $\hat{subst}$($o_{g1}$, $o_{g2}$, $\sigma$)
                    \end{vquote}
 
                    \begin{vquote}
                      where
 
                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,
 
                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,
 
                      \hspace{1em}
                      $o_{g1}$, $o_{g2}$ $\in$ ${\cal E}_{og}$,
 
                      \hspace{1em}
                      $o_{g1}$ $\neq$ $o_{g2}$,
 
                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}
                \end{enumerate}

              \item
                {\em Transitivity Rules.}
                Given three distinct groups $g_0$, $g_1$ and $g_2$. If $g_0$ is
                a subset of $g_1$ and $g_1$ is a subset of $g_2$, then $g_0$
                must also be a subset of $g_2$. The following rules ensure that
                the transitive property of subject, access right and object
                groups holds:

                \begin{enumerate}
                  \item
                    Subject Group Transitivity Rules

                    \begin{vquote}
                      $\forall$ ($sg_{0}$, $sg_{1}$, $sg_{2}$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{subst}$($sg_{0}$, $sg_{2}$, $\sigma$) $\leftarrow$
                      $\hat{subst}$($sg_{0}$, $sg_{1}$, $\sigma$),
                      $\hat{subst}$($sg_{1}$, $sg_{2}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $sg_{0}$, $sg_{1}$, $sg_{2}$ $\in$ ${\cal E}_{sg}$,

                      \hspace{1em}
                      $sg_{0}$ $\neq$ $sg_{1}$ $\neq$ $sg_{2}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    Access Right Group Transitivity Rules

                    \begin{vquote}
                      $\forall$ ($ag_{0}$, $ag_{1}$, $ag_{2}$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{subst}$($ag_{0}$, $ag_{2}$, $\sigma$) $\leftarrow$
                      $\hat{subst}$($ag_{0}$, $ag_{1}$, $\sigma$),
                      $\hat{subst}$($ag_{1}$, $ag_{2}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $ag_{0}$, $ag_{1}$, $ag_{2}$ $\in$ ${\cal E}_{ag}$,

                      \hspace{1em}
                      $ag_{0}$ $\neq$ $ag_{1}$ $\neq$ $ag_{2}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    Object Group Transitivity Rules

                    \begin{vquote}
                      $\forall$ ($og_{0}$, $og_{1}$, $og_{2}$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{subst}$($og_{0}$, $og_{2}$, $\sigma$) $\leftarrow$
                      $\hat{subst}$($og_{0}$, $og_{1}$, $\sigma$),
                      $\hat{subst}$($og_{1}$, $og_{2}$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $og_{0}$, $og_{1}$, $og_{2}$ $\in$ ${\cal E}_{og}$,

                      \hspace{1em}
                      $og_{0}$ $\neq$ $og_{1}$ $\neq$ $og_{2}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}
                \end{enumerate}

              \item
                {\em Intertial Rules.}
                Intuitively, all facts in the current state that are not
                affected by a policy update should be carried over to the
                next state after the update. In language ${\cal L}^{*}$,
                this rule must be explicitly defined as a constraint. Formally,
                the inertial rules are expressed as follows:

                \begin{vquote}
                  $\forall$ ($\hat{\alpha}$,$u$) $\exists$$\hat{\alpha}'$,
                \end{vquote}

                \begin{vquote}
                  $\hat{\alpha}'$ $\leftarrow$
                    $\hat{\alpha}$, $not$ $\lnot$ $\hat{\alpha}'$

                  $\lnot$ $\hat{\alpha}'$ $\leftarrow$
                    $\lnot$ $\hat{\alpha}$, $not$ $\hat{\alpha}'$
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$,

                  \hspace{1em}
                  $u$ $\in$ $\psi$,

                  \hspace{1em}
                  $\hat{\alpha}'$ $=$
                  $CopyAtom$($\hat{\alpha}$, $Res$($u$, $\sigma$))
                \end{vquote}

              \item
                {\em Reflexivity Rules.}
                Finally, explicit rules must be given to show that every set is
                a subset of itself.

                \begin{vquote}
                  $\forall$ ($g$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{subst}$($g$, $g$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $g$ $\in$
                    (${\cal E}_{sg}$ $\cup$ ${\cal E}_{ag}$ $\cup$ ${\cal E}_{og}$),

                  \hspace{1em}
                  $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                \end{vquote}
            \end{enumerate}

          \begin{vexample}
            \label{ex-2-2}
            The following shows the language ${\cal L^{*}}$ translation of the
            language ${\cal L}$ program listing shown in Example \ref{ex-2-1}.

            \begin{enumerate}
              \item
                Initial Fact Rules
    
                \begin{vquote}
                  $\hat{memb}(alice, grp2, S_{0}) \leftarrow$
    
                  $\hat{holds}(grp1, read, file,S_{0}) \leftarrow$
    
                  $\hat{subst}(grp2, grp1, S_{0}) \leftarrow$
                \end{vquote}
    
              \item
                Constraint Rules
    
                \begin{vquote}
                  % constraints (S0)
                  $\hat{holds}(grp1, write, file, S_{0})$ $\leftarrow$
    
                  \hspace{1em}
                  $\hat{holds}(grp1, read, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp3, write, file, S_{0})$
                \end{vquote}
    
                \begin{vquote}
                  % constraints (S1)
                  $\hat{holds}(grp1, write, file, S_{1})$ $\leftarrow$
    
                  \hspace{1em}
                  $\hat{holds}(grp1, read, file, S_{1})$,
                  $not$ $\lnot\hat{holds}(grp3, write, file, S_{1})$
                \end{vquote}
    
              \item
                Policy Update Rules
    
                \begin{vquote}
                  $\lnot\hat{holds}(grp1, read, file, S_{1})$ $\leftarrow$
                \end{vquote}
              \item
                Inheritance Rules
               
                \begin{vquote}
                  % inheritance rules (positive, read, S0)
                  $\hat{holds}(alice, read, file, S_{0})$ $\leftarrow$
               
                  \hspace{1em}
                  $\hat{holds}(grp1, read, file, S_{0})$,
                  $\hat{memb}(alice, grp1, S_{0})$,
               
                  \hspace{1em}
                  $not$ $\lnot\hat{holds}(alice, read, file, S_{0})$
                \end{vquote}
               
                \begin{vquote}
                  % inheritance rules (negative, read, S0)
                  $\lnot\hat{holds}(alice, read, file, S_{0})$ $\leftarrow$
               
                  \hspace{1em}
                  $\lnot\hat{holds}(grp1, read, file, S_{0})$,
                  $\hat{memb}(alice, grp1, S_{0})$
                \end{vquote}
               
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
               
                \begin{vquote}
                  % inheritance rules (positive, write, S1)
                  $\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$
               
                  \hspace{1em}
                  $\hat{holds}(grp3, write, file, S_{1})$,
                  $\hat{memb}(alice, grp3, S_{1})$,
               
                  \hspace{1em}
                  $not$ $\lnot\hat{holds}(alice, write, file, S_{1})$
                \end{vquote}

                \begin{vquote}
                  % inheritance rules (negative, write, S1)
                  $\lnot\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$
               
                  \hspace{1em}
                  $\lnot\hat{holds}(grp3, write, file, S_{1})$,
                  $\hat{memb}(alice, grp3, S_{1})$
                \end{vquote}
               
                \begin{vquote}
                  % inheritance rules (subset positive, read, S0)
                  $\hat{holds}(grp1, read, file, S_{0})$ $\leftarrow$
               
                  \hspace{1em}
                  $\hat{holds}(grp2, read, file, S_{0})$,
                  $\hat{subst}(grp1, grp2, S_{0})$

                  \hspace{1em}
                  $not$ $\lnot\hat{holds}(grp1, read, file, S_{0})$,
                \end{vquote}
               
                \begin{vquote}
                  % inheritance rules (subset negative, read, S0)
                  $\lnot\hat{holds}(grp1, read, file, S_{0})$ $\leftarrow$
               
                  \hspace{1em}
                  $\lnot\hat{holds}(grp2, read, file, S_{0})$,
                  $\hat{subst}(grp1, grp2, S_{0})$
                \end{vquote}
               
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
               
                \begin{vquote}
                  % inheritance rules (subset positive, write, S1)
                  $\hat{holds}(grp3, write, file, S_{1})$ $\leftarrow$
               
                  \hspace{1em}
                  $\hat{holds}(grp2, write, file, S_{1})$,
                  $\hat{subst}(grp3, grp2, S_{1})$

                  \hspace{1em}
                  $not$ $\lnot\hat{holds}(grp3, write, file, S_{1})$,
                \end{vquote}
               
                \begin{vquote}
                  % inheritance rules (subset negative, write, S1)
                  $\lnot\hat{holds}(grp3, write, file, S_{1})$ $\leftarrow$
               
                  \hspace{1em}
                  $\lnot\hat{holds}(grp2, write, file, S_{1})$,
                  $\hat{subst}(grp3, grp2, S_{1})$
                \end{vquote}

              \item
                Transitivity Rules

                \begin{vquote}
                  $\hat{subst}(grp1, grp3, S_{0})$ $\leftarrow$
                  $\hat{subst}(grp1, grp2, S_{0})$,
                  $\hat{subst}(grp2, grp3, S_{0})$
                \end{vquote}
    
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
    
                \begin{vquote}
                  $\hat{subst}(grp3, grp1, S_{0})$ $\leftarrow$
                  $\hat{subst}(grp3, grp2, S_{0})$,
                  $\hat{subst}(grp2, grp1, S_{0})$
                \end{vquote}
    
                \begin{vquote}
                  $\hat{subst}(grp1, grp3, S_{1})$ $\leftarrow$
                  $\hat{subst}(grp1, grp2, S_{1})$,
                  $\hat{subst}(grp2, grp3, S_{1})$
                \end{vquote}
    
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
    
                \begin{vquote}
                  $\hat{subst}(grp3, grp1, S_{1})$ $\leftarrow$
                  $\hat{subst}(grp3, grp2, S_{1})$,
                  $\hat{subst}(grp2, grp1, S_{1})$
                \end{vquote}

              \item
                Inertial Rules

                \begin{vquote}
                  % inertial rule holds(alice, read, file)
                  $\hat{holds}(alice, read, file, S_{1})$ $\leftarrow$
    
                  \hspace{1em}
                  $\hat{holds}(alice, read, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(alice, read, file, S_{1})$
                \end{vquote}
    
                \begin{vquote}
                  % inertial rule !holds(alice, read, file)
                  $\lnot\hat{holds}(alice, read, file, S_{1})$ $\leftarrow$
    
                  \hspace{1em}
                  $\lnot\hat{holds}(alice, read, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(alice, read, file, S_{1})$
                \end{vquote}
    
                \begin{vquote}
                  % inertial rule holds(alice, write, file)
                  $\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$
    
                  \hspace{1em}
                  $\hat{holds}(alice, write, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(alice, write, file, S_{1})$
                \end{vquote}
    
                \begin{vquote}
                  % inertial rule !holds(alice, write, file)
                  $\lnot\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$
    
                  \hspace{1em}
                  $\lnot\hat{holds}(alice, write, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(alice, write, file, S_{1})$
                \end{vquote}
    
                \begin{vquote}
                  % inertial rule holds(grp1, read, file)
                  $\hat{holds}(grp1, read, file, S_{1})$ $\leftarrow$
    
                  \hspace{1em}
                  $\hat{holds}(grp1, read, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp1, read, file, S_{1})$
                \end{vquote}

                \begin{vquote}
                  % inertial rule !holds(grp1, read, file)
                  $\lnot\hat{holds}(grp1, read, file, S_{1})$ $\leftarrow$
   
                  \hspace{1em}
                  $\lnot\hat{holds}(grp1, read, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp1, read, file, S_{1})$
                \end{vquote}
   
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
                
                \begin{vquote}
                  % inertial rule holds(grp3, read, file)
                  $\hat{holds}(grp3, read, file, S_{1})$ $\leftarrow$
                
                  \hspace{1em}
                  $\hat{holds}(grp3, read, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp3, read, file, S_{1})$
                \end{vquote}
                
                \begin{vquote}
                  % inertial rule !holds(grp3, read, file)
                  $\lnot\hat{holds}(grp3, read, file, S_{1})$ $\leftarrow$
                
                  \hspace{1em}
                  $\lnot\hat{holds}(grp3, read, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp3, read, file, S_{1})$
                \end{vquote}
                
                \begin{vquote}
                  % inertial rule holds(grp1, write, file)
                  $\hat{holds}(grp1, write, file, S_{1})$ $\leftarrow$
                
                  \hspace{1em}
                  $\hat{holds}(grp1, write, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp1, write, file, S_{1})$
                \end{vquote}

                \begin{vquote}
                  % inertial rule !holds(grp1, write, file)
                  $\lnot\hat{holds}(grp1, write, file, S_{1})$ $\leftarrow$
                
                  \hspace{1em}
                  $\lnot\hat{holds}(grp1, write, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp1, write, file, S_{1})$
                \end{vquote}
                
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
                
                \begin{vquote}
                  % inertial rule holds(grp3, write, file)
                  $\hat{holds}(grp3, write, file, S_{1})$ $\leftarrow$
                
                  \hspace{1em}
                  $\hat{holds}(grp3, write, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp3, write, file, S_{1})$
                \end{vquote}
                
                \begin{vquote}
                  % inertial rule !holds(grp3, write, file)
                  $\lnot\hat{holds}(grp3, write, file, S_{1})$ $\leftarrow$
                
                  \hspace{1em}
                  $\lnot\hat{holds}(grp3, write, file, S_{0})$,
                  $not$ $\lnot\hat{holds}(grp3, write, file, S_{1})$
                \end{vquote}
                
                \begin{vquote}
                  % inertial rule memb(alice, grp1)
                  $\hat{memb}(alice, grp1, S_{1})$ $\leftarrow$
                
                  \hspace{1em}
                  $\hat{memb}(alice, grp1, S_{0})$,
                  $not$ $\lnot\hat{memb}(alice, grp1, S_{1})$
                \end{vquote}

                \begin{vquote}
                  % inertial rule !memb(alice, grp1)
                  $\lnot \hat{memb}(alice, grp1, S_{1})$ $\leftarrow$
            
                  \hspace{1em}
                  $\lnot\hat{memb}(alice, grp1, S_{0})$,
                  $not$ $\hat{memb}(alice, grp1, S_{1})$
                \end{vquote}
            
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
            
                \begin{vquote}
                  % inertial rule memb(alice, grp3)
                  $\hat{memb}(alice, grp3, S_{1})$ $\leftarrow$
            
                  \hspace{1em}
                  $\hat{memb}(alice, grp3, S_{0})$,
                  $not$ $\lnot\hat{memb}(alice, grp3, S_{1})$
                \end{vquote}
            
                \begin{vquote}
                  % inertial rule !memb(alice, grp3)
                  $\lnot\hat{memb}(alice, grp3, S_{1})$ $\leftarrow$
            
                  \hspace{1em}
                  $\lnot\hat{memb}(alice, grp3, S_{0})$,
                  $not$ $\hat{memb}(alice, grp3, S_{1})$
                \end{vquote}
            
                \begin{vquote}
                  % inertial rule subst(grp1, grp1)
                  $\hat{subst}(grp1, grp1, S_{1})$ $\leftarrow$
            
                  \hspace{1em}
                  $\hat{subst}(grp1, grp1, S_{0})$,
                  $not$ $\lnot\hat{subst}(grp1, grp1, S_{1})$
                \end{vquote}

                \begin{vquote}
                  % inertial rule !subst(grp1, grp1)
                  $\lnot\hat{subst}(grp1, grp1, S_{1})$ $\leftarrow$
            
                  \hspace{1em}
                  $\lnot\hat{memb}(grp1, grp1, S_{0})$,
                  $not$ $\hat{memb}(grp1, grp1, S_{1})$
                \end{vquote}
            
                \begin{vquote}
                  \hspace{2em}$\vdots$
                \end{vquote}
            
                \begin{vquote}
                  % inertial rule subst(grp3, grp3)
                  $\hat{subst}(grp3, grp3, S_{1})$ $\leftarrow$
            
                  \hspace{1em}
                  $\hat{subst}(grp3, grp3, S_{0})$,
                  $not$ $\lnot\hat{subst}(grp3, grp3, S_{1})$
                \end{vquote}
            
                \begin{vquote}
                  % inertial rule !subst(grp3, grp3)
                  $\lnot\hat{subst}(grp3, grp3, S_{1})$ $\leftarrow$
            
                  \hspace{1em}
                  $\lnot\hat{memb}(grp3, grp3, S_{0})$,
                  $not$ $\hat{memb}(grp3, grp3, S_{1})$
                \end{vquote}

              \item
                Reflexivity Rules

                \begin{vquote}
                  $\hat{subset}(grp1, grp1, S_{0})$ $\leftarrow$
                  
                  $\hat{subset}(grp2, grp2, S_{0})$ $\leftarrow$
                  
                  $\hat{subset}(grp3, grp3, S_{0})$ $\leftarrow$
                  
                  $\hat{subset}(grp1, grp1, S_{1})$ $\leftarrow$
                  
                  $\hat{subset}(grp2, grp2, S_{1})$ $\leftarrow$
                  
                  $\hat{subset}(grp3, grp3, S_{1})$ $\leftarrow$
               \end{vquote}
            \end{enumerate}
          \end{vexample}

          \begin{vdefinition}
            \label{def-langl-trans}
            Given a domain description ${\cal D_{L}}$ of language ${\cal L}$,
            the language ${\cal L^{*}}$ translation $Trans$(${\cal D_{L}}$)
            is an extended logic program of language ${\cal L}$ consisting of:
            (1) initial fact rules, (2) constraint rules, (3) policy update
            rules, (4) inheritance rules, (5) transitivity rules, (6) inertial
            rules, and (7) reflexivity rules as described above.
          \end{vdefinition}

          Note that given a domain description ${\cal D_{L}}$, the translation
          $Trans$(${\cal D_{L}}$) may contain more rules than the original
          statements in ${\cal D_{L}}$. However, as the theorem below defines
          the maximum number of rules generated in a translation
          $Trans$(${\cal D_{L}}$), it shows that the size of a translated
          domain $|$$Trans$(${\cal D_{L}}$)$|$ can only be polynomially larger
          than the size of the given domain $|$${\cal D_{L}}$$|$. Therefore,
          from a computational viewpoint, computing the answer sets of
          $Trans$(${\cal D_{L}}$) is always feasible.

          \begin{vtheorem}{Translation Size}
            \label{the-size}
            Given a domain description ${\cal D_{L}}$; the sets $\Gamma_{int}$,
            $\Gamma_{con}$ and $\Gamma_{upd}$ containing the initially,
            constraint and policy update statements in ${\cal D_{L}}$,
            respectively; the set ${\cal E}$ containing all the entities in
            ${\cal D_{L}}$, including its subsets ${\cal E}_{s}$,
            ${\cal E}_{a}$, ${\cal E}_{s}$, ${\cal E}_{ss}$, ${\cal E}_{as}$,
            ${\cal E}_{os}$, ${\cal E}_{sg}$, ${\cal E}_{ag}$, ${\cal E}_{og}$;
            the set ${\cal A}$ containing all the atoms in ${\cal D_{L}}$; the
            maximum number of facts $Max$($\Gamma_{int}$) in the expression of
            any {\em initially} statement in $\Gamma_{int}$; the maximum
            number of facts $Max$($\Gamma_{con}$) in the {\em always} clause
            expression of any constraint statement in $\Gamma_{con}$; the
            maximum number of facts $Max$($\Gamma_{upd}$) in the postcondition
            expression of any policy update statement in $\Gamma_{upd}$; and
            finally the policy update sequence list $\psi$, then the size of
            the translation $Trans$(${\cal D_{L}}$) is:

            \begin{vquote}
              $|$$Trans$(${\cal D_{L}}$)$|$ $\leq$
 
              % initially
              \hspace{1em}
              $Max$($\Gamma_{int}$) $|\Gamma_{int}|$ $+$
 
              % constraints
              \hspace{1em}
              $|\psi|$ $Max$($\Gamma_{con}$) $|\Gamma_{con}|$ $+$
 
              % policy updates
              \hspace{1em}
              $|\psi|$ $Max$($\Gamma_{upd}$) $+$
 
              % membership inheritance
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{ss}|$ $|{\cal E}_{sg}|$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{as}|$ $|{\cal E}_{ag}|$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{os}|$ $|{\cal E}_{og}|$ $+$
 
              % subset inheritance
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{sg}|^{2}$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{ag}|^{2}$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{og}|^{2}$ $+$
 
              % transitivity rules
              \hspace{1em}
              $|\psi|$
              $($$|{\cal E}_{sg}|^{3}$ $+$
              $|{\cal E}_{ag}|^{3}$ $+$
              $|{\cal E}_{og}|^{3}$$)$ $+$
 
              % inertial rules
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal A}|$ $+$
 
              % reflexivity rules
              \hspace{1em}
              $|\psi|$
              $($$|{\cal E}_{sg}|$ $+$ $|{\cal E}_{ag}|$ $+$ $|{\cal E}_{og}|$$)$
            \end{vquote}
          \end{vtheorem}

          \begin{vproof}
            From Definition \ref{def-langl-trans}, it follows that the size of
            a language ${\cal L}^{*}$ translation is as follows:

            \begin{vquote}
              $|$$Trans$(${\cal D_{L}}$)$|$ $=$
                $|{\cal F}_{int}|$ $+$
                $|{\cal F}_{con}|$ $+$
                $|{\cal F}_{upd}|$ $+$
                $|{\cal F}_{inh}|$ $+$
                $|{\cal F}_{tra}|$ $+$
                $|{\cal F}_{ine}|$ $+$
                $|{\cal F}_{ref}|$
            \end{vquote}

            \noindent
            where ${\cal F}_{int}$, ${\cal F}_{con}$, ${\cal F}_{upd}$,
            ${\cal F}_{inh}$, ${\cal F}_{tra}$, ${\cal F}_{ine}$, and
            ${\cal F}_{ref}$ are the sets of initial fact rules, constraint
            rules, policy update rules, inheritance rules, transitivity rules,
            inertial rules, and reflexivity rules, respectively.

            As no {\em initially} statement in the set $\Gamma_{int}$ contain
            an expression with more than $Max$($\Gamma_{int}$) facts, the
            maximum number of initial fact rules generated in the translation
            is:

            \begin{vquote}
              $|{\cal F}_{int}|$ $\leq$
                $Max$($\Gamma_{int}$) $|\Gamma_{int}|$
            \end{vquote}

            Each language ${\cal L}$ constraint statement in $\Gamma_{con}$
            corresponds to $n$ rules in language ${\cal L}^{*}$, where $n$ is
            the number of policy update states times the number of facts in the
            {\em always} clause of the statement. With $Max$($\Gamma_{con}$) as
            the maximum number of facts in the {\em always} clause of any
            constraint statement, we have:

            \begin{vquote}
              $|{\cal F}_{con}|$ $\leq$
                $|\psi|$ $Max$($\Gamma_{con}$) $|\Gamma_{con}|$
            \end{vquote}

            For policy update statements, only those that are applied are
            actually translated to language ${\cal L}^{*}$. With
            $Max$($\Gamma_{upd}$) as the maximum number of facts in the
            postcondition expression of any applied policy update statement, we
            have:

            \begin{vquote}
              $|{\cal F}_{upd}|$ $\leq$ $|\psi|$ $Max$($\Gamma_{upd}$)
            \end{vquote}

            The total number of inheritance rules generated in the translation
            is the sum of the number of member inheritance rules and the number
            of subset inheritance rules:

            \begin{vquote}
              $|{\cal F}_{inh}|$ $=$
                $|{\cal F}_{inh_{mem}}|$ $+$
                $|{\cal F}_{inh_{sub}}|$
            \end{vquote}

            Since the membership inheritance rules show the relationships
            between every possible combination of single and group entities
            times the number of states times 2 (for negative facts), we have:
 
            \begin{vquote}
              $|{\cal F}_{inh_{mem}}|$ $=$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{ss}|$ $|{\cal E}_{sg}|$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{as}|$ $|{\cal E}_{ag}|$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{os}|$ $|{\cal E}_{og}|$
            \end{vquote}
 
            For subset inheritance rules, only the relationships between group
            entities are considered:
 
            \begin{vquote}
              $|{\cal F}_{inh_{sub}}|$ $=$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{sg}|^{2}$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{ag}|^{2}$ $|{\cal E}_{o}|$ $+$
 
              \hspace{1em}
              $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{og}|^{2}$
            \end{vquote}
 
            As transitivity rules enumerate every possible combinations of any
            three group entities, for each entity type, the total number of
            transitivity rules is shown below:
 
            \begin{vquote}
              $|{\cal F}_{tra}|$ $=$
              $|\psi|$
              ($|{\cal E}_{sg}|^{3}$ $+$ $|{\cal E}_{ag}|^{3}$ $+$ $|{\cal E}_{og}|^{3}$)
            \end{vquote}
 
            A single atom in language ${\cal L}$ corresponds to $n$ inertial
            rules in language ${\cal L}^{*}$, where $n$ is the number of states
            times 2 (for negative facts). This means the total number of
            inertial rules generated is:
 
            \begin{vquote}
              $|{\cal F}_{ine}|$ $=$ $2$ $|\psi|$ $|{\cal A}|$
            \end{vquote}
 
            Lastly, the total number of reflexivity rules is equal to the total
            number of group entities times the number of states:
 
            \begin{vquote}
              $|{\cal F}_{ref}|$ $=$
              $|\psi|$
              ($|{\cal E}_{sg}|$ $+$ $|{\cal E}_{ag}|$ $+$ $|{\cal E}_{og}|$)
            \end{vquote}
          \end{vproof}

    \section{Domain Consistency and Query Evaluation}

  \chapter{PolicyUpdater System}

  \chapter{Temporal Constraints in Authorisation Policies}

    \section{Introduction}

      An obvious limitation of language ${\cal L}$ is its lack of expressive
      power to represent time-dependent authorisations. Consider the following
      authorisation rule:

      \begin{vquote}
        $Bob$ holds $read$ access to file $f$ between $9:00$ $AM$ and $5:00$
        $PM$
      \end{vquote}

      The authorisation information above can be broken down into two parts: an
      authorisation part, i.e. "Bob holds read access to file $f$", and a
      temporal part, i.e. "between 9:00 AM and 5:00 PM". As language ${\cal L}$
      can already express authorisations, we focus our attention to the
      temporal part. A naive attempt to extend language ${\cal L}$ to express
      time may involve adding two extra parameters to each authorisation atom
      to represent the starting and ending time points of the interval. For
      example, the authorisation rule above can be represented as:

      \begin{vquote}
        $holds$($bob$, $read$, $f$, $900$, $1700$)
      \end{vquote}

      The atom above may be interpreted to mean that the authorisation holds
      for all times between 9:00 AM and 5:00 PM, inclusive. In this example,
      the granularity of time, or the smallest unit of time that can be
      expressed, is one minute. Of course, a more general approach is to use
      the domain of positive integers. With this approach, the system can
      handle different granularities of time, where the choice of what time
      unit each discrete value is interpreted as is left to the application.
      For example, if the temporal values are defined to be the number of
      seconds since 12 midnight, 01 Jan 1970 (i.e. the beginning of the UNIX
      epoch), then the atom below states that the authorisation holds at an
      interval starting at 9:00 AM, 18 March 1976 and ending at 5:00 PM, 18
      March 1976:

      \begin{vquote}
        $holds$($bob$, $read$, $f$, $195951600$, $195980400$)
      \end{vquote}

      While this approach gives the language enough expressive power to
      represent authorisations bound by literal time values, it is by no means
      expressive enough to model relationships between the time values
      themselves. This deficiency is shown in the example below:

      \begin{vquote}
        $Alice$ holds a $write$ access right to file $f_0$ after $Bob$ holds a
        $read$ access right to file $f_1$
      \end{vquote}

      Such authorisation rule might arise in a situation where the access right
      $write$ to file $f_0$ can only be granted at some time after the $read$
      access right to file $f_1$ has been granted and revoked. This example
      shows that the specific times at which authorisations hold are not as
      important as the relationship between the times themselves. This
      authorisation rule may be represented as follows:

      \begin{vquote}
        $holds$($alice$, $write$, $f_0$, $i_{1}$)

        $holds$($bob$, $read$, $f_0$, $i_{2}$)

        $after$($i_0$, $i_1$)
      \end{vquote}

      The example above states that $alice$ holds a $write$ access right to
      file $f_0$ at some time interval $i_0$, $bob$ holds a $read$ access right
      to file $f_1$ at some time interval $i_1$, and that the interval $i_0$
      occurs at some time after the interval $i_1$. As mentioned earlier, the
      actual values of the time intervals $i_0$ and $i_1$ is not as important
      as the fact that the interval $i_0$ occurs after interval $i_1$.

      The rest of this chapter discusses how temporal constraints can be
      incorporated into the authorisation language. The next section introduces
      Allen's temporal interval algebra to express relations between time
      values, followed by a section that outlines extensions to this algebra,
      and finally, the last section gives a detailed formalisation of a new
      authorisation language that utilises the interval algebra to support
      temporal constraints.

    \section{Allen's Temporal Interval Algebra}

      Allen's interval algebra \cite{AL} is based on the fact that for any
      two well defined time intervals, there exists exactly one interval
      relation between them. The strength of the algebra lies not just on
      the formalisation of these relations, but also on its ability to handle
      disjunctive interval relations between undefined time intervals.

      For example, given an interval ${i_0}$, defined as 24th of September,
      1995 to 25th of September, 1995; and interval ${i_1}$, defined as 25th of
      December 1995 to 1st of January 1996. From the definitions of these
      intervals, it is easy to conclude that interval ${i_0}$ is {\em before}
      interval ${i_1}$, since the finishing end point of interval ${i_0}$
      occurs before the starting end point of interval ${i_1}$.

      The strength of the interval algebra can be illustrated by considering
      intervals without endpoint definitions, but rather as having disjunctive
      relations with other intervals. For example, given three intervals
      ${i_0}$, ${i_1}$ and ${i_2}$ whose bounding endpoints are not known. The
      algebra allows us to conclude that if ${i_0}$ occurs either {\em before}
      or {\em during} ${i_1}$ and ${i_2}$ occurs {\em after} ${i_1}$, then the
      interval ${i_0}$ must occur {\em before} ${i_2}$.

      The rest of the section gives a detailed overview of Allen's interval
      algebra.

      \subsection{Time Points and Time Intervals}

        The preceding introduction hinted the difference between a time point and a
        time interval. This sub section aims to give a more formal distinction between
        the two.

        A point in time represents an event with zero duration, or an event that occurs
        instantaneously, such as the switching on of a light bulb, or the moment the sun
        has risen in the morning.

        A time interval, on the other hand, is defined to be the time that has elapsed
        between two given time points. For example, the interval one might call lunch
        hour may be defined as the time elapsed between the time points 1 PM and 2 PM.

        Formally, a time interval $i$ is defined by its starting end point ${i^-}$ and
        a finishing end point ${i^+}$, where ${i^-}$ $<$ ${i^+}$.

        One might argue that time point events such as the switching on of a light bulb
        are not instantaneous, meaning that time, no matter how small the value, has
        elapsed between the instant that electricity flowed through light bulb's
        filament and the instant the light from the bulb reaches the observer's eyes.
        One can further argue that the "instant" that electricity flowed through the
        bulb's filament is not instantaneous, once we consider that the speed of light
        and electricity is finite. In other words, any given event can always be
        divided into sub-events. This argument is more evident in the sunrise example.

        To solve this problem, Allen's algebra defines time intervals as the most basic
        entities. This means time points are not used to define time intervals, but
        instead, each interval is defined only in terms of its relationship with other
        intervals.

      \subsection{Time Interval Relations}

        As shown in Figure \ref{fig-rels}, the algebra defines 13 disjoint relations
        that can occur between any two intervals. For clarity, we define each temporal
        interval relation below in terms of the relationships of the end points of
        their intervals:

        \begin{figure}[[tbhp]
          \begin{center}
            \includegraphics{rels}
            \caption{Thirteen Temporal Interval Relations}
            \label{fig-rels}
          \end{center}
        \end{figure}

        \begin{itemize}
          \item
            {\em Before}.
            Interval ${i_0}$ is said to be {\em before} interval ${i_1}$ if and
            only if ${i_0^+}$ $<$ ${i_1^-}$.

          \item
            {\em After}.
            Interval ${i_0}$ is said to be {\em after} interval ${i_1}$ if and
            only if ${i_0^-}$ $>$ ${i_1^+}$. Note that this is an inverse of
            the {\em before} relation.

          \item
            {\em Meets}.
            Interval ${i_0}$ is said to {\em meet} interval ${i_1}$ if and only
            if ${i_0^+}$ $=$ ${i_1^-}$.

          \item
            {\em Met By}.
            Interval ${i_0}$ is said to be {\em met by} interval ${i_1}$ if and
            only if ${i_0^-}$ $=$ ${i_1^+}$. Note that this is an inverse of
            the {\em meets} relation.

          \item
            {\em During}.
            Interval ${i_0}$ is said to be {\em during} interval ${i_1}$ if and
            only if ${i_0^-}$ $>$ ${i_1^-}$ and ${i_0^+}$ $<$ ${i_1^+}$.

          \item
            {\em Contains}.
            Interval ${i_0}$ is said to {\em contain} interval ${i_1}$ if and
            only if ${i_0^-}$ $<$ ${i_1^-}$ and ${i_0^+}$ $>$ ${i_1^+}$. Note
            that this is an inverse of the {\em during} relation.

          \item
            {\em Overlaps}.
            Interval ${i_0}$ is said to {\em overlap} interval ${i_1}$ if and
            only if ${i_0^-}$ $<$ ${i_1^-}$, ${i_0^+}$ $>$ ${i_1^-}$ and
            ${i_0^+}$ $<$ ${i_1^+}$.

          \item
            {\em Overlapped By}.
            Interval ${i_0}$ is said to be {\em overlapped by} interval
            ${i_1}$ if and only if ${i_0^-}$ $>$ ${i_1^-}$, ${i_0^-}$ $<$
            ${i_1^+}$ and ${i_0^+}$ $>$ ${i_1^+}$. Note that this is an
            inverse of the {\em overlaps} relation.

          \item
            {\em Starts}.
            Interval ${i_0}$ is said to {\em start} interval ${i_1}$ if and
            only if ${i_0^-}$ $=$ ${i_1^-}$ and ${i_0^+}$ $<$ ${i_1^+}$.

          \item
            {\em Started By}.
            Interval ${i_0}$ is said to be {\em started by} interval ${i_1}$ if
            and only if ${i_0^-}$ $=$ ${i_1^-}$ and ${i_0^+}$ $>$ ${i_1^+}$.
            Note that this is an inverse of the the {\em starts} relation.

          \item
            {\em Finishes}.
            Interval ${i_0}$ is said to {\em finish} interval ${i_1}$ if and
            only if ${i_0^-}$ $>$ ${i_1^-}$ and ${i_0^+}$ $=$ ${i_1^+}$.

          \item
            {\em Finished By}.
            Interval ${i_0}$ is said to be {\em finished by} interval ${i_1}$
            if and only if ${i_0^-}$ $<$ ${i_1^-}$ and ${i_0^+}$ $=$ ${i_1^+}$.
            Note that this is an inverse of the {\em finishes} relation.

          \item
            {\em Equals}.
            Interval ${i_0}$ {\em equals} interval ${i_1}$ if and only if ${i_0^-}$
            $=$ ${i_1^-}$ and ${i_0^+}$ $=$ ${i_1^+}$.
        \end{itemize}

        For example, given intervals {\em lunch hour} and {\em work hours},
        defined as 1 PM to 2 PM and 9 AM to 5 PM, respectively. Since 1 PM
        (1300 hours) is greater than 9 AM (0900 hours) and 2 PM (1400 hours) is
        less than 5 PM (1700 hours), then the interval {\em lunch hour} is
        {\em during} the interval {\em work hours}.

      \subsection{Inferring New Relations}

        As mentioned earlier, the strength of the algebra is its ability to infer new
        relations from existing ones. This is achieved by taking advantage of the
        transitive properties of relations. For example, given that interval ${i_0}$ is
        {\em before} interval ${i_1}$ and interval ${i_1}$ is {\em before} interval
        ${i_2}$. Regardless of what the end points are, interval ${i_0}$ is
        {\em before} interval ${i_2}$.

        While simple relations like the one shown in the above example may seem
        intuitive, we quickly realise that it may not be so if we consider that
        a relation that exists between any two intervals may be given as a
        disjunctive set of possible relations. For example, the relation
        between interval ${i_0}$ and interval ${i_1}$ may be given as a set
        of possible relations \{{\em before}, {\em after}, {\em during}\}.

        Another issue is propagation. Given that the temporal knowledge base
        is populated by these disjunctive interval relations, adding new
        pieces of information may narrow down the set of possible relations
        between two intervals. This in turn may lead to the trimming down of
        other relations between other interval pairs. In fact, as new and more
        specific information are added into the knowledge base, its effects may
        propagate to other relations.

        \subsubsection{Interval Relation Network}

          The temporal interval relation knowledge base is represented as a
          network whose nodes represent intervals and the arcs between them
          represent a set of possible relations that hold between the two
          intervals. Note that although this representation allows the
          assignment of a set of relations between any two intervals, because
          the relations are mutually exclusive, we know that only one of these
          relations actually holds. The fact that some interval pairs have a
          set of relations between them only suggests that the information
          given is insufficient to define the exact relation that holds
          between the intervals. Formally, we define the interval relation
          network as follows:

          \begin{vdefinition}
            \label{def-net}
            A {\bf interval relation network} is a collection of {\bf nodes}
            and {\bf arcs}, where each node represents a single temporal
            interval and each arc represents a set of possible relations
            between two intervals. For any node pair, there is exactly one arc
            between them.
          \end{vdefinition}

          The interval relation network is maintained in such a way that each
          node is connected to every other node in the network. In cases where
          no information is given to define an arc, we use the default arc
          which  contains a set of all 13 relations. As a matter of convention
          in the notation, we only show one arc between two nodes. The reverse
          arc, composed of the inverses of the relations represented by the
          first arc, is omitted.

          Figure \ref{fig-net-ex-01} gives an example of a network with three
          nodes: $i_0$, $i_1$ and $i_2$ and the following relations:

          \begin{itemize}
            \item
              Interval ${i_0}$ is {\em before} or {\em during} interval
              ${i_1}$.
            \item
              Interval ${i_1}$ {\em overlaps} interval $i_2$.
          \end{itemize}

          In this example, note that because no relation is defined for
          intervals ${i_0}$ and ${i_2}$, the corresponding arc between these
          nodes in Figure \ref{fig-net-ex-01} is labelled {\em All}, meaning
          the relation set contains all 13 possible relations.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-01}
              \caption{Network Representation Example}
              \label{fig-net-ex-01}
            \end{center}
          \end{figure}

          With the network structure defined, we can now formally define the
          three basic network operators:

          \begin{vdefinition}
            \label{def-net-ops}
            Given a temporal interval network $NET$. The three basic network
            operations are as follows:

            \begin{itemize}
              \item
                The $NET.Get$($I_0$, $I_1$) operator returns the relation
                set on the arc between intervals $I_0$ and $I_1$.
              \item
                The $NET$.$Replace$($I_0$, $I_1$, $RS$) operator replaces the
                relation set on the arc between intervals $I_0$ and $I_1$ with
                the relation set $RS$.
              \item
                The $NET.Add$($I_0$, $I_1$, $RS$) operator adds the relation
                set $RS$ to the arc between intervals $I_0$ and $I_1$, and
                propagates the effects of this change to the rest of the
                network.
            \end{itemize}
          \end{vdefinition}

          As described in the definition above, the $NET.Get$() and
          $NET.Replace$() operators are simple $get$() and $set$() operations
          on arc labels. In constrast, the $NET.Add$() operator requires a
          more complex algorithm to perform the propagation. This algorithm is
          discussed in detail in the next section.

          \begin{table}[p]
            \begin{vvarmargin}{-4cm}{-4cm}
              \begin{center}
                \tiny
                \begin{tabular}[t]{|r|l|l|l|l|l|l|l|l|l|l|l|l|}
                  \hline
                                          & \textbf{Before}         & \textbf{After}          & \textbf{During}         & \textbf{Contains}       & \textbf{Overlaps}       & \textbf{Overlapped By}  & \textbf{Meets}          & \textbf{Met}            & \textbf{Starts}         & \textbf{Started By}     & \textbf{Finishes}       & \textbf{Finished By}    \\
                                          & (BEF)                   & (BEI)                   & (DUR)                   & (DUI)                   & (OVR)                   & (OVI)                   & (MET)                   & (MEI)                   & (STA)                   & (STI)                   & (FIN)                   & (FII)                   \\
                  \hline
                  \textbf{Before}         & BEF                     & ALL                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     \\
                  (BEF)                   &                         &                         & OVR                     &                         &                         & OVR                     &                         & OVR                     &                         &                         & OVR                     &                         \\
                                          &                         &                         & MET                     &                         &                         & MET                     &                         & MET                     &                         &                         & MET                     &                         \\
                                          &                         &                         & DUR                     &                         &                         & DUR                     &                         & DUR                     &                         &                         & DUR                     &                         \\
                                          &                         &                         & STA                     &                         &                         & STA                     &                         & STA                     &                         &                         & STA                     &                         \\
                  \hline
                  \textbf{After}          & ALL                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     \\
                  (BEI)                   &                         &                         & OVI                     &                         & OVI                     &                         & OVI                     &                         & OVI                     &                         &                         &                         \\
                                          &                         &                         & MEI                     &                         & MEI                     &                         & MEI                     &                         & MEI                     &                         &                         &                         \\
                                          &                         &                         & DUR                     &                         & DUR                     &                         & DUR                     &                         & DUR                     &                         &                         &                         \\
                                          &                         &                         & FIN                     &                         & FIN                     &                         & FIN                     &                         & FIN                     &                         &                         &                         \\
                  \hline
                  \textbf{During}         & BEF                     & BEI                     & DUR                     & ALL                     & BEF                     & BEI                     & BEF                     & BEI                     & DUR                     & BEI                     & DUR                     & BEF                     \\
                  (DUR)                   &                         &                         &                         &                         & OVI                     & OVI                     &                         &                         &                         & OVI                     &                         & OVR                     \\
                                          &                         &                         &                         &                         & MET                     & MEI                     &                         &                         &                         & MEI                     &                         & MET                     \\
                                          &                         &                         &                         &                         & DUR                     & DUR                     &                         &                         &                         & DUR                     &                         & DUR                     \\
                                          &                         &                         &                         &                         & STI                     & FIN                     &                         &                         &                         & FIN                     &                         & STA                     \\
                  \hline
                  \textbf{Contains}       & BEF                     & BEI                     & OVR                     & DUI                     & OVR                     & OVI                     & OVR                     & OVI                     & DUI                     & DUI                     & DUI                     & DUI                     \\
                  (DUI)                   & MET                     & DUI                     & DUR                     &                         & DUI                     & DUI                     & DUI                     & DUI                     & FII                     &                         & STI                     &                         \\
                                          & DUI                     & MEI                     & STA                     &                         & FII                     & STI                     & FII                     & STI                     & OVR                     &                         & OVI                     &                         \\
                                          & FII                     & STI                     & FIN                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Overlaps}       & BEF                     & BEI                     & OVR                     & BEF                     & BEF                     & OVR                     & BEF                     & OVI                     & OVR                     & DUI                     & DUR                     & BEF                     \\
                  (OVR)                   &                         & OVI                     & DUR                     & OVR                     & OVR                     & OVI                     &                         & DUI                     &                         & FII                     & STA                     & OVR                     \\
                                          &                         & DUI                     & STA                     & MET                     & MET                     & DUR                     &                         & STI                     &                         & OVR                     & OVR                     & MET                     \\
                                          &                         & MEI                     &                         & DUI                     &                         & STA                     &                         &                         &                         &                         &                         &                         \\
                                          &                         & STI                     &                         & FII                     &                         & FIN                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Overlapped By}  & BEF                     & BEI                     & OVI                     & BEI                     & OVR                     & BEI                     & OVR                     & BEI                     & OVI                     & OVI                     & OVI                     & OVI                     \\
                  (OVI)                   & OVR                     &                         & DUR                     & OVI                     & OVI                     & OVI                     & DUI                     &                         & DUR                     & BEI                     &                         & DUI                     \\
                                          & MET                     &                         & FIN                     & MEI                     & DUR                     & MEI                     & FII                     &                         & FIN                     & MEI                     &                         & STI                     \\
                                          & DUI                     &                         &                         & DUI                     & STA                     &                         &                         &                         &                         &                         &                         &                         \\
                                          & FII                     &                         &                         & STI                     & FIN                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Meets}          & BEF                     & BEI                     & OVR                     & BEF                     & BEF                     & OVR                     & BEF                     & FIN                     & MET                     & MET                     & DUR                     & BEF                     \\
                  (MET)                   &                         & OVI                     & DUR                     &                         &                         & DUR                     &                         & FII                     &                         &                         & STA                     &                         \\
                                          &                         & MEI                     & STA                     &                         &                         & STA                     &                         & EQL                     &                         &                         & OVR                     &                         \\
                                          &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Met By}         & BEF                     & BEI                     & OVI                     & BEI                     & OVI                     & BEI                     & STA                     & BEI                     & DUR                     & BEI                     & MEI                     & MEI                     \\
                  (MEI)                   & OVR                     &                         & DUR                     &                         & DUR                     &                         & STI                     &                         & FIN                     &                         &                         &                         \\
                                          & MET                     &                         & FIN                     &                         & FIN                     &                         & EQL                     &                         & OVI                     &                         &                         &                         \\
                                          & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Starts}         & BEF                     & BEI                     & DUR                     & BEF                     & BEF                     & OVI                     & BEF                     & MEI                     & STA                     & STA                     & DUR                     & BEF                     \\
                  (STA)                   &                         &                         &                         & OVR                     & OVR                     & DUR                     &                         &                         &                         & STI                     &                         & MET                     \\
                                          &                         &                         &                         & MET                     & MET                     & FIN                     &                         &                         &                         & EQL                     &                         & OVR                     \\
                                          &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Started By}     & BEF                     & BEI                     & OVI                     & DUI                     & OVR                     & OVI                     & OVR                     & MEI                     & STA                     & STI                     & OVI                     & DUI                     \\
                  (STI)                   & OVR                     &                         & DUR                     &                         & DUI                     &                         & DUI                     &                         & STI                     &                         &                         &                         \\
                                          & MET                     &                         & FIN                     &                         & FII                     &                         & FII       y             &                         & EQL                     &                         &                         &                         \\
                                          & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Finishes}       & BEF                     & BEI                     & DUR                     & BEI                     & OVR                     & BEI                     & MET                     & BEI                     & DUR                     & BEI                     & FIN                     & FIN                     \\
                  (FIN)                   &                         &                         &                         & OVI                     & DUR                     & OVI                     &                         &                         &                         & OVI                     &                         & FII                     \\
                                          &                         &                         &                         & MEI                     & STA                     & MEI                     &                         &                         &                         & MEI                     &                         & EQL                     \\
                                          &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Finished By}    & BEF                     & BEI                     & OVR                     & DUI                     & OVR                     & OVI                     & MET                     & STI                     & OVR                     & DUI                     & FIN                     & FII                     \\
                  (FII)                   &                         & OVI                     & DUR                     &                         &                         & DUI                     &                         & OVI                     &                         &                         & FII                     &                         \\
                                          &                         & MEI                     & STA                     &                         &                         & STI                     &                         & DUI                     &                         &                         & EQL                     &                         \\
                                          &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                \end{tabular}
              \end{center}
              \caption[]{Transitivity Table}
              \label{table-trans}
            \end{vvarmargin}
          \end{table}

        \subsubsection{Propagation Algorithm}

          The algorithm works as follows. As a starting point, we assume that
          the network contains complete interval relation information, i.e. at
          each node, there is an arc that connects it to every other node.
          Where there is no defined relationship between two nodes, the default
          arc is used to connect these two nodes. The algorithm is invoked
          whenever new information is to be added into the network. Whenever a
          new relation is added into the network, all consequences of this new
          relation are also added into the network. These consequences are
          computed through the transitive closure of the network. The following
          example illustrates this procedure.

          Given 3 intervals $i_0$, $i_1$ and $i_2$, and the relation $i_0$ is
          {\em before} $i_1$. Suppose the new relation $i_2$ is {\em during}
          $i_1$ is added into the network. The algorithm then infers that
          $i_0$ is {\em before} $i_2$. This new relation is again added into
          the network in a similar way, possibly inferring other new relations
          as it is added. This procedure is repeated until no new information
          is yielded.

          Table \ref{table-trans} shows the basic transitivity rules. For any 3
          intervals $i_0$, $i_1$ and $i_2$, the relation(s) between intervals
          $i_0$ and $i_2$ is shown in the intersection of the row that contains
          the relation between $i_0$ and $i_1$, and the column that contains
          the relation between $i_1$ and $i_2$.

          Before we can define the actual algorithm, we must first define a few
          functions. For any single relations $r_0$ and $r_1$, the function
          $Trans_1$($r_0$, $r_1$) returns the relation set $RS$ that
          corresponds to the intersection of $r_0$ and $r_1$ in Table
          \ref{table-trans}.

          Using this function, we can then define the extended function
          $Trans_2$($RS_0$, $RS_1$) shown in Algorithm \ref{algo-trans2}, which
          takes a pair of relation sets $RS_0$ and $RS_1$ as input, and returns
          the relation set $RS$ which contains all the possible relations
          inferred from the two given relation sets using the $Trans_1$()
          function.

          \begin{valgorithm}[tbhp]{$Trans_{2}()$}{algo-trans2}
FUNCTION \(Trans\sb{2}\)(\(RS\sb{0}\), \(RS\sb{1}\))
  \(RS\) = \(\emptyset\)
  FOR each \(r\sb{0}\) \(\in\) \(RS\sb{0}\) DO
    FOR each \(r\sb{1}\) \(\in\) \(RS\sb{1}\) DO
      \(RS\) = \(RS\) \(\cup\) \(Trans\sb{1}\)(\(r\sb{0}\), \(r\sb{1}\))
    ENDDO
  ENDDO
  RETURN \(RS\)
ENDFUNCTION
          \end{valgorithm}

          In addition to these functions, we also define a standard queue
          structure $Q$ which stores network arcs, i.e. a pair of intervals
          and a relation set that holds between the two intervals. Thus, we
          have three operators for the queue structure:

          \begin{itemize}
            \item
              $Q.Enqueue$($I_0$, $I_1$, $RS$) stores the given arc to the end
              of the structure.
            \item
              $Q.Dequeue$() returns and removes the arc at the front of the
              structure.
            \item
              $Q.IsEmpty$() returns true if the queue is empty and false
              otherwise.
          \end{itemize}

          The $NET.Add()$ algorithm shown in Algorithm \ref{algo-net-add} works
          as follows. Every time a new arc ($i_0$, $i_1$, $rs$) is added, the
          algorithm finds the transitive relation set $RS$ between each of
          these intervals and every other interval $I$ in the network, i.e.
          the algorithm finds $RS$ = $Trans_2$($NET.Get$($I$, $i_0$), $rs$) for
          every other interval $I$ in the network. If this new relation set
          $RS$ contains more specific information than what is already in the
          network, i.e. $RS$ $\subset$ $NET.Get$($I$, $i_1$), then this new arc
          between $I$ and $i_1$ (shown in Figure \ref{fig-net-ex-02}) is again
          put through the same algorithm, as it might yield more relation
          changes.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-02}
              \caption{A new relation $RS$ from interval $I$ and interval $i_1$}
              \label{fig-net-ex-02}
            \end{center}
          \end{figure}

          Note that the algorithm also attempts to form new transitive
          relations between the given intervals $i_0$ and $i_1$ and all other
          intervals $I$ in the network such that interval $I$ is to the right
          of the other two intervals (shown in Figure \ref{fig-net-ex-03}).

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-03}
              \caption{A new relation $RS$ from interval $i_0$ and interval $I$}
              \label{fig-net-ex-03}
            \end{center}
          \end{figure}

          \begin{valgorithm}[tbhp]{$NET.Add()$}{algo-net-add}
FUNCTION \(NET.Add\)(\(I\sb{0}\), \(I\sb{1}\), \(RS\))
  \(Q.Enqueue\)(\(I\sb{0}\), \(I\sb{1}\), \(RS\))
  WHILE NOT \(Q.IsEmpty\)() DO
    \(I\sb{0}'\), \(I\sb{1}'\), \(RS'\) = \(Q.Dequeue\)()
    \(NET.Replace\)(\(I\sb{0}'\), \(I\sb{1}'\), \(RS'\))
    FOR each interval \(I''\) \(\in\) \(NET\) DO
      IF \(I''\) != \(I\sb{0}'\) AND \(I''\) != \(I\sb{1}'\) THEN
        \(RS''\) =  \(Trans\sb{2}\)(\(NET.Get\)(\(I''\), \(I\sb{0}'\)), \(RS'\))
        \(RS'''\) = \(NET.Get\)(\(I''\), \(I\sb{1}'\)) \(\cap\) \(RS''\)
        IF \(RS'''\) \(\subset\) \(NET.Get\)(\(I''\), \(I\sb{1}'\)) THEN
          \(Q.Add\)(\(I''\), \(I\sb{1}'\), \(RS'''\))
        ENDIF
      ENDIF
    ENDDO
    FOR each interval \(I''\) \(\in\) \(NET\) DO
      IF \(I''\) != \(I\sb{0}'\) AND \(I''\) != \(I\sb{1}'\) THEN
        \(RS''\) =  \(Trans\sb{2}\)(\(RS'\), \(NET.Get\)(\(I\sb{1}'\), \(I''\)))
        \(RS'''\) = \(NET.Get\)(\(I\sb{0}'\), \(I''\)) \(\cap\) \(RS''\)
        IF \(RS'''\) \(\subset\) \(NET.Get\)(\(I''\), \(I\sb{0}'\)) THEN
          \(Q.Add\)(\(I\sb{0}'\), \(I''\), \(RS'''\))
        ENDIF
      ENDIF
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          \begin{vexample}
            \label{ex-4-1}
            Given a network with three intervals $i_0$, $i_1$ and $i_2$ where
            no relation between any of the intervals are known. As no relations
            are given, each arc in the network as shown in Figure
            \ref{fig-net-ex-04} is the default arc.

            \begin{figure}[tbhp]
              \begin{center}
                \includegraphics{net-04}
                \caption{Network with 3 default arcs}
                \label{fig-net-ex-04}
              \end{center}
            \end{figure}

            Now, suppose the relation between interval $i_0$ and interval $i_1$
            is narrowed down to the relation set \{$before$, $meets$,
            $overlaps$\}, i.e., the operation $NET.Add$($i_0$, $i_1$, \{$BEF$,
            $MET$, $OVR$\}) is executed. This operation will yield the network
            shown in Figure \ref{fig-net-ex-05}. Note that because every arc
            in the network contains all relations, the effects of the
            $NET.ADD$() operation are limited to one arc.

            \begin{figure}[tbhp]
              \begin{center}
                \includegraphics{net-05}
                \caption{Network after $NET.Add$($i_0$, $i_1$, \{$BEF$, $MET$, $OVR$\})}
                \label{fig-net-ex-05}
              \end{center}
            \end{figure}

            Now, if the relation set \{$starts$, $finishes$\} is added to the
            arc between interval $i_1$ and interval $i_2$, the $NET.Add$($i_1$,
            $i_2$, \{$STA$, $FIN$\}) algorithm will also compute the relation
            set $rs_2$ between interval $i_0$ and interval $i_2$ by using the
            relation set $rs_0$ between intervals $i_0$ and interval $i_1$, and
            relation set $rs_1$ between intervals $i_1$ and interval $i_2$ to
            complete the transitivity. In other words, the algorithm computes
            the following:

            \begin{vquote}
              $rs_2$ = $Trans_2$($rs_0$, $rs_1$)

              $rs_2$ = $Trans_2$(\{$BEF$, $MET$, $OVR$\}, \{$STA$, $FIN$\})
            \end{vquote}

            By referring to the transitivity table in Table \ref{table-trans},
            we note the following:

            \begin{vquote}
              $Trans_1$($BEF$, $STA$) = \{$BEF$\}

              $Trans_1$($BEF$, $FIN$) = \{$BEF$, $OVR$, $MET$, $DUR$, $STA$\}

              $Trans_1$($MET$, $STA$) = \{$MET$\}

              $Trans_1$($MET$, $FIN$) = \{$DUR$, $STA$, $OVR$\}

              $Trans_1$($OVR$, $STA$) = \{$OVR$\}

              $Trans_1$($OVR$, $FIN$) = \{$DUR$, $STA$, $OVR$\}
            \end{vquote}

            Therefore, as $Trans_2$() takes the union of all the relation sets
            returned by $Trans_1$(), we have:

            \begin{vquote}
              $rs_2$ = \{$BEF$, $OVR$, $MET$, $DUR$, $STA$\}
            \end{vquote}

            Finally, because $rs_2$ is a subset of $NET.Get$($i_0$, $i_2$), the
            algorithm replaces the arc between $i_0$ and $i_2$ with $rs_2$, as
            shown in Figure \ref{fig-net-ex-06}.

            \begin{figure}[tbhp]
              \begin{center}
                \includegraphics{net-06}
                \caption{Network after $NET.Add$($i_1$, $i_2$, \{$STA$, $FIN$\})}
                \label{fig-net-ex-06}
              \end{center}
            \end{figure}
          \end{vexample}

    \section{Extensions to Allen's Interval Algebra}

      In an authorisation system, an agent that enforces an authorisation
      policy must be able to match the policy's entities to objects observable
      by the agent, e.g. a subject in the policy is mapped to a user that logs
      in, or an object in the policy is mapped to a certain file in the
      filesystem. Similarly, an agent must also be able to map time intervals
      in a policy to events that are observable by the agent. For example,
      the interval {\em logged\_on} in the policy may be mapped to the time
      between a certain user logs in and out of the system.

      In certain situations, however, it is convenient to map intervals in the
      policy to a particular time scale, such as the agent's real time clock.
      These situations might arise when certain authorisations need to be
      granted or revoked at a certain time, instead of being triggered by
      observable events. To map policy intervals to real time, it is necessary
      to define them in terms of points in real time.

      In the previous section, we have shown that Allen's algebra defines
      temporal intervals as the primitive, where each interval is defined not
      by time points, but by their relationships with other intervals. In this
      section, we will attempt to show the extensions to the interval algebra
      to allow it to express intervals in terms of time points.

      \subsection{Time Points Revisited}

        By allowing time point definitions to be expressed in the algebra, we must
        formally define time points.

        Disregarding the relativistic effects of gravitation and velocity, we make the
        assumption that time is linear, absolute and universal. That is, time always
        flows in one direction: from past to future; that the passage of time as seen
        by one system is the same for any other system; and that all systems define
        time against a universal frame of reference. For simplicity, we further assume
        that time is not a continuous line, but is instead made up of discrete time
        points.

        As this definition goes against the more intuitive notion of continuous time
        lines, one might see the problem of events falling through the gaps between
        the discrete time points in the non-continuous time line.

        To go around this problem, we allow the time point granularity to be chosen
        arbitrarily. Ideally, for a specific application, one would choose a
        granularity that is at least as small as the smallest interval in that
        application. In practice, however, such choices are limited by implementing
        system's clock and other hardware and software latencies.

        In the light bulb and sunrise example in the previous section, if we
        choose a granularity of 1 second, then the switching on of a light bulb is an
        event that occurs at a specific time point. A granularity of 1 second,
        however, means that a sunrise is not an event but an interval, given the fact
        that in most parts of the world, the sun takes a few minutes to rise above the
        horizon. However, if we choose a granularity of 1 hour (and we do not
        live in the polar regions), a sunrise becomes an event that occurs at a single
        point in our chosen time scale. We can therefore argue that given a specific
        time granularity, some events can be treated as instantaneously occurring at a
        specific time point.

        Regardless of the granularity chosen, the domain of time points is the set of
        positive integers ${\mathbb Z}^{+}$.

      \subsection{Defining Intervals in Terms of Time Points}

        \begin{vdefinition}
          \label{def-interval}
          A {\bf well-defined interval} $i$ is an interval whose end points
          $i^{-}$ $\in$ ${\mathbb Z}^{+}$ and $i^{+}$ $\in$ ${\mathbb Z}^{+}$
          are defined, where $i^{-}$ $<$ $i^{+}$. A {\bf regular interval} is
          an interval whose end points are not known.
        \end{vdefinition}

        Under this definition, we can conclude that for any two well-defined
        intervals there is exactly one interval relation that holds between
        them. Algorithm \ref{algo-comp} shows a function that calculates this
        relation given the end points of two well-defined intervals.

        By using the $Compute$() function in Algorithm \ref{algo-comp}, we can
        now define a network operator, $NET.Bind$($I$, $I^-$, $I^+$), that
        assigns the end points $I^-$ and $I^+$ to the existing interval $I$ in
        the network. By allowing such end points to be defined for any
        interval, thereby making them well-defined intervals, we are also
        allowing the possibility of introducing new relations with this
        interval. Furthermore, any new relations gathered by comparing the end
        points of well-defined intervals are subject to the same propagation
        algorithms shown in the previous section. Algorithm \ref{algo-net-bind}
        shows how the $NET.Bind$() operator achieves this.

        \begin{valgorithm}[tbhp]{$Compute$()}{algo-comp}
FUNCTION \(Compute\)(\(i\sb{0}\sp{-}\), \(i\sb{0}\sp{+}\), \(i\sb{1}\sp{-}\), \(i\sb{1}\sp{+}\))
  IF \(i\sb{0}\sp{-}\) == \(i\sb{1}\sp{-}\) THEN
    IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{+}\) THEN
      RETURN \{\(equals\}\)
    ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{+}\) THEN
      RETURN \{\(starts\}\)
    ELSE
      RETURN \{\(started by\}\)
    ENDIF
  ELSE IF \(i\sb{0}\sp{-}\) < \(i\sb{1}\sp{-}\) THEN
    IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{+}\) THEN
      RETURN \{\(finished by\}\)
    ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{+}\) THEN
      IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{-}\) THEN
        RETURN \{\(meets\}\)
      ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{-}\) THEN
        RETURN \{\(before\}\)
      ELSE
        RETURN \{\(overlaps\}\)
      ENDIF
    ELSE
      RETURN \{\(contains\}\)
    ENDIF
  ELSE
    IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{+}\) THEN
      RETURN \{\(finishes\}\)
    ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{+}\) THEN
      RETURN \{\(during\}\)
    ELSE
      IF \(i\sb{0}\sp{-}\) == \(i\sb{1}\sp{+}\) THEN
        RETURN \{\(met by\}\)
      ELSE IF \(i\sb{0}\sp{-}\) < \(i\sb{1}\sp{+}\) THEN
        RETURN \{\(overlapped by\}\)
      ELSE
        RETURN \{\(after\}\)
      ENDIF
    ENDIF
  ENDIF
ENDFUNCTION
        \end{valgorithm}

        \begin{valgorithm}[tbhp]{$Net.Bind$()}{algo-net-bind}
FUNCTION \(NET.Bind\)(\(I\), \(I\sp{-}\), \(I\sp{+}\))
  FOR each interval \(I'\) \(\in\) \(NET\) DO
    IF \(I'\) != \(I\) THEN
      IF \(I'\) is well-defined THEN
        \(RS\) = \(Compute\)(\(I\sp{-}\), \(I\sp{+}\), \(I'\sp{-}\), \(I'\sp{+}\))
        \(NET.Add\)(\(I\), \(I'\), \(RS\))
      ENDIF
    ENDIF
  ENDDO
ENDFUNCTION
        \end{valgorithm}

      \subsection{Additional Network Operators}

        For the sake of completeness, we define an additional two network
        operators to complement those shown in Definition \ref{def-net-ops}
        and the $Net.Bind$() operator discussed in the previous section:

        \begin{itemize}
          \item
            $NET.Init$()

            The $NET.Init$() operator initialises or re-initialises the
            network. When executed, the operator causes all intervals and
            relations to be removed from the network.

          \item
            $NET.New$($I$)

            The $NET.New$() operator causes the given interval identifier $I$
            to be added to the network. As the network maintains complete
            information and since the new interval $I$ does not have any known
            relations with any interval in the network, the operator assigns
            the default relation between $I$ and every other interval in the
            network.
        \end{itemize}

    \section{Formalisation}

      In this section, we attempt to formalise a new language, ${\cal L^T}$,
      with the same expressive power as language ${\cal L}$ to represent
      authorisation policies, but with extensions to also express temporal
      constraints. Like language ${\cal L}$, language ${\cal L^T}$ is also a
      first-order logic language. As such, any language ${\cal L^T}$ policy
      can be translated into a normal logic program to derive answer sets,
      from which queries can be evaluated.

      \subsection{Syntax}

        \subsubsection{Components of Language ${\cal L^T}$}

          \begin{itemize}

            \item
              {\bf Identifiers}

                In language ${\cal L^T}$, there are 4 general types of
                identifiers:

                \begin{enumerate}
                  \item
                    {\em Entity Identifiers.}
                    As with language ${\cal L}$, language ${\cal L^T}$
                    includes six disjoint entity sorts: subject, access
                    rights, objects, subject groups, access right groups and
                    object groups. The syntax for each entity type is a single
                    lower case alpha character followed by zero or more
                    alphanumeric or underscore characters:

                    \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
                    \end{vverbatim}

                  \item
                    {\em Interval Identifiers.}
                    The main difference between language ${\cal L}$ and
                    language ${\cal L^T}$ is that in addition to the six
                    entity sorts, language ${\cal L^T}$ also includes an
                    additional time interval sort. As it occupies a different
                    name space from the other sorts, interval identifiers share
                    the same syntax.
      
                  \item
                    {\em Policy Update Identifiers.}
                    These identifiers are used as labels to name policy
                    updates. They occupy a different name space from other
                    identifiers and hence share the same syntax as entity and
                    interval identifiers.

                  \item
                    {\em Variable Identifiers.}
                    In language ${\cal L}$, variable identifiers are used to
                    represent entity identifiers. In contrast, language
                    ${\cal L^T}$ variable identifiers are used to represent
                    both entity and interval identifiers. The list below shows
                    the syntax of the different types of variable identifiers:

                    \begin{enumerate}
                      \item
                        Subject Variables

                        \begin{vverbatim}
  S[SG][a-zA-Z0-9\_]
                        \end{vverbatim}

                      \item
                        Access Right Variables

                        \begin{vverbatim}
  A[SG][a-zA-Z0-9\_]
                        \end{vverbatim}

                      \item
                        Object Variables

                        \begin{vverbatim}
  O[SG][a-zA-Z0-9\_]
                        \end{vverbatim}

                      \item
                        Interval Variables

                        \begin{vverbatim}
  I[a-zA-Z0-9\_]
                        \end{vverbatim}

                    \end{enumerate}
                \end{enumerate}

            \item
              {\bf Authorisation Atoms, Facts and Expressions}

              Authorisation atoms of language ${\cal L^T}$ are similar to the
              to the atoms of language ${\cal L}$, except each atom includes
              an interval parameter that indicates the time at which that atom
              holds. As with language ${\cal L}$, there are three types of
              atoms:

              \begin{enumerate}
                \item
                  {\em Holds Atom.} The syntax below shows an atom that states
                  that subject $sub$-$id$ holds the access right $acc$-$id$ for
                  object $obj$-$id$ at time interval $int$-$id$.

                  \begin{vverbatim}
  holds(<sub-id>,
        <acc-id>,
        <obj-id>,
        <int-id>)
                  \end{vverbatim}

                \item
                  {\em Member Atom.} The syntax shown below is that of an atom
                  that states that the single entity $single$-$id$ is a member
                  of the group entity $group$-$id$ for the duration specified
                  by interval $int$-$id$.

                  \begin{vverbatim}
  memb(<single-id>, <group-id>, <int-id>)
                  \end{vverbatim}

                \item
                  {\em Subset Atom.} Below is the syntax of an atom that states
                  that the group entity $group$-$id$-$0$ is a subset of the
                  group entity $group$-$id-$-$1$ at time interval $int$-$id$.

                  \begin{vverbatim}
  subst(<group-id-0>, <group-id-1>, <int-id>)
                  \end{vverbatim}
              \end{enumerate}

              Like language ${\cal L}$, language ${\cal L^T}$ facts state
              that relationship represented by the corresponding atom its
              negation (as indicated by the "!" character prefix) holds.

              An expression is either a fact or a conjunction of facts
              separated by the comma "," character. An atom, fact or expression
              composed entirely of entity and interval identifiers (no
              variables) are called ground atoms, facts or expressions,
              respectively.

            \item
              {\bf Interval Atoms and Expressions}

              Noting the fact that the inverse relation between any intervals
              $i_0$ and $i_1$ is equal to the relation between intervals
              $i_1$ and $i_0$, for the sake of brevity, language ${\cal L^T}$
              defines only 7 out of the 13 interval relations in the algebra.
              These relations, together with two interval identifiers make up
              the language's interval atoms:

              \begin{vverbatim}
  <rel-id>(<int-id-0>, <int-id-1>)
              \end{vverbatim}

              where $rel$-$id$ indicates the relation between interval
              $int$-$id$-$0$ and interval $int$-$id$-$1$, and is one of the
              following: $equals$, $before$, $during$, $overlaps$, $meets$,
              $starts$ or $finishes$.

              An interval expression in language ${\cal L^T}$ is a group
              of interval atoms separated by the comma "," character. As the
              interval algebra allows disjunctions, the meaning of the comma
              within an interval expression may be conjunctive or disjunctive.
              If an interval expression contains two atoms that differ only by
              their relation (meaning the interval pairs are the same), then
              the comma between these atoms indicates a logical {\em or}.
              Commas between other interval atoms indicate a logical {\em and}.
              For example, the following interval expression is interpreted as
              "interval $i_0$ is before or after interval $i_1$ and interval
              $i_2$ is during interval $i_0$":

              \begin{vverbatim}
  before(i0, i1), before(i1, i0), during(i2, i0)
              \end{vverbatim}

              Like their authorisation counterparts, interval atoms and
              expressions that do not have variable identifiers are called
              ground interval atoms and expressions.

          \end{itemize}

        \subsubsection{Identifier Declarations}

          In language ${\cal L^T}$, both entity and interval identifiers must
          be declared before they are used anywhere in the program. The syntax
          for declaring entity identifiers in language ${\cal L^T}$ is the same
          as the syntax in language ${\cal L}$:

          \begin{vverbatim}
  entity sub|acc|obj[-grp] <ent-id>[, ...];
          \end{vverbatim}

          Interval identifiers may be declared with or without end points. Note
          that once intervals are assigned end points, they are bound to those
          end points for the lifetime of the program. End points, if declared
          with an interval identifier, must be a positive integer as indicated
          in the following syntax:

          \begin{vverbatim}
  interval <int-id> [\(\backslash\)[ep0, ep1\(\backslash\)]][, ... ];
          \end{vverbatim}

          \noindent
          where $ep_0$ $\in$ ${\mathbb Z}^+$, $ep_1$ $\in$ ${\mathbb Z}^+$ and
          $ep_0$ $<$ $ep_1$.

        \subsubsection{Initial Fact Declarations}

          Like language ${\cal L}$, language ${\cal L^T}$ allows the
          declaration of initial state facts. Ground facts declared in this
          manner hold until a policy update causes them to be otherwise. Syntax
          is as follows:

          \begin{vverbatim}
  initially <gnd-auth-exp>;
          \end{vverbatim}

        \subsubsection{Interval Constraint Declarations}

          Relations between intervals are expressed in language ${\cal L^T}$
          through interval constraints. Interval relations defined by interval
          constraints hold for the entire lifetime of the program. Such
          relations in the form of a ground interval expression may be declared
          in the following manner:

          \begin{vverbatim}
  relation <gnd-int-exp>;
          \end{vverbatim}

          The example below declares an interval constraint that states that
          interval $i_0$ is $before$ or $starts$ interval $i_1$, interval $i_1$
          is $during$ or $meets$ interval $i_2$, and interval $i_2$ $meets$
          interval $i_3$:

          \begin{vverbatim}
  relation
    before(i0, i1),
    starts(i0, i1),
    during(i1, i2),
    meets(i1, i2),
    meets(i2, i3);
          \end{vverbatim}

        \subsubsection{Authorisation Constraint Declarations}

          Like the constraint declarations in language ${\cal L}$,
          authorisation constraint declarations in language ${\cal L^T}$ are
          used to define logical rules that always holds, even after a policy
          update is applied. The difference, as shown by the syntax below, is
          the addition of the {\em where} clause.

          \begin{vverbatim}
  always <auth-exp-0>
    [implied by <auth-exp-1>]
    [with absence <auth-exp-2>]
    [where <int-exp>];
          \end{vverbatim}

          The meaning of the statement is essentially the same as its language
          ${\cal L}$ counterpart: expression $auth$-$exp$-$0$ holds if
          expression $auth$-$exp$-$1$ holds and there is no evidence that
          expression $auth$-$exp$-$2$ holds. Any variables occurring in
          any of these expressions are grounded to all defined entities and
          interval identifiers.

          The {\em where} clause is used to define an interval expression
          $int$-$exp$ which is used to place a restriction on the interval
          identifiers used to ground interval variables occurring in the
          authorisation expressions. Only those sets of interval identifiers
          that satisfy the expression $int$-$exp$ is used to replace the
          set of interval variables in the authorisation expressions. As the
          {\em where} clause is used in the grounding of variables, it is
          important to note that it does not make sense to have a ground
          interval expression in the {\em where} clause. Furthermore, not only
          does the expression $int$-$exp$ need to be non-ground, but every atom
          in this expression must also be non-ground.

          For example, given the following authorisation constraint
          declaration:

          \begin{vverbatim}
  always holds(SS, a, o, I0)
    implied by memb(SS, SG0, I1)
    with absence !memb(SS, SG1, I1)
    where starts(I0, I1);
          \end{vverbatim}

          \noindent
          Assuming that \{$ss_0$, $ss_1$\} is the set of single subjects,
          \{$sg_0$, $sg_1$\} is the set of group subjects and \{$i_0$, $i_1$,
          $i_2$\} is the set of intervals defined, with interval $i_0$ $during$
          interval $i_1$ and interval $i_1$ $start$ing interval $i_2$, the
          statement is equivalent to the following statements:

          \begin{vverbatim}
  always holds(ss0, a, o, i1)
    implied by memb(ss0, sg0, i2)
    with absence !memb(ss0, sg1, i2);

  always holds(ss1, a, o, i1)
    implied by memb(ss1, sg0, i2)
    with absence !memb(ss1, sg1, i2);

  always holds(ss0, a, o, i1)
    implied by memb(ss0, sg1, i2)
    with absence !memb(ss0, sg0, i2);

  always holds(ss1, a, o, i1)
    implied by memb(ss1, sg1, i2)
    with absence !memb(ss1, sg0, i2);
          \end{vverbatim}

          Although the entity variables $SS$, $SG_0$ and $SG_1$ are grounded
          to every entity that matches their respective types, the interval
          variables $I_0$ and $I_1$ are restricted to the intervals $i_1$ and
          $i_2$, respectively, because they are the only interval pair that
          satisfies the restriction placed by the {\em where} clause.

        \subsubsection{Policy Update Declarations}

          Like the authorisation constraint definition, policy update
          definitions of language ${\cal L^T}$ are similar to those of language
          ${\cal L}$, but with the extra {\em where} clause to limit the
          interval identifiers that are used to ground interval variables that
          may occur in authorisation expressions.

          The syntax below describes the declaration of a policy update
          $update$-$id$ which, when applied, causes the expression
          $auth$-$exp$-$0$ to hold if the expression $auth$-$exp$-$1$ already
          holds.

          \begin{vverbatim}
  <update-id>([<ent-var-0>[, ...]])
    causes <auth-exp-0>
    [if <auth-exp-1>]
    [where <int-exp>];
          \end{vverbatim}

          When a policy update is applied, entity identifiers are supplied for
          each entity variable $ent$-$var$-$n$. These entity identifiers are
          used to ground any matching entity variables that may occur in either
          authorisation expressions $auth$-$exp$-$0$ or $auth$-$exp$-$1$.
          Entity variables occurring in these expressions that do not match
          the variables in the variable list $ent$-$var$-$n$ are replaced by
          all defined entity identifiers that match the variable types.
          Interval variables occurring in the authorisation expressions are
          grounded to sets of interval identifiers that satisfy the interval
          expression $int$-$exp$.

        \subsubsection{Policy Update Directives}

          The policy update directives in language ${\cal L^T}$, like those
          in language ${\cal L}$, are used to manipulate the policy update
          sequence list.

          The three directives below are for adding a policy update into the
          update sequence list, removing an update from the update sequence
          list, and showing the contents of the update sequence list,
          respectively.

          \begin{vverbatim}
  seq add <upd-id>([<id-0>[, ...]]);
  seq del <n>;
  seq list;
          \end{vverbatim}

          The directive is used to apply policy updates one at a time in the
          order in which they appear in the update sequence list.

          \begin{vverbatim}
  compute;
          \end{vverbatim}

        \subsubsection{Query Directives}

          A ground query expression may be given to the system for evaluation.
          The syntax is as follows:

          \begin{vverbatim}
  query <gnd-auth-exp>;
          \end{vverbatim}

          Queries are evaluated against the policy base state derived from the
          application of policy updates in the update sequence list. The system
          response for each query directive either {\em true}, {\em false} or
          {\em unknown}.

        \begin{vexample}
          \label{ex-4-2}
          The example code below shows a full language ${\cal L^T}$ policy
          description. In this policy, three intervals are defined:
          $work\_hours$, $morning\_hours$ and $afternoon\_hours$, where
          $worh\_hours$ starts at 9:00 AM and ends at 5:00 PM. Furthermore,
          the interval constraint in the policy states that $morning\_hours$
          either {\em starts} or is {\em during} $work\_hours$,
          $afternoon\_hours$ either {\em finishes} or is {\em during}
          $work\_hours$, and $morning\_hours$ is {\em before}
          $afternoon\_hours$.

          The authorisation constraint states that for all defined intervals
          $I0$, if $grp1$ holds the $read$ access right to $file$ at interval
          $I0$, and there is no evidence that $grp3$ does not hold the $write$
          access right to $file$ at interval $I0$, then $grp1$ holds the
          $write$ access right to $file$ at interval $I0$.

          The policy update $delete\_read$ definition states that when applied,
          the update will cause some subject group $SG0$ to lose the $read$
          access right to some object $OS0$ at all intervals $I0$ that either
          {\em starts} or is {\em during} the interval $work\_hours$.

          \begin{vverbatim}
  /* entity declarations */

  entity sub alice;
  entity sub-grp grp1, grp2, grp3;
  entity acc read, write;
  entity obj file;

  /* interval declarations */

  interval work\_hours [0900, 1700];
  interval morning\_hours;
  interval afternoon\_hours;

  /* initial fact statements */

  initially
    memb(alice, grp2, work\_hours),
    subst(grp2, grp1, morning\_hours),
    holds(grp1, read, file, work\_hours);

  /* interval constraints */

  relation
    during(morning\_hours, work\_hours),
    starts(morning\_hours, work\_hours);

  relation
    during(afternoon\_hours, work\_hours),
    finishes(afternoon\_hours, work\_hours);

  relation
    before(morning\_hours, afternoon\_hours);

  /* authorisation constraints */

  always holds(grp1, write, file, I0)
    implied by
      holds(grp1, read, file, I0)
    with absence
      !holds(grp3, write, file, I0);

  /* policy update definition */

  delete\_read(SG0, OS0)
    causes
      !holds(SG0, read, OS0, I0)
    where
      starts(work\_hours, I0),
      during(work\_hours, I0);

  /* add delete\_read to policy update sequence list */

  seq add delete_read(grp1, file);

  compute;

  /* queries */

  query holds(grp1, write, file, morning\_hours);
  query holds(grp1, read, file, morning\_hours);
  query holds(alice, write, file, morning\_hours);
  query holds(alice, read, file, morning\_hours);
          \end{vverbatim}
        \end{vexample}

      \subsection{Semantics}

        The domain description ${\cal D_{L^T}}$ of language ${\cal L^T}$ is
        a finite set of intervals with end points, initial state facts,
        temporal constraint rules, authorisation constraint rules, policy
        update definitions and an ordered set $\psi$ of policy update
        references.

        Like language ${\cal L}$, the semantics of language ${\cal L^T}$ is
        best described by its translation into an extended logic program,
        language ${\cal L^{T^*}}$. Formally, given a domain description
        ${\cal D_{L^T}}$ of language ${\cal L^T}$, the translation is denoted
        by $Trans$(${\cal D_{L^T}}$).

        The main difference between language ${\cal L^T}$ and language
        ${\cal L^{T^*}}$ is that each atom of the latter also specifies the
        policy update state in which it holds. Another difference between the
        two languages is that the temporal constraints of language ${\cal L^T}$
        is not directly expressed in language ${\cal L^{T^*}}$. Instead, the
        interval algebra discussed at the beginning of this chapter is used by
        the translation process to generate the appropriate authorisation rules
        with respect to the given temporal constraints.

        Before the translation process can be shown, we must first provide
        a formal definition of language ${\cal L^{T^*}}$.

        \subsubsection{Language ${\cal L^{T^*}}$}

          As hinted above, language ${\cal L^{T^*}}$ is an extended logic
          program which is composed of facts and rules that expresses an
          authorisation policy. The following are the components of the
          language:

          \begin{itemize}
            \item
              {\bf Entities}

              Like language ${\cal L^*}$, language ${\cal L^{T^*}}$ defines
              a set ${\cal E}$ that contains all the defined subject, access
              right and object (both singles and groups) entities. In addition
              to this set, we also define all its subsets: single subject
              ${\cal E}_{ss}$, single access right ${\cal E}_{as}$, single
              object ${\cal E}_{os}$, group subject ${\cal E}_{sg}$, group
              access right ${\cal E}_{ag}$, group object ${\cal E}_{og}$,
              single and group subjects ${\cal E}_{s}$, single and group access
              rights ${\cal E}_{a}$, and single and group objects
              ${\cal E}_{o}$.

            \item
              {\bf Intervals}

              Language ${\cal L^{T^*}}$ defines a set ${\cal I}$ that contains
              all the defined time intervals from ${\cal D_{L^T}}$.

            \item
              {\bf Atoms}

              A language ${\cal L^{T^*}}$ atom is a binding of a set of
              entities, a temporal interval and a state. The set
              ${\cal A}^\sigma$ contains all the atoms of state $\sigma$.
              The sets ${\cal A}^{\sigma}_{h}$, ${\cal A}^{\sigma}_{m}$ and
              ${\cal A}^{\sigma}_{h}$ denotes all $holds$, $member$ and
              $subset$ atoms of state $\sigma$, respectively, where
              ${\cal A}^\sigma$ = ${\cal A}^{\sigma}_{h}$ $\cup$
              ${\cal A}^{\sigma}_{m}$ $\cup$ ${\cal A}^{\sigma}_{s}$. The
              definitions of these subsets are shown below. To distinguish
              between the atoms of the two languages, atoms of language
              ${\cal L^{T^*}}$ are written with the hat character.

              \begin{vquote}
                ${\cal A}^{\sigma}_{h}$ =
                  $\{\hat{holds}$($s$, $a$, $o$, $\iota$, $\sigma$) $\mid$
                  $s$ $\in$ ${\cal E}_{s}$,
                  $a$ $\in$ ${\cal E}_{a}$,
                  $o$ $\in$ ${\cal E}_{o}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{m}$ =
                  ${\cal A}^{\sigma}_{ms}$ $\cup$
                  ${\cal A}^{\sigma}_{ma}$ $\cup$
                  ${\cal A}^{\sigma}_{mo}$

                ${\cal A}^{\sigma}_{s}$ =
                  ${\cal A}^{\sigma}_{ss}$ $\cup$
                  ${\cal A}^{\sigma}_{sa}$ $\cup$
                  ${\cal A}^{\sigma}_{so}$

                ${\cal A}^{\sigma}_{ms}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{ss}$,
                  $g$ $\in$ ${\cal E}_{sg}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{ma}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{as}$,
                  $g$ $\in$ ${\cal E}_{ag}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{mo}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{os}$,
                  $g$ $\in$ ${\cal E}_{og}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{ss}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{sg}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{sa}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{ag}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{so}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{og}$,
                  $\iota$ $\in$ ${\cal I}\}$
              \end{vquote}

            \item
              {\bf Facts}

              The definition below states that a fact $\hat{\rho}^\sigma$ is a
              logical statement that asserts that an atom $\hat{\alpha}$ either
              holds or does not hold at a given state $\sigma$.

              \begin{vquote}
                $\hat{\rho}^{\sigma}$ =
                  $[\lnot]$$\hat{\alpha}$

                where
                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$
              \end{vquote}

            \item
              {\bf Expressions}

              A language ${\cal L^{T^*}}$ expression is a conjunction of
              facts separated by the comma character. The expression below
              asserts that where $0$ $\leq$ $i$ $\leq$ $n$, each fact
              $\hat{\rho}_i$ holds:

              \begin{vquote}
                $\hat{\rho}_0$,
                $\hat{\rho}_1$,
                $\ldots$,
                $\hat{\rho}_n$,
              \end{vquote}

          \end{itemize}

        \subsubsection{Translating Language ${\cal L^T}$ to Language ${\cal L^{T^*}}$}

          Unlike the translation of language ${\cal L}$ to language
          ${\cal L^*}$, not all statements of language ${\cal L^T}$ is
          translated to language ${\cal L^{T^*}}$. In particular, as language
          ${\cal L^{T^*}}$ does not express relationships between temporal
          intervals, all language ${\cal L^T}$ statements that denote these
          relationships are not directly translated. Through the use of Allen's
          interval algebra, the authorisation rules that result from the
          consequences of these temporal relations are generated instead.

          To describe the details of the translation $Trans$(${\cal D_{L^T}}$),
          we first define some translation functions similar to
          [XXX ref to ${\cal L}$].

          \begin{itemize}

            \item
              The $Res$($u$, $\sigma$) function takes as input a policy update
              $u$ $\in$ $\psi$ and a policy state $\sigma$, and returns the
              policy state that results from applying the update $u$ upon
              state $\sigma$.

            \item
              The $CopyAtom$($\hat{\alpha}$, $\sigma$) function takes as input
              an atom $\hat{\alpha}$ of language ${\cal L^{T^*}}$ and some
              state $\sigma$, then returns an atom with the same type and with
              the same entities and interval as atom $\hat{\alpha}$, but with
              state $\sigma$ instead of the original state specified by
              $\hat{\alpha}$.

            \item
              The $TransAtom$($\alpha$, $\sigma$) function takes as input an
              atom $\alpha$ of language ${\cal L^T}$ and some state $\sigma$,
              then returns an equivalent atom of language ${\cal L^{T^*}}$
              with the same entities and interval specified by $\alpha$.

            \item
              The $TransFact$($\rho$, $\sigma$) function is similar to the
              $TransAtom$ function, but instead of translating an atom, it
              takes a language ${\cal L^T}$ fact $\rho$ and some state $\sigma$
              then returns the equivalent language ${\cal L}^{T^*}$ fact.
          \end{itemize}

          With these functions defined, we can now outline the translation
          process:

          \begin{itemize}

            \item
              {\bf Initialising the Temporal Interval Relation Network}

              The first step in the translation is to initialise the interval
              relation network with all the temporal intervals and all the
              given end points defined in language ${\cal L^T}$. Recall that
              there are two ways a temporal interval may be declared in
              language ${\cal L^T}$:

              \begin{vverbatim}
  interval \(\iota\);
  interval \(\iota\) [\(ep\sb{0}\), \(ep\sb{1}\)];
              \end{vverbatim}

              All intervals $\iota$ declared by using the first form are added
              to the interval network through a call to the following function:

              \begin{vquote}
                $NET.New$($\iota$)
              \end{vquote}

              All intervals $\iota$ declared by using the second form, i.e.,
              with end points $ep_0$ and $ep_1$, are added to the network
              through the following functions:

              \begin{vquote}
                $NET.New$($\iota$)

                $NET.Bind$($\iota$, $ep_0$, $ep_1$)
              \end{vquote}

            \item
              {\bf Populating the Temporal Interval Relation Network}

              The next step is to encode all temporal constraints in
              language ${\cal L^T}$ as interval relations in the interval
              relation network. Temporal constraints are declared in language
              ${\cal L^T}$ in the following way:

              \begin{vverbatim}
  relation \(\alpha\sb{0}\), \(\ldots\), \(\alpha\sb{n}\);
              \end{vverbatim}

              Note that each interval atom ${\alpha}_i$ above is in the form
              $r_i$(${\iota}0_i$, ${\iota}1_i$), where $r_i$ $\in$ \{$equals$,
              $before$, $\ldots$\}, ${\iota}0_i$, ${\iota}1_i$ $\in$
              ${\cal I}$ and $0$ $\leq$ $i$ $\leq$ $n$. We further note that
              under this notation, it is possible to encounter a situation
              where two different interval atoms ${\alpha}_i$ and ${\alpha}_j$
              can both contain the same pair of intervals:

              \begin{vquote}
                ${\alpha}_i$ $=$ $r_i$(${\iota}0_i$, ${\iota}1_i$)

                ${\alpha}_j$ $=$ $r_j$(${\iota}0_j$, ${\iota}1_j$)

                where

                \hspace{1em}
                $i$ $\neq$ $j$,

                \hspace{1em}
                $r_i$ $\neq$ $r_j$,

                \hspace{1em}
                ${\iota}0_i$ $=$ ${\iota}0_j$,

                \hspace{1em}
                ${\iota}1_i$ $=$ ${\iota}1_j$
              \end{vquote}

              According to the syntax definition of interval atoms in the
              previous section, in any given interval expression, all interval
              atom pairs that satisfies the above condition are to be treated
              as disjunctions in that expression, while those that do not are
              to be treated as conjunctions.

              For simplicity, we introduce a normalised notation for interval
              expressions where each interval atom in the expression contains a
              unique pair of intervals and a set of relations that hold between
              those intervals. Formally, a normalised interval expression is
              in the following form:

              \begin{vquote}
                ${\alpha}_0$, $\ldots$, ${\alpha}_n$
              \end{vquote}

              \noindent
              where each interval atom ${\alpha}_i$ ($0$ $\leq$ $i$ $\leq$ $n$)
              in the form:

              \begin{vquote}
                ${\alpha}_i$ =
                  (${\iota}0_i$, ${\iota}1_i$, \{$r0_i$, $\ldots$, $rx_i$\})
              \end{vquote}

              \noindent
              satisfies the following condition:

              \begin{vquote}
                $\lnot$$\exists$${\alpha}_j$,

                where

                \hspace{1em}
                ${\alpha}_j$ =
                  (${\iota}0_j$, ${\iota}1_j$, \{$r0_j$, $\ldots$, $ry_j$\})

                \hspace{1em}
                $0$ $\leq$ $j$ $\leq$ $n$,

                \hspace{1em}
                $i$ $\neq$ $j$

                such that

                \hspace{1em}
                ${\iota}0_i$ $=$ ${\iota}0_j$,

                \hspace{1em}
                ${\iota}1_i$ $=$ ${\iota}1_j$
              \end{vquote}

              Now, we define a function $Normalise$($\varepsilon$) that takes
              a language ${\cal L^T}$ interval expression $\varepsilon$ as
              input and returns the normalised equivalent of that expression in
              the form shown above. Formally, we have:

              \begin{vquote}
                ${\varepsilon}'$ $=$ $Normalise$($\varepsilon$)
              \end{vquote}

              \noindent
              For each
              (${\iota}0_i$, ${\iota}1_i$, \{$r0_i$, $\ldots$, $rx_i$\})
              $\in$ ${\varepsilon}'$,
              where $0$ $\leq$ $i$ $<$ $|{\varepsilon}'|$, the following
              conditions are satisfied:

              \begin{itemize}
                \item
                  For each $r_j$ $\in$ \{$r0_i$, $\ldots$, $rx_i$\}, where $0$
                  $\leq$ $j$ $\leq$ $i$, there exists an
                  $r_j$(${\iota}0_i$, ${\iota}1_i$) $\in$ $\varepsilon$

                \item
                  For each
                  (${\iota}0_j$, ${\iota}1_j$, \{$r0_j$, $\ldots$, $ry_j$\})
                  $\in$ ${\varepsilon}'$, where $0$ $\leq$ $j$ $<$
                  $|{\varepsilon}'|$ and $i$ $\neq$ $j$,
                  (
                    ${\iota}0_i$ $\neq$ ${\iota}0_j$ $\lor$
                    ${\iota}1_i$ $\neq$ ${\iota}1_j$
                  )
              \end{itemize}

              With the $Normalise$() function defined, we can now populate the
              interval relation network with relations expressed in language
              ${\cal L^T}$ interval constraint statements. The steps involved
              to achieve this is as follows. For each interval constraint
              statement in language ${\cal L^T}$:

              \begin{vverbatim}
  relation \(\alpha\sb{0}\), \(\ldots\), \(\alpha\sb{n}\);
              \end{vverbatim}

              Now, by using the $Normalise$() function, we obtain a normalised
              expression $\varepsilon$:

              \begin{vquote}
                $\varepsilon$ $=$
                  $Normalise$(\{${\alpha}_0$, $\ldots$, ${\alpha}_n$\})
              \end{vquote}

              Finally, to register the interval constraint to the interval
              relation network, we make a call to the following operator
              for each (${\iota}0_i$, ${\iota}1_i$, $rs_i$) $\in$
              $\varepsilon$, where $0$ $\leq$ $i$ $<$ $|\varepsilon|$:

              \begin{vverbatim}
  \(NET.Add\)(\({\iota}0\sb{i}\), \({\iota}1\sb{i}\), \(rs\sb{i}\))
              \end{vverbatim}

            \item
              {\bf Variable Grounding}

              As language ${\cal L^{T^*}}$ does not allow variables, all
	      language ${\cal L^T}$ expressions containing entity or interval
              variables must be grounded in the translation process. Although
              the task of grounding entity variables is a relatively
              straightforward procedure, grounding interval variables involves
              additional steps due to the {\em where} clause of the language.
              After generating the tuples to replace the variables, each of
              these tuples must also be checked to ensure that they satisfy
              any given temporal constraints.

              Before we can describe the grounding process in greater detail,
              we first define the following three functions:

              \begin{itemize}
                \item
                  $Type$($ev$)

                  The $Type$($ev$) function returns the type of the given
                  entity or variable $ev$: $interval$, $single$-$subject$,
                  $group$-$subject$, $single$-$access$-$right$, etc.

                \item
                  $Var$($\varepsilon$)

                  Given a non-ground language ${\cal L^T}$ authorisation or
                  interval expression $\varepsilon$, this function returns
                  a set of unique variables that occurs in $\varepsilon$. If
                  $\varepsilon$ is ground, the function returns $\emptyset$.

                \item
                  $Replace$($\varepsilon$, $V$, $t$)

                  The function takes the following as input: a non-ground
                  language ${\cal L^T}$ authorisation or interval expression
                  $\varepsilon$, a set of variables $V$ that occur in
                  $\varepsilon$, and a tuple $t$ containing entities and
                  intervals that correspond to the variables in $V$ ($|V|$ $=$
                  $|t|$ and $\forall$$i$, $0$ $\leq$ $i$ $<$ $|V|$,
                  $Type$($V_i$) $=$ $Type$($t_i$)). The function returns
                  $\varepsilon$ with all variable occurences replaced with the
                  corresponding entities or intervals from $t$. If
                  $\varepsilon$ is a ground expression, $\varepsilon$ is
                  returned.
              \end{itemize}

              With these functions defined, we can now generalise the process
              of grounding both entity and interval variables. Given a set $V$
              of unique entity and interval variables, the function below
              returns a set of all possible $|V|$-tuples that can be used to
              replace the variables in $V$:

              \begin{vquote}
                $GenTuples_1$($V$) $=$
                $R_0$ $\times$ $\ldots$ $\times$ $R_{|V|-1}$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\forall$ $i$, $0$ $\leq$ $i$ $<$ $|V|$,

                \hspace{1em}
                $R_i$ $=$
                \begin{math}
                  \begin{cases}
                    \mbox{${\cal E}_s$, if $Type$($V_i$) $=$ {\em subject}} \\
                    \mbox{${\cal E}_a$, if $Type$($V_i$) $=$ {\em access right}} \\
                    \vdots \\
                    \mbox{${\cal I}$, if $Type$($V_i$) $=$ {\em interval}}
                  \end{cases}
                \end{math}
              \end{vquote}

              A variation of this function, shown below, generates tuples
              with respect to a given temporal constraint. Given a language
              ${\cal L^T}$ {\em where} clause with an interval expression
              $\varepsilon$ and a set $V$ of variables that occur in
              $\varepsilon$, the following function returns a set of
              $|V|$-tuples, where each tuple satisfies the condition given
              in $\varepsilon$:

              \begin{vquote}
                $GenTuples_2$($\varepsilon$, $V$)
                $=$ \{$t_0$, $\ldots$, $t_{|V|-1}$\}
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\forall$ $i$, $0$ $\leq$ $i$ $<$ $|V|$,
                $t_i$ $\in$ $GenTuples_1$($V$),

                \hspace{1em}
                $\varepsilon'$ $=$
                $Normalise$($Replace$($\varepsilon$, $V$, $t_i$)),

                \hspace{1em}
                $\forall$ (${\iota}_0$, ${\iota}_1$, $rs$) $\in$
                $\varepsilon'$,
                $NET.Get$(${\iota}_0$, ${\iota}_1$) $\subseteq$ $rs$
              \end{vquote}

            \item
              {\bf Initial Fact Rules}

              The initial fact rules are obtained directly from initial fact
              declaration statements of language ${\cal L^T}$:

              \begin{vverbatim}
  initially \(\rho\sb{0}\), \(\ldots\), \(\rho\sb{n}\);
              \end{vverbatim}

              Each initial fact declaration statement of language ${\cal L^T}$
              in the form above corresponds to the following language
              ${\cal L^{T^*}}$ rules:

              \begin{vquote}
                $\hat{\rho_i}$ $\leftarrow$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{\rho_i}$ $=$ $TransFact$($\rho_i$, $S_0$),

                \hspace{1em}
                $0$ $\leq$ $i$ $\leq$ $n$
              \end{vquote}

            \item
              {\bf Authorisation Constraint Rules}

              An authorisation constraint statement in language ${\cal L^T}$
              is in the form:

              \begin{vverbatim}
  always \(\rho\sb{0\sb{0}}\), \(\ldots\), \(\rho\sb{0\sb{n\sb{0}}}\)
    implied by \(\rho\sb{1\sb{0}}\), \(\ldots\), \(\rho\sb{1\sb{n\sb{1}}}\)
    with absence \(\rho\sb{2\sb{0}}\), \(\ldots\), \(\rho\sb{2\sb{n\sb{2}}}\)
    where \(r\sb{0}\), \(\ldots\), \(r\sb{n\sb{3}}\);
              \end{vverbatim}

              The first step is to gather all the entity and interval
              variables that occur in all the expressions above into a set $V$:

              \begin{vquote}
                $V$ $=$
                $Var$(($\rho_{0_0}$, $\ldots$, $\rho_{0_{n_0}}$)) $\cup$
                $Var$(($\rho_{1_0}$, $\ldots$, $\rho_{1_{n_1}}$)) $\cup$
                $Var$(($\rho_{2_0}$, $\ldots$, $\rho_{2_{n_2}}$))
              \end{vquote}

              \noindent
              Using the set $V$, we generate a set of tuples $T$ that satisfies
              the temporal constraint specified by the {\em where} clause:

              \begin{vquote}
                $T$ $=$ $GenTuples_2$(($r_0$, $\ldots$, $r_{n_3}$), $V$)
              \end{vquote}

              \noindent
              Finally, the language ${\cal L^{T^*}}$ equivalent of the
              authorisation constraint rule is the following rules:

              \begin{vquote}
                $\forall$ ($t$, $\sigma$),
              \end{vquote}

              \begin{vquote}
                $\hat{\rho}^{\sigma}_{0_0}$ $\leftarrow$
                $\hat{\rho}^{\sigma}_{1_0}$, \ldots, $\hat{\rho}^{\sigma}_{1_{n_1}}$,
                $not$ $\hat{\rho}^{\sigma}_{2_0}$, \ldots, $not$ $\hat{\rho}^{\sigma}_{2_{n_2}}$

                $\vdots$

                $\hat{\rho}^{\sigma}_{0_{n_0}}$ $\leftarrow$
                $\hat{\rho}^{\sigma}_{1_0}$, \ldots, $\hat{\rho}^{\sigma}_{1_{n_1}}$,
                $not$ $\hat{\rho}^{\sigma}_{2_0}$, \ldots, $not$ $\hat{\rho}^{\sigma}_{2_{n_2}}$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{\rho}^{\sigma}_{0_i}$ =
                $TransFact$($Replace$($\rho_{0_i}$, $V$, $t$), $\sigma$),
                $0$ $\leq$ $i$ $\leq$ $n_0$,

                \hspace{1em}
                $\hat{\rho}^{\sigma}_{1_j}$ =
                $TransFact$($Replace$($\rho_{1_j}$, $V$, $t$), $\sigma$),
                $0$ $\leq$ $j$ $\leq$ $n_1$,

                \hspace{1em}
                $\hat{\rho}^{\sigma}_{2_k}$ =
                $TransFact$($Replace$($\rho_{1_k}$, $V$, $t$), $\sigma$),
                $0$ $\leq$ $k$ $\leq$ $n_2$,

                \hspace{1em}
                $t$ $\in$ $T$,

                \hspace{1em}
                $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
              \end{vquote}

            \item
              {\bf Policy Update Rules}

              Obviously, only language ${\cal L^T}$ policy update statements
              that are applied to the policy are actually translated to
              language ${\cal L^{T^*}}$ rules. The translation process for
              these rules are again similar to that of language ${\cal L^*}$,
              except this time, the variable grounding is subject to the
              constraints specified by the {\em where} clause. A language
              ${\cal L^T}$ policy update statement is shown below:

              \begin{vverbatim}
  \(u\) causes \(\rho\sb{0\sb{0}}\), \(\ldots\), \(\rho\sb{0\sb{n\sb{0}}}\)
    if \(\rho\sb{1\sb{0}}\), \(\ldots\), \(\rho\sb{1\sb{n\sb{1}}}\)
    where \(r\sb{0}\), \(\ldots\), \(r\sb{n\sb{2}}\);
              \end{vverbatim}

              \noindent
              Like the authorisation constraint rules, the first step in the
              translation process is to generate a set $V$ of entity and
              interval variables that occur in all the expressions:

              \begin{vquote}
                $V$ $=$
                $Var$($\rho_{0_0}$, $\ldots$, $\rho_{0_{n_0}}$) $\cup$
                $Var$($\rho_{1_0}$, $\ldots$, $\rho_{1_{n_1}}$)
              \end{vquote}

              \noindent
              With the variable set $V$ and a {\em where} clause expression
              ($r_0$, $\ldots$, $r_{n_2}$), a set of tuples $T$ can be
              generated such that each tuple $t$ $\in$ $T$ satisfies the
              {\em where} clause constraint:

              \begin{vquote}
                $T$ $=$
                $GenTuples_2$(($r_0$, $\ldots$, $r_{n_2}$), $V$)
              \end{vquote}

              \noindent
              By using the entities and intervals in each tuple in set $T$
              to ground all the variables, we can now define the policy
              update rules in language ${\cal L^{T^*}}$:

              \begin{vquote}
                $\forall$ $t$,
              \end{vquote}

              \begin{vquote}
                $\hat{\rho}_{0_0}$ $\leftarrow$
                $\hat{\rho}_{1_0}$, $\ldots$, $\hat{\rho}_{1_{n_1}}$

                $\vdots$

                $\hat{\rho}_{0_{n_0}}$ $\leftarrow$
                $\hat{\rho}_{1_0}$, $\ldots$, $\hat{\rho}_{1_{n_1}}$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{\rho}_{0_i}$ $=$
                $TransFact$($Replace$($\rho_{0_i}$, $V$, $t$), $Res$($u$, $\sigma$)),
                $0$ $\leq$ $i$ $\leq$ $n_0$,

                \hspace{1em}
                $\hat{\rho}_{1_j}$ $=$
                $TransFact$($Replace$($\rho_{1_j}$, $V$, $t$), $\sigma$),
                $0$ $\leq$ $j$ $\leq$ $n_1$,

                \hspace{1em}
                $t$ $\in$ $T$,

                \hspace{1em}
                $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
              \end{vquote}

            \item
              {\bf Inheritance Rules}

                As with language ${\cal L^*}$, a set of language
                ${\cal L^{T^*}}$ rules are needed to express the inheritance
                properties of members and subsets. While these rules are
                similar to their respective language ${\cal L^*}$ counterparts,
                the definitions are slightly different due to the
                representation of temporal intervals.

                \begin{itemize}
                  \item
                    {\bf Subject Group Member Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($ss$, $sg$, $a$, $o$, $\iota$ $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($sg$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($ss$, $sg$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($sg$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($ss$, $sg$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $ss$ $\in$ ${\cal E}_{ss}$,

                      \hspace{1em}
                      $sg$ $\in$ ${\cal E}_{sg}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    {\bf Access Right Group Member Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $as$, $ag$, $o$, $\iota$ $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $ag$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($as$, $ag$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $ag$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($as$, $ag$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $as$ $\in$ ${\cal E}_{as}$,

                      \hspace{1em}
                      $ag$ $\in$ ${\cal E}_{ag}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    {\bf Object Group Member Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $a$, $os$, $og$, $\iota$ $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $a$, $og$, $\iota$, $\sigma$),
                      $\hat{memb}$($os$, $og$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a$, $og$, $\iota$, $\sigma$),
                      $\hat{memb}$($os$, $og$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $os$ $\in$ ${\cal E}_{os}$,

                      \hspace{1em}
                      $og$ $\in$ ${\cal E}_{og}$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    {\bf Subject Group Subset Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($sg_1$, $sg_2$, $a$, $o$, $\iota$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($sg_2$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($sg_1$, $sg_2$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($sg_2$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($sg_1$, $sg_2$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $sg_1$, $sg_2$ $\in$ ${\cal E}_{sg}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $sg_1$ $\neq$ $sg_2$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                  \item
                    {\bf Access Right Group Subset Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $ag_1$, $ag_2$, $o$, $\iota$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $ag_2$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($ag_1$, $ag_2$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot$ $\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $ag_2$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($ag_1$, $ag_2$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $ag_1$, $ag_2$ $\in$ ${\cal E}_{ag}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $ag_1$ $\neq$ $ag_2$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    {\bf Object Group Subset Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $a$, $og_1$, $og_2$, $\iota$, $\sigma$),
                    \end{vquote}

                    \begin{vquote}
                      $\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $a$, $og_2$, $\iota$, $\sigma$),
                      $\hat{subst}$($og_1$, $og_2$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a$, $og_2$, $\iota$, $\sigma$),
                      $\hat{subst}$($og_1$, $og_2$, $\iota$, $\sigma$)
                    \end{vquote}

                    \begin{vquote}
                      where

                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $og_1$, $og_2$ $\in$ ${\cal E}_{og}$,

                      \hspace{1em}
                      $og_1$ $\neq$ $og_2$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                \end{itemize}

            \item
              {\bf Transitivity Rules}

              Like their language ${\cal L^*}$ counterparts, these rules ensure
              that for any three distinct groups $g_0$, $g_1$ and $g_2$, if
              $g_0$ is a subset of $g_1$ and $g_1$ is a subset of $g_2$, then
              $g_0$ is also a subset of $g_2$.

              \begin{itemize}
                \item
                  {\bf Subject Group Transitivity Rules}

                  \begin{vquote}
                    $\forall$ ($sg_{1}$, $sg_{2}$, $sg_{3}$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($sg_{1}$, $sg_{3}$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{subst}$($sg_{1}$, $sg_{2}$, $\iota$, $\sigma$),
                    $\hat{subst}$($sg_{2}$, $sg_{3}$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $sg_{1}$, $sg_{2}$, $sg_{3}$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $sg_{1}$ $\neq$ $sg_{2}$ $\neq$ $sg_{3}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  {\bf Access Right Group Transitivity Rules}

                  \begin{vquote}
                    $\forall$ ($ag_{1}$, $ag_{2}$, $ag_{3}$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($ag_{1}$, $ag_{3}$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{subst}$($ag_{1}$, $ag_{2}$, $\iota$, $\sigma$),
                    $\hat{subst}$($ag_{2}$, $ag_{3}$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $ag_{1}$, $ag_{2}$, $ag_{3}$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $ag_{1}$ $\neq$ $ag_{2}$ $\neq$ $ag_{3}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}
                \item
                  {\bf Object Group Transitivity Rules}

                  \begin{vquote}
                    $\forall$ ($og_{1}$, $og_{2}$, $og_{3}$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($og_{1}$, $og_{3}$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{subst}$($og_{1}$, $og_{2}$, $\iota$, $\sigma$),
                    $\hat{subst}$($og_{2}$, $og_{3}$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $og_{1}$, $og_{2}$, $og_{3}$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $og_{1}$ $\neq$ $og_{2}$ $\neq$ $og_{3}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}
              \end{itemize}

            \item
              {\bf Inertial Rules}

              The same rules of inertia expressed in language ${\cal L^*}$
              applies to language ${\cal L^{T^*}}$: every fact $\hat{\rho}$
              that holds in state $\sigma$ must also hold in state
              $Res$($u$, $\sigma$) after policy update $u$ is applied,
              provided that update $u$ does not cause the fact
              $\lnot\hat{\rho}$ to hold.

              \begin{vquote}
                $\forall$ ($\hat{\alpha}$,$u$),
              \end{vquote}

              \begin{vquote}
                $\hat{\alpha}'$
                $\leftarrow$
                $\hat{\alpha}$,
                $not$ $\lnot$ $\hat{\alpha}'$
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{\alpha}'$
                $\leftarrow$ $\lnot$
                $\hat{\alpha}$,
                $not$ $\hat{\alpha}'$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$,

                \hspace{1em}
                $u$ $\in$ $\psi$,

                \hspace{1em}
                $\hat{\alpha}'$ = $CopyAtom$($\hat{\alpha}$, $Res$($u$, $\sigma$))
              \end{vquote}

            \item
              {\bf Reflexivity Rules}

              These rules ensure that the reflexive property of sets are
              preserved: every set is a subset of itself.

              \begin{vquote}
                $\forall$ ($g$, $\iota$, $\sigma$),
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($g$, $g$, $\iota$, $\sigma$) $\leftarrow$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $g$ $\in$ (${\cal E}_{sg}$ $\cup$ ${\cal E}_{ag}$ $\cup$ ${\cal E}_{og}$),

                \hspace{1em}
                $\iota$ $\in$ ${\cal I}$,

                \hspace{1em}
                $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
              \end{vquote}

            \item
              {\bf Temporal Rules}

              The temporal rules are based on the fact that if a fact
              $\hat{\rho}$ holds at interval $\iota$, then the same fact
              $\hat{\rho}$ must also hold at all intervals $\iota'$ where
              the relation between intervals $\iota$ and $\iota'$ is
              {\em Equals}, {\em During}, {\em Starts} or {\em Finishes}.

              \begin{itemize}

                \item
                  {\bf Holds Temporal Rules}

                  \begin{vquote}
                    $\forall$($s$, $a$, $o$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $a$, $o$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{holds}$($s$, $a$, $o$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot$ $\hat{holds}$($s$, $a$, $o$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\lnot$ $\hat{holds}$($s$, $a$, $o$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_s$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_a$,

                    \hspace{1em}
                    $0$ $\in$ ${\cal E}_o$,

                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                \item
                  {\bf Membership Temporal Rules}

                  \begin{vquote}
                    $\forall$($ss$, $sg$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{memb}$($ss$, $sg$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{memb}$($ss$, $sg$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot$ $\hat{memb}$($ss$, $sg$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\lnot$ $\hat{memb}$($ss$, $sg$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $ss$ $\in$ ${\cal E}_{ss}$,

                    \hspace{1em}
                    $sg$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                  \vspace{0.5em}

                  \begin{vquote}
                    $\forall$($as$, $ag$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{memb}$($as$, $ag$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{memb}$($as$, $ag$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot$ $\hat{memb}$($as$, $ag$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\lnot$ $\hat{memb}$($as$, $ag$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $as$ $\in$ ${\cal E}_{as}$,

                    \hspace{1em}
                    $ag$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                  \vspace{0.5em}

                  \begin{vquote}
                    $\forall$($os$, $og$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{memb}$($os$, $og$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{memb}$($os$, $og$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot$ $\hat{memb}$($os$, $og$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\lnot$ $\hat{memb}$($os$, $og$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $os$ $\in$ ${\cal E}_{os}$,

                    \hspace{1em}
                    $og$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                \item
                  {\bf Subset Temporal Rules}

                  \begin{vquote}
                    $\forall$($sg_0$, $sg_1$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($sg_0$, $sg_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{subst}$($sg_0$, $sg_1$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot$ $\hat{subst}$($sg_0$, $sg_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\lnot$ $\hat{subst}$($sg_0$, $sg_1$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $sg_0$, $sg_1$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                  \vspace{0.5em}

                  \begin{vquote}
                    $\forall$($ag_0$, $ag_1$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($ag_0$, $ag_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{subst}$($ag_0$, $ag_1$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot$ $\hat{subst}$($ag_0$, $ag_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\lnot$ $\hat{subst}$($ag_0$, $ag_1$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $ag_0$, $ag_1$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                  \vspace{0.5em}

                  \begin{vquote}
                    $\forall$($og_0$, $og_1$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($og_0$, $og_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{subst}$($og_0$, $og_1$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot$ $\hat{subst}$($og_0$, $og_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\lnot$ $\hat{subst}$($og_0$, $og_1$, $\iota_0$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $og_0$, $og_1$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

              \end{itemize}
            \end{itemize}

        \begin{vexample}
          \label{ex-4-3}
          The following rules show the language ${\cal L^{T^*}}$ translation
          of the language ${\cal L^T}$ code listing shown in Example
          \ref{ex-4-2}.

          \begin{enumerate}
            \item
              Initial Fact Rules

              \begin{vquote}
  $\hat{memb}$($alice$, $grp_2$, $work\_hours$, $S_0$) $\leftarrow$

  $\hat{subst}$($grp_2$, $grp_1$, $morning\_hours$, $S_0$) $\leftarrow$

  $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$
              \end{vquote}

            \item
              Authorisation Constraint Rules

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $afternoon\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Policy Update Rules

              \begin{vquote}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_1$) $\leftarrow$

                $\hat{holds}$($grp_1$, $read$, $file$, $morning\_hours$, $S_1$) $\leftarrow$

                $\hat{holds}$($grp_1$, $read$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$
              \end{vquote}

            \item
              Inheritance Rules

              \begin{vquote}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_2$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_2$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_2$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_2$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($alice$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($alice$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($alice$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Transitivity Rules

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_3$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{subst}$($grp_2$, $grp_3$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_1$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{subst}$($grp_2$, $grp_1$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Inertial Rules

              \begin{vquote}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Reflexivity Rules

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_0$) $\leftarrow$
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$
              \end{vquote}

            \item
              Temporal Rules

              \begin{vquote}
                $\hat{holds}$($alice$, $read$, $file$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_1$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{memb}$($alice$, $grp_1$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{memb}$($alice$, $grp_3$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_2$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{subst}$($grp_1$, $grp_2$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{subst}$($grp_3$, $grp_2$, $afternoon_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{subst}$($grp_3$, $grp_2$, $work\_hours$, $S_1$),
              \end{vquote}
          \end{enumerate}
        \end{vexample}

    \section{Discussions}

      The previous section has shown how a language ${\cal L^T}$ program can
      be translated into a extended logic program language ${\cal L^{T^*}}$.
      Since language ${\cal L^{T^*}}$ is semantically similar to language
      ${\cal L^*}$, the same methods shown in [XXX ref to L*] is used to
      translate langauge ${\cal L^{T^*}}$ into a normal logic program for
      query evaluation. However, one outstanding issue remains for langauge
      ${\cal L^T}$: domain consistency.
      
      A language ${\cal L^T}$ domain description ${\cal D}_{\cal L^T}$ without
      any variable occurences (and therefore without any {\em where} clauses)
      may be represented as the following statements:

      \begin{vverbatim}
  initially \(\rho\sb{0\sb{0}}\), \(\ldots\), \(\rho\sb{0\sb{n\sb{0}}}\), \(!\)\(\rho\sb{1\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{1\sb{n\sb{1}}}\);

  relation \(r\sb{0\sb{0}}\), \(\ldots\), \(r\sb{0\sb{m}}\);

  always \(\rho\sb{2\sb{0}}\), \(\ldots\), \(\rho\sb{2\sb{n\sb{2}}}\), \(!\)\(\rho\sb{3\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{3\sb{n\sb{3}}}\)
    implied by \(\rho\sb{4\sb{0}}\), \(\ldots\), \(\rho\sb{4\sb{n\sb{4}}}\), \(!\)\(\rho\sb{5\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{5\sb{n\sb{5}}}\)
    with absence \(\rho\sb{6\sb{0}}\), \(\ldots\), \(\rho\sb{6\sb{n\sb{6}}}\), \(!\)\(\rho\sb{7\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{7\sb{n\sb{7}}}\);

  update \(u\)()
    causes \(\rho\sb{8\sb{0}}\), \(\ldots\), \(\rho\sb{8\sb{n\sb{8}}}\), \(!\)\(\rho\sb{9\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{9\sb{n\sb{9}}}\) 
    if \(\rho\sb{10\sb{0}}\), \(\ldots\), \(\rho\sb{10\sb{n\sb{10}}}\), \(!\)\(\rho\sb{11\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{11\sb{n\sb{11}}}\);
      \end{vverbatim}

      Note that if we disregard the {\em relation} statement and the fact
      that langauge ${\cal L^T}$ atoms also specify time intervals, language
      ${\cal L^T}$ statements consisting only of ground expressions as above
      are identical to the language ${\cal L}$ statements shown in [XXX ref to
      lang L]. As a consequence, we can use Theorem [XXX ref to theorem in
      lang L] to define ${\cal D_{L^T}}$ consistency:

      \begin{vdefinition}
        \label{def-cons1}
        A domain description ${\cal D_{L^T}}$ is consistent if:

        \begin{enumerate}
          \item
            ${\cal D_{L^T}}$ is {\bf normal}, using the same language
            ${\cal L}$ definition in Definition [XXX ref to lang L], and

          \item
            The temporal interval relations defined in ${\cal D_{L^T}}$
            produces a {\bf consistent interval network}.
        \end{enumerate}
      \end{vdefinition}

      Assuming that we already have a normal domain description, we focus on
      the second condition. Below, we define network consistency:

      \begin{vdefinition}
        \label{def-cons2}
        Given a temporal interval network $N$, with nodes $n_0$,
        $\ldots$ $n_n$ and arcs $a_0$, $\ldots$, $a_m$. An {\bf instance} of
        interval network $N$ is a subnetwork with nodes $n_0$, $\ldots$, $n_n$,
        with each arc $a_{i}'$ representing a single relation from the
        corresponding arc in $N$ ($a_{i}'$ $\in$ $a_i$, $0$ $\leq$ $i$ $\leq$
        $m$). A {\bf consistent instance} of interval network $N$ is an
        instance of $N$ such that for any three nodes, the three relations
        represented by these nodes satisfy the transitivity rules shown in
        Table \ref{table-trans}. A {\bf consistent interval network} is a
        network with at least one consistent instance.
      \end{vdefinition}

      Any given language ${\cal L^T}$ domain description can fail to satisfy
      condition 2 in Definition \ref{def-cons1} above in different ways. In
      fact, Valdez-Perez \cite{VP} generalised these conditions where an
      interval network is inconsistent\footnotemark.
      \footnotetext{Valdez-Perez uses the term {\em unsatisfiable}.}
      One such condition arises in language ${\cal L^T}$ when two or more
      conflicting interval constraint statements exist. This conflict occurs
      when the consequence of an interval constraint is implictly or explicitly
      excluded by another interval constraint. For example, the following two
      interval constraint statements are in conflict with each other because
      the second defines a relation that has been explicitly excluded by the
      first.

      \begin{vverbatim}
  relation during(i0, i1), before(i0, i1);
  relation equals(i0, i1);
      \end{vverbatim}

      Note that this type of domain inconsistency is detected by the
      $NET.Add$() algorithm. Unfortunately, the second type of inconsisteny is
      not. To illustrate this type of inconsistency, we use Allen's example in
      \cite{AL}, shown in Figure \ref{fig-net-ex-07}.

      \begin{figure}[[tbhp]
        \begin{center}
          \includegraphics{net-07}
          \caption{Inconsistent Network}
          \label{fig-net-ex-07}
        \end{center}
      \end{figure}

      The network shown in Figure \ref{fig-net-ex-07} is in fact inconsistent,
      as none of its 32 instances are consistent. To see this, we note that
      although the $NET.Add$() algorithm accepts the relation shown between the
      arcs $i_1$ and $i_2$, we cannot assign the relation {\em finishes} or
      {\em finished by} alone.

      In fact, as Allen points out in \cite{AL}, the $NET.Add$() algorithm can
      only guarantee consistency within any three nodes of the network
      ({\em 3-consistency}). Unfortunately, Vilain et. al. \cite{VI} points out
      that algorithms that can ensure full network consistency, i.e.
      {\em k-consistency} \cite{FR}, are in fact, intractable. Nevertheless,
      total consistency can be easily checked by employing a simple
      backtracking algorithm. Furthermore, several methods for full network
      consistency checking, like those in \cite{LA,VB} already exist. In this
      work, we make the assumption that 3-consistency is sufficient for our
      authorisation system as we have observed that this covers all scenarios
      that we have examined.

      In this chapter, we have introduced an algebra for expressing time
      interval relations and an authorisation language that employs this
      algebra to express temporal constraints. In the next chapter, we shall
      describe in detail the implementation of an authorisation system whose
      policies are expressed in this language.

  \chapter{Implementation}

    \section{Introduction}

    \section{System Structure}

      \begin{figure}[[tbhp]
        \begin{center}
          \includegraphics{sys-02}
          \caption{System Flowchart}
          \label{fig-sysflow-2}
        \end{center}
      \end{figure}

    \section{Temporal Reasoner}

      \subsection{Network Structure}

        Conceptually, a temporal interval relation network may be represented
        as a table whose rows and columns both represent all the intervals
        in the network. As shown in Table \ref{table-cons-int-net}, all the
        possible relations that exist between intervals $\iota_i$ and
        $\iota_j$, as stored in the network, are contained in the relation set
        $RS_{ij}$ from cell ($i$, $j$).

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|c|c|c|c|c|}
              \cline{1-3}
              \cline{5-5}
              & $\iota_0$ & $\iota_1$ & $\ldots$ & $\iota_n$ \\
              \cline{1-3}
              \cline{5-5}
              $\iota_0$ & $RS_{00}$ & $RS_{01}$ & & $RS_{0n}$ \\
              \cline{1-3}
              \cline{5-5}
              $\iota_1$ & $RS_{10}$ & $RS_{11}$ & & $RS_{1n}$ \\
              \cline{1-3}
              \cline{5-5}
              \multicolumn{4}{l}{$\vdots$} & \multicolumn{1}{l}{$\vdots$} \\
              \cline{1-3}
              \cline{5-5}
              $\iota_n$ & $RS_{n0}$ & $RS_{n1}$ & $\ldots$ & $RS_{nn}$ \\
              \cline{1-3}
              \cline{5-5}
            \end{tabular}
          \end{center}
          \caption[]{Conceptual Representation of an Interval Network}
          \label{table-cons-int-net}
        \end{table}

        As we shall see, using this representation as a basis for
        implementation is not a good idea, as it contains redundant information
        and will incur a high maintenance overhead. First, we note that due
        to the reflexive property of intervals, all the cells in the diagonal
        of this representation is defined as follows:

        \begin{vquote}
          $\forall$ $i$,

          $RS_{ii}$ $=$ {$EQL$}

          where

          \hspace{1em}
          $0$ $\leq$ $i$ $\leq$ $n$
        \end{vquote}

        As the reflexive property applies to all intervals, there is no need to
        store such relations in the network. Another instance of redundancy in
        this representation is made evident by the following definition:

        \begin{vquote}
          $\forall$ ($i$, $j$),

          $RS_{ij}$ $=$ $RS^{-1}_{ji}$

          where

          \hspace{1em}
          $0$ $\leq$ $i$ $\leq$ $n$

          \hspace{1em}
          $0$ $\leq$ $j$ $\leq$ $n$

          \hspace{1em}
          $RS^{-1}$ is the inverse set of $RS$
        \end{vquote}

        The definition above states that a relation set between two intervals
        $\iota_0$ and $\iota_1$ can be derived by calculating the inverse of
        the relation set between $\iota_1$ and $\iota_0$. As a consequence,
        only one relation set between any two intervals needs to be stored
        as its inverse can be calculated from this relation set if required.
        Note that under this definition, half of the cells in Table
        \ref{table-cons-int-net} are redundant.

        \subsubsection{Binary Representation of Relation Sets}

          Obviously, relation sets can be conceptually represented as a list of
          relations. However, from an implementation point of view, maintaining
          a list of relations for every relation set can incur a lot of
          overhead as the cost of adding and removing relations from such a
          list can be computationally expensive. To avoid this problem, we
          employ a more efficient way of representing these sets in our
          implementation. Each relation set is represented as a bit
          vector\footnotemark.

          \footnotetext{A similar method is used in \cite{VB, VI}.}

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|c|c|c|c|}
                \hline
                {\bf Relation} & {\bf Symbol} & {\bf Value} & {\bf Bit Value} \\
                \hline
                Equals        & EQL &    1 &  0 \\
                \hline                        
                Before        & BEF &    2 &  1 \\
                \hline                        
                During        & DUR &    4 &  2 \\
                \hline                        
                Overlaps      & OVR &    8 &  3 \\
                \hline                        
                Meets         & MET &   16 &  4 \\
                \hline                        
                Starts        & STA &   32 &  5 \\
                \hline                        
                Finishes      & FIN &   64 &  6 \\
                \hline                        
                After         & BEI &  128 &  7 \\
                \hline                        
                Contains      & DUI &  256 &  8 \\
                \hline                        
                Overlapped By & OVI &  512 &  9 \\
                \hline
                Met By        & MEI & 1024 & 10 \\
                \hline
                Started By    & STI & 2048 & 11 \\
                \hline
                Finished By   & FII & 4096 & 12 \\
                \hline
              \end{tabular}
            \end{center}
            \caption[]{Temporal Relation Value Assignment}
            \label{table-rels-value}
          \end{table}

          To illustrate this representation, we first assign a base-2 value
          for each basic relation as shown in Table \ref{table-rels-value}.
          With these value assignments, any relation set composed of any
          combination of these basic relations can be represented as an integer
          which is the sum of the relations that it contains. For example,
          under this system the relation set \{$BEF$, $DUR$, $STA$, $STI$\} can
          be represented as $2086$.

          Implemented as a bit vector, three important relation set operators
          can be easily defined by using bitwise operators:

          \begin{itemize}
            \item
              Union
              \begin{vquote}
                $RS_0$ $\cup$ $RS_1$ $=$ $RS_0$ $|$ $RS_1$
              \end{vquote}
  
            \item
              Intersection
              \begin{vquote}
                $RS_0$ $\cap$ $RS_1$ $=$ $RS_0$ $\&$ $RS_1$
              \end{vquote}

            \item
              Inverse

              \begin{vquote}
                $RS^{-1}$ $=$
                  (($RS$ $\&$ $8064$) $>>$ $6$) $|$
                  (($RS$ $\&$ $126$)  $<<$ $6$) $|$
                  ($RS$ $\&$ $1$)
              \end{vquote}
          \end{itemize}

        \subsubsection{Network Data Structure}

          The temporal interval network is implemented as a list of all
          intervals, each with a relation list where information about its
          relation with other intervals are stored (see Figure
          \ref{fig-net-struct}). Table \ref{table-net-ds} shows the structure
          of each node in the network list, while Table
          \ref{table-rlist-ds} shows the structure of each relation list
          node in each network list node.

          \begin{figure}[[tbhp]
            \begin{center}
              \includegraphics{net-struct}
              \caption{Network Structure as a List of Relation Lists}
              \label{fig-net-struct}
            \end{center}
          \end{figure}

          For example, a network $NET$ containing only the relations
          $before$($\iota_0$, $\iota_1$) and $during$($\iota_0$, $\iota_1$) are
          stored in the following manner:

          \begin{vquote}
            $NET$[$0$].$int\_id$ $=$ $\iota_0$

            $NET$[$0$].$rlist$[$0$].$int\_id$ $=$ $\iota_1$

            $NET$[$0$].$rlist$[$0$].$rs$ $=$ $6$

            $NET$[$1$].$int\_id$ $=$ $\iota_1$

            $NET$[$1$].$rlist$ $=$ $\emptyset$
          \end{vquote}

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|l|l|l|}
                \hline
                {\bf Field} & {\bf Type} & {\bf Description} \\
                \hline
                $int\_id$ & String & Interval ID \\
                \hline
                $rlist$   & RelList & Relation List \\
                \hline
              \end{tabular}
            \end{center}
            \caption[]{Network Node Data Structure}
            \label{table-net-ds}
          \end{table}

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|l|l|l|}
                \hline
                {\bf Field} & {\bf Type} & {\bf Description} \\
                \hline
                $int\_id$ & String & Interval ID \\
                \hline
                $rs$      & Integer & Relation Set \\
                \hline
              \end{tabular}
            \end{center}
            \caption[]{Relation List Node Data Structure}
            \label{table-rlist-ds}
          \end{table}

          Note that in the previous example, the relations between intervals
          $\iota_0$ and $\iota_1$ are stored in the relation list of interval
          $\iota_0$, but the inverse relation, the relations between intervals
          $\iota_1$ and $\iota_0$, is not stored in the relation list of
          $\iota_1$. This is done for efficiency, as inverse relations can be
          calculated by the inverse operator for any stored relations.

          However, this method raises the question of how we decide which
          interval node is used to store a given relation. In the previous
          example, we arbitrarily chose to store the relation in interval
          $\iota_0$'s relation list, however, we could just as easily have
          chosen to store the relation in interval $\iota_1$'s relation list:

          \begin{vquote}
            $NET$[$0$].$int\_id$ $=$ $\iota_0$

            $NET$[$0$].$rlist$ $=$ $\emptyset$

            $NET$[$1$].$int\_id$ $=$ $\iota_1$

            $NET$[$1$].$rlist$[$0$].$int\_id$ $=$ $\iota_0$

            $NET$[$1$].$rlist$[$0$].$rs$ $=$ $384$
          \end{vquote}

          To resolve this issue, we adopt a simple rule to determine where a
          given relation is to be stored in the network. Given a pair of
          intervals $\iota_0$ and $\iota_1$, and a relation set $rs$, this
          relation is stored in the node whose interval ID occurs first when
          sorted alphabetically. For example, if $\iota_0$ is $morning$ and
          $\iota_1$ is $evening$, then the relation $rs$ would be stored
          in the node containing $\iota_1$, since $evening$ is alphabetically
          before $morning$. To enforce this rule, we use the function shown in
          Algorithm \ref{algo-normalise} before adding a relation to the
          network:

          \begin{valgorithm}[tbhp]{Normalise()}{algo-normalise}
FUNCTION \(Normalise\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  IF \(\iota\sb{0}\) \(\leq\) \(\iota\sb{1}\) THEN
    RETURN (\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\)) 
  ELSE
    RETURN (\(\iota\sb{1}\), \(\iota\sb{0}\), \(rs\sp{-1}\)) 
  ENDIF
ENDFUNCTION
          \end{valgorithm}

      \subsection{Network Operators}

    \section{Authorisation Engine}

      \subsection{Symbol Table}

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              {\bf Field} & {\bf Type} & {\bf Description} \\
              \hline
              $ss$  & String List & Single Subject \\
              \hline
              $sg$  & String List & Group Subject \\
              \hline
              $as$  & String List & Single Access Right \\
              \hline
              $ag$  & String List & Group Access Right \\
              \hline
              $os$  & String List & Single Object \\
              \hline
              $og$  & String List & Group Object \\
              \hline
              $int$ & String List & Interval \\
              \hline
            \end{tabular}
          \end{center}
          \caption[]{Symbol Table}
          \label{table-symtab}
        \end{table}

      \subsection{Grounding of Variables}

      \subsection{Translation to Normal Logic Program}

        \begin{vquote}
          $Total_H$ $=$

          \hspace{1em}
          ($|T_s.ss|$ $+$ $|T_s.sg|$) $\cdot$

          \hspace{1em}
          ($|T_s.as|$ $+$ $|T_s.ag|$) $\cdot$

          \hspace{1em}
          ($|T_s.os|$ $+$ $|T_s.og|$) $\cdot$

          \hspace{1em}
          $|T_s.int|$
        \end{vquote}

        \begin{vquote}
          $Total_M$ $=$

          \hspace{1em}
          ($|T_s.ss|$ $\cdot$ $|T_s.sg|$ $\cdot$ $|T_s.int|$) $+$

          \hspace{1em}
          ($|T_s.as|$ $\cdot$ $|T_s.ag|$ $\cdot$ $|T_s.int|$) $+$

           \hspace{1em}
          ($|T_s.os|$ $\cdot$ $|T_s.og|$ $\cdot$ $|T_s.int|$)
        \end{vquote}

        \begin{vquote}
          $Total_S$ $=$

          \hspace{1em}
          ($|T_s.sg|^2$ $\cdot$ $|T_s.int|$) $+$

          \hspace{1em}
          ($|T_s.ag|^2$ $\cdot$ $|T_s.int|$) $+$

           \hspace{1em}
          ($|T_s.og|^2$ $\cdot$ $|T_s.int|$)
        \end{vquote}

        \begin{vquote}
          $Total_A$ $=$ $Total_H$ $+$ $Total_M$ $+$ $Total_S$
        \end{vquote}

        \begin{valgorithm}[tbhp]{Encode\_Holds()}{algo-encode-holds}
FUNCTION \(Encode_Holds\)(\(sub\), \(acc\), \(obj\), \(int\), \(\sigma\), \(tr\))
  IF \(sub\) is group THEN
    \(sub\) = \(sub\) + \(|T\sb{s}.ss|\)
  ENDIF
  IF \(acc\) is group THEN
    \(acc\) = \(acc\) + \(|T\sb{s}.as|\)
  ENDIF
  IF \(obj\) is group THEN
    \(obj\) = \(obj\) + \(|T\sb{s}.os|\)
  ENDIF

  \(offset\) \(=\)
    (\(sub\) \(\cdot\) (\(|T\sb{s}.as|\) \(+\) \(|T\sb{s}.ag|\)) \(\cdot\) (\(|T\sb{s}.os|\) \(+\) \(|T\sb{s}.og|\)) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
    (\(acc\) \(\cdot\) (\(|T\sb{s}.os|\) \(+\) \(|T\sb{s}.og|\)) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
    (\(obj\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
    \(int\)
    
  IF \(tr\) THEN
    \(offset\) \(=\) \(offset\) \(+\) \(Total\sb{A}\)
  ENDIF

  RETURN \(offset\) \(+\) (\(\sigma\) \(\cdot\) \(Total\sb{A}\) \(\cdot\) \(2\))
ENDFUNCTION
        \end{valgorithm}

        \begin{valgorithm}[tbhp]{Encode\_Memb()}{algo-encode-memb}
FUNCTION \(Encode_Memb\)(\(elt\), \(grp\), \(int\), \(\sigma\), \(tr\))
  CASE type of member atom OF
    \(subject\) :
      \(offset\) \(=\)
        (\(elt\) \(\cdot\) \(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(grp\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        \(int\)
    \(access right\) :
      \(offset\) \(=\)
        (\(elt\) \(\cdot\) \(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(grp\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(|T\sb{s}.ss|\) \(\cdot\) \(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        \(int\)
    \(object\) :
      \(offset\) \(=\)
        (\(elt\) \(\cdot\) \(|T\sb{s}.og|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(grp\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(|T\sb{s}.ss|\) \(\cdot\) \(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(|T\sb{s}.as|\) \(\cdot\) \(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        \(int\)
  ENDCASE
    
  IF \(tr\) THEN
    \(offset\) \(=\) \(offset\) \(+\) \(Total\sb{A}\)
  ENDIF

  RETURN \(Total\sb{H}\) \(+\) \(offset\) \(+\) (\(\sigma\) \(\cdot\) \(Total\sb{A}\) \(\cdot\) \(2\))
ENDFUNCTION
        \end{valgorithm}

        \begin{valgorithm}[tbhp]{Encode\_Subst()}{algo-encode-subst}
FUNCTION \(Encode_Subst\)(\(grp\sb{0}\), \(grp\sb{1}\), \(int\), \(\sigma\), \(tr\))
  CASE type of subset atom OF
    \(subject\) :
      \(offset\) \(=\)
        (\(grp\sb{0}\) \(\cdot\) \(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(grp\sb{1}\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        \(int\)
    \(access right\) :
      \(offset\) \(=\)
        (\(grp\sb{0}\) \(\cdot\) \(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(grp\sb{1}\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(|T\sb{s}.sg|\sp{2}\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        \(int\)
    \(object\) :
      \(offset\) \(=\)
        (\(grp\sb{0}\) \(\cdot\) \(|T\sb{s}.og|\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(grp\sb{1}\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(|T\sb{s}.sg|\sp{2}\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        (\(|T\sb{s}.ag|\sp{2}\) \(\cdot\) \(|T\sb{s}.int|\)) \(+\)
        \(int\)
  ENDCASE
    
  IF \(tr\) THEN
    \(offset\) \(=\) \(offset\) \(+\) \(Total\sb{A}\)
  ENDIF

  RETURN \(Total\sb{H}\) \(+\) \(Total\sb{M}\) \(+\) \(offset\) \(+\) (\(\sigma\) \(\cdot\) \(Total\sb{A}\) \(\cdot\) \(2\))
ENDFUNCTION
        \end{valgorithm}


        \begin{valgorithm}[tbhp]{Decode\_Holds()}{algo-decode-holds}
FUNCTION \(Decode_Holds\)(\(id\), \(\sigma\), \(tr\))
  \(s\) \(=\) \(id\) div ((\(|T\sb{s}.as|\) \(+\) \(|T\sb{s}.ag|\)) \(\cdot\) (\(|T\sb{s}.os|\) \(+\) \(|T\sb{s}.og|\)) \(\cdot\) \(|T\sb{s}.int|\))
  \(id\) \(=\) \(id\) mod ((\(|T\sb{s}.as|\) \(+\) \(|T\sb{s}.ag|\)) \(\cdot\) (\(|T\sb{s}.os|\) \(+\) \(|T\sb{s}.og|\)) \(\cdot\) \(|T\sb{s}.int|\))
  \(a\) \(=\) \(id\) div ((\(|T\sb{s}.os|\) \(+\) \(|T\sb{s}.og|\)) \(\cdot\) \(|T\sb{s}.int|\))
  \(id\) \(=\) \(id\) mod ((\(|T\sb{s}.os|\) \(+\) \(|T\sb{s}.og|\)) \(\cdot\) \(|T\sb{s}.int|\))
  \(o\) \(=\) \(id\) div \(|T\sb{s}.int|\)
  \(i\) \(=\) \(id\) mod \(|T\sb{s}.int|\)

  IF \(s\) \(\geq\) \(|T\sb{s}.ss|\) THEN
    \(sub\) = \(T\sb{s}.sg\)[\(s\) \(-\) \(|T\sb{s}.ss|\)]
  ELSE
    \(sub\) = \(T\sb{s}.ss\)[\(s\)]
  ENDIF
  IF \(a\) \(\geq\) \(|T\sb{s}.as|\) THEN
    \(acc\) = \(T\sb{s}.ag\)[\(a\) \(-\) \(|T\sb{s}.as|\)]
  ELSE
    \(acc\) = \(T\sb{s}.as\)[\(a\)]
  ENDIF
  IF \(o\) \(\geq\) \(|T\sb{s}.os|\) THEN
    \(obj\) = \(T\sb{s}.og\)[\(o\) \(-\) \(|T\sb{s}.os|\)]
  ELSE
    \(obj\) = \(T\sb{s}.os\)[\(o\)]
  ENDIF

  RETURN \(holds\)(\(sub\), \(acc\), \(obj\), \(T\sb{s}.int\)[\(i\)], \(\sigma\), \(tr\))
ENDFUNCTION
        \end{valgorithm}

        \begin{valgorithm}[tbhp]{Decode\_Memb()}{algo-decode-memb}
FUNCTION \(Decode_Memb\)(\(id\), \(\sigma\), \(tr\))
  \(c\sb{0}\) \(=\) (\(|T\sb{s}.ss|\) \(\cdot\) \(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\)) 
  \(c\sb{1}\) \(=\) \(c\sb{0}\) \(+\) (\(|T\sb{s}.as|\) \(\cdot\) \(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\)) 

  IF \(id\) \(<\) \(c\sb{0}\) THEN
    \(elt\) \(=\) \(T\sb{s}.ss\)[\(id\) div (\(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\))]
    \(grp\) \(=\) \(T\sb{s}.sg\)[(\(id\) mod (\(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\))) div \(|T\sb{s}.int|\)]
    \(int\) \(=\) \(T\sb{s}.int\)[(\(id\) mod (\(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\))) mod \(|T\sb{s}.int|\)]
  ELSE IF \(id\) \(<\) \(c\sb{1}\) THEN
    \(id\) \(=\) \(id\) \(-\) \(c\sb{0}\)

    \(elt\) \(=\) \(T\sb{s}.as\)[\(id\) div (\(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\))]
    \(grp\) \(=\) \(T\sb{s}.ag\)[(\(id\) mod (\(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\))) div \(|T\sb{s}.int|\)]
    \(int\) \(=\) \(T\sb{s}.int\)[(\(id\) mod (\(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\))) mod \(|T\sb{s}.int|\)]
  ELSE
    \(id\) \(=\) \(id\) \(-\) \(c\sb{1}\)

    \(elt\) \(=\) \(T\sb{s}.os\)[\(id\) div (\(|T\sb{s}.og|\) \(\cdot\) \(|T\sb{s}.int|\))]
    \(grp\) \(=\) \(T\sb{s}.og\)[(\(id\) mod (\(|T\sb{s}og|\) \(\cdot\) \(|T\sb{s}.int|\))) div \(|T\sb{s}.int|\)]
    \(int\) \(=\) \(T\sb{s}.int\)[(\(id\) mod (\(|T\sb{s}.og|\) \(\cdot\) \(|T\sb{s}.int|\))) mod \(|T\sb{s}.int|\)]
  ENDIF

  RETURN \(memb\)(\(elt\), \(grp\), \(int\), \(\sigma\), \(tr\))
ENDFUNCTION
        \end{valgorithm}

        \begin{valgorithm}[tbhp]{Decode\_Subst()}{algo-decode-subst}
FUNCTION \(Decode_Subst\)(\(id\), \(\sigma\), \(tr\))
  \(c\sb{0}\) \(=\) (\(|T\sb{s}.sg|\sp{2}\) \(\cdot\) \(|T\sb{s}.int|\)) 
  \(c\sb{1}\) \(=\) \(c\sb{0}\) \(+\) (\(|T\sb{s}.ag|\sp{2}\) \(\cdot\) \(|T\sb{s}.int|\)) 

  IF \(id\) \(<\) \(c\sb{0}\) THEN
    \(grp\sb{0}\) \(=\) \(T\sb{s}.sg\)[\(id\) div (\(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\))]
    \(grp\sb{1}\) \(=\) \(T\sb{s}.sg\)[(\(id\) mod (\(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\))) div \(|T\sb{s}.int|\)]
    \(int\) \(=\) \(T\sb{s}.int\)[(\(id\) mod (\(|T\sb{s}.sg|\) \(\cdot\) \(|T\sb{s}.int|\))) mod \(|T\sb{s}.int|\)]
  ELSE IF \(id\) \(<\) \(c\sb{1}\) THEN
    \(id\) \(=\) \(id\) \(-\) \(c\sb{0}\)

    \(grp\sb{0}\) \(=\) \(T\sb{s}.ag\)[\(id\) div (\(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\))]
    \(grp\sb{1}\) \(=\) \(T\sb{s}.ag\)[(\(id\) mod (\(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\))) div \(|T\sb{s}.int|\)]
    \(int\) \(=\) \(T\sb{s}.int\)[(\(id\) mod (\(|T\sb{s}.ag|\) \(\cdot\) \(|T\sb{s}.int|\))) mod \(|T\sb{s}.int|\)]
  ELSE
    \(id\) \(=\) \(id\) \(-\) \(c\sb{1}\)

    \(grp\sb{0}\) \(=\) \(T\sb{s}.os\)[\(id\) div (\(|T\sb{s}.og|\) \(\cdot\) \(|T\sb{s}.int|\))]
    \(grp\sb{1}\) \(=\) \(T\sb{s}.og\)[(\(id\) mod (\(|T\sb{s}og|\) \(\cdot\) \(|T\sb{s}.int|\))) div \(|T\sb{s}.int|\)]
    \(int\) \(=\) \(T\sb{s}.int\)[(\(id\) mod (\(|T\sb{s}.og|\) \(\cdot\) \(|T\sb{s}.int|\))) mod \(|T\sb{s}.int|\)]
  ENDIF

  RETURN \(subst\)(\(grp\sb{0}\), \(grp\sb{1}\), \(int\), \(\sigma\), \(tr\))
ENDFUNCTION
        \end{valgorithm}

        \begin{valgorithm}[tbhp]{Decode\_Fact()}{algo-decode-fact}
FUNCTION \(Decode_Fact\)(\(id\))
  \(\sigma\) \(=\) \(id\) div (\(Total\sb{A}\) \(\cdot\) \(2\))
  \(id\) \(=\) \(id\) mod (\(Total\sb{A}\) \(\cdot\) \(2\)) 

  IF \(id\) \(\geq\) \(Total\sb{A}\) THEN
    \(tr\) \(=\) \(true\)
  ELSE
    \(tr\) \(=\) \(false\)
  ENDIF

  \(id\) \(=\) \(id\) mod \(Total\sb{A}\)

  IF \(id\) \(<\) \(Total\sb{H}\) THEN
    RETURN \(Decode_Holds\)(\(id\), \(\sigma\), \(tr\))
  ELSEIF \(id\) \(<\) (\(Total\sb{H}\) \(+\) \(Total\sb{M}\)) THEN
    RETURN \(Decode_Memb\)(\(id\) \(-\) \(Total\sb{H}\), \(\sigma\), \(tr\))
  ELSE
    RETURN \(Decode_Subst\)(\(id\) \(-\) (\(Total\sb{H}\) \(+\) \(Total\sb{M}\)), \(\sigma\), \(tr\))
  ENDIF
ENDFUNCTION
        \end{valgorithm}

    \section{Discussions} 

  \chapter{Conclusion}

  \begin{thebibliography}{M}
    \bibitem{AL}
      Allen J. F.,
      Maintaining Knowledge about Temporal Intervals.
      {\em Communications of the ACM},
      Vol. 26, No. 11, pp. 832-843,
      1983.

    \bibitem{FR}
      Freuder E. C.,
      A Sufficient Condition for Backtrack-Free Search.
      {\em Journal of the ACM},
      Vol. 29, No. 1, pp. 24-32,
      1982.

    \bibitem{GE}
      Gelfond M., Lifschitz V.
      The Stable Model Semantics for Logic Programming.
      In {\em Proceedings of the Fifth International Conference on Logic Programming},
      pp. 1070-1080,
      1988.

    \bibitem{LA}
      Ladkin P. B., Reinefeld A.,
      Fast Algebraic Methods for Interval Constraint Problems.
      {\em Annals of Mathematics and Artificial Intelligence},
      Vol. 19, No. 3-4, pp. 383-411,
      1997.

    \bibitem{VP}
      Valdez-Perez R. E.,
      The Satisfiability of Temporal Constraint Networks,
      In {\em Proceedings of the Sixth National Conference on Artificial Intelligence (AAAI-87)},
      pp. 256-260,
      1987.

    \bibitem{VB}
      Van Beek P. G., Manchak D. W.,
      The Design and Experimental Analysis of Algorithms for Temporal Reasoning.
      {\em Journal of Artificial Intelligence Research},
      Vol. 4, pp. 1-18,
      1996.

    \bibitem{VI}
      Vilain M. B., Kautz H. A., Van Beek P. G.,
      Constraint Propagation Algorithms for Temporal Reasoning: A Revised Report.
      In {\em Readings in Qualitative Reasoning about Physical Systems},
      pp. 373-381,
      1989.
  \end{thebibliography}

\end{document}
