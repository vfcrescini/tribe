\documentclass[11pt]{report}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{alltt}
\usepackage{float}
\usepackage{calc}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{fancyheadings}

% a variable margin environment
\newenvironment{vvarmargin}[2]
{
  \begin{list}{}
  {
    \setlength{\topsep}{0pt}
    \setlength{\leftmargin}{0pt}
    \setlength{\rightmargin}{0pt}
    \setlength{\listparindent}{\parindent}
    \setlength{\itemindent}{\parindent}
    \setlength{\parsep}{0pt plus 1pt}
    \addtolength{\leftmargin}{#1}\addtolength{\rightmargin}{#2}
  }
  \item
}
{
  \end{list}
}

% definition environment
\newtheorem{vdefinition}{Definition}[chapter]

% theorem environment
\newtheorem{vvtheorem}{Theorem}[chapter]
\newenvironment{vtheorem}[1]
{
  \begin{vvtheorem}{{\bf (#1)}}
}
{
  \end{vvtheorem}
}

% proof environment
\newenvironment{vproof}
{
  \noindent
  {\em Proof}\hspace{0.5em}
}
{

  \noindent
  \rule{0.5em}{0.5em}
}

% example environment
\newtheorem{vexample}{Example}[chapter]

% verbatim environment
\newenvironment{vverbatim}
{
  \begin{alltt}
}
{
    \vspace{-\baselineskip}
  \end{alltt}
}

% algorithm environment
\newtheorem{vvalgorithm}{Algorithm}[chapter]
\newenvironment{valgorithm}[2]
{
  \begin{vvalgorithm}{#1}
    \label{#2}
    \small
    \begin{vverbatim}
}
{
    \end{vverbatim}
  \end{vvalgorithm}
}

% create a quote environment without a right-hand margin
\newenvironment{vquote}
{
  \begin{list}{}{\leftmargin 1em}\item[]
}
{
  \end{list}
}

% dedication environment
\newenvironment{vdedication}
{
  \thispagestyle{empty}
  \vspace*{\stretch{2}}
  \em
  \begin{center}
}
{
  \end{center}
  \vspace*{\stretch{10}}
  \cleardoublepage
}

% copyright environment
\newenvironment{vcopyright}
{
  \thispagestyle{empty}
  \vspace*{\stretch{10}}
  \begin{center}
}
{
  \end{center}
  \vspace*{\stretch{2}}
  \clearpage
}

% certification environment
\newenvironment{vcertificate}
{
  \thispagestyle{empty}
  \vspace*{\stretch{8}}
}
{
  \vspace*{\stretch{10}}
  \cleardoublepage
}

% headings and footers
\setlength{\headheight}{2em}
\lhead{\leftmark}
\chead[]{}
\rhead[]{}
\lfoot{}
\cfoot{\hfil\textrm{\thepage}\hfil}
\rfoot[]{}

% lines in chapter headings
\makeatletter
\renewcommand{\@makechapterhead}[1]
{
  \vspace*{3em}
  {
    \raggedright
    \normalfont
    \LARGE \bf \@chapapp \space \thechapter
    \par
    \vspace{1em}
    \hrule
    \vspace{15pt}
    \Huge \bf #1\par
    \vspace{15pt}
    \hrule
    \vspace{1.5em}
  }
}
\renewcommand{\@makeschapterhead}[1]
{
  \vspace*{3em}
  {
    \raggedright
    \normalfont
    \vspace{1em}
    \hrule
    \vspace{15pt}
    \Huge \bf #1\par
    \vspace{15pt}
    \hrule
    \vspace{1.5em}
  }
}
\makeatother

\begin{document}
  \onehalfspacing

  \pagenumbering{roman}

  \pagestyle{fancy}

  \begin{titlepage}
    \begin{center}
      \vspace*{\stretch{1}}

      {
        \huge \bf
        Implementation of a \\
        Logic-Based Access Control System with \\
        Dynamic Policy Updates and \\
        Temporal Constraints \\
      }

      \vspace*{\stretch{1}}

      {
        \Large \bf
        Vino Fernando Crescini
      }

      \vspace*{\stretch{2}}

      {
        \Large
        A thesis submitted for the Degree of \\
        Doctor of Philosophy at \\
        University of Western Sydney \\
      }

      \vspace*{\stretch{1}}

      {
        \Large
        April 2006
      }

      \vspace*{\stretch{1}}
    \end{center}
  \end{titlepage}

  \begin{vcopyright}
    Copyright \copyright \space
    V. F. Crescini
    2006

    \vspace{1em}

    \small
    Typeset in Times with \TeX \space and \LaTeXe.
  \end{vcopyright}

  \begin{vcertificate}
    \noindent
    Except where otherwise indicated, this thesis is my own original work.
    I certify that this thesis contains no material that has been submitted
    previously, in whole or in part, for the award of any other academic
    degree.

    \vspace{5em}

    \noindent
    V. F. Crescini \\
    30 April 2006
  \end{vcertificate}

  \begin{vdedication}
    For Huai Zheng
  \end{vdedication}

  \chapter*{Acknowledgements}
  \addcontentsline{toc}{chapter}{Acknowledgements}

    This work would not be possible without my principal supervisor, Assoc.
    Prof. Yan Zhang. For the countless hours I spent with him discussing the
    details of this work, for his guidance and for his support, I am deeply
    grateful. My gratitute also goes to Dr. Yun Bai, whose previous work on
    access control systems served as a foundation for this study.

    I would like to thank the academic staff and research colleagues in the
    Intelligent Systems Laboratory research group for their valuable inputs
    that contributed to this work.

    I would also like to express my gratitude to my family, especially my
    parents, without whose encouragements and support this work would not be
    possible.

    Finally, I thank my wife, Huai Zheng, the source of all my inspiration, the
    sole reason why I get up in the morning and do what I do.

  \chapter*{Abstract}
  \addcontentsline{toc}{chapter}{Abstract}
    As information systems evolve to cope with the ever increasing demand
    of today's digital world, so does the need for more effective means of
    protecting information. In the early days of computing, information
    security started out as a branch of information technology. Over the years,
    several advances in information security have been made and, as a result,
    it is now considered a discipline in its own right. The most fundamental
    function of information security is to ensure that information flows to
    authorised entities, and at the same time, prevent unauthorised entities
    from accessing the protected information. In a typlical information system,
    an access control system provides this function.

    Several advances in the field information security have produced several
    access control models and implementations. However, as information
    technology evolves, the need for a better access control system increases.
    This dissertation proposes an effective, yet flexible access control
    system: the {\em PolicyUpdater} access control system.

    PolicyUpdater is a fully-implemented access control system that provides
    policy evaluations as well as dynamic policy updates. These functions are
    provided by the use of a logic-based language, ${\cal L}$, to represent the
    underlying access control policies, constraints and policy update rules.
    The system performs authorisation query evaluations, as well as conditional
    and dynamic policy updates by translating language $\cal{L}$ policies to
    normal logic programs in a form suitable for evaluation using the
    well-known {\em Stable Model} semantics.

    In this thesis, we show the underlying mechanisms that make up the
    PolicyUpdater system, including the theoretical foundations of its formal
    language, the system structure, a full discussion of implementation issues
    and a performance analysis.

    Lastly, the thesis also proposes a non-trivial extension of the
    PolicyUpdater system that is capable of supporting temporal constraints.
    This is made possible by the integration of the well-established
    {\em Temporal Interval Algebra} into the extended authorisation language,
    language ${\cal L^T}$, which can also be translated into a normal logic
    program for evaluation. The formalisation of this extension, together with
    the full implementation details, are included in this dissertation.

  \tableofcontents
  \listoffigures
  \listoftables
  \newpage

  \pagenumbering{arabic}

  \chapter{Introduction}
    \label{chap-intro}

    \section{General Background}
      \label{sect-intro-genbg}

      Generally, the term access control refers to a mechanism by which access
      to resources, digital or otherwise, are restricted. This restriction is
      enforced in such a way that only authorised entities are allowed access
      to the resources protected by the mechanism, and that any other entities
      are not. Access control restrictions are typically expressed as an
      access control {\em policy}, which defines the rules that determine
      whether or not an entity is granted access to protected resources.

      In the broadest sense of the term, an access control system is a
      collection of mechanisms that enforces access control policies. An access
      control system may be divided into two sub-systems: the
      {\em authentication} sub-system and the {\em authorisation} sub-system.
      The goal of authentication is to obtain and verify the identity of every
      entity that requests access to protected resources. This may be achieved
      by simple mechanisms like username/password verification, digital
      certificates, physical/digital keys, or more advanced methods like
      biometric authentication which include fingerprint verification, voice
      print verification, iris/retinal scanning, etc.

      In contrast, an authorisation system's purpose is to decide whether or
      not an authenticated entity is to be allowed access to resources or not.
      It is therefore in the authorisation sub-system where the access control
      policy is kept and maintained. This is the reason why the term access
      control is often used interchangeably with the term authorisation.

      Another system that may be considered an access control sub-system
      is the {\em enforcement} system. The sole task of this system is to
      ensure that an authenticated and authorised entity is allowed access and
      that all other entities are denied access. While in some literatures
      the enforcement system is considered to be part of the authorisation
      sub-system, others place it outside the domain of access control
      altogether. In this view, the task of an access control system is limited
      to identifying (authentication) requesting entities and deciding whether
      to grant or deny (authorisation) access requests. Enforcement of these
      decisions is left to an external enforcement system.

      Figure \ref{figu-intro-acctl} shows how each sub-system fits into the
      overall access control system.

      \begin{figure}[tbhp]
        \begin{center}
          \includegraphics{acc-ctrl}
          \caption{Structure of a Typical Access Control System}
          \label{figu-intro-acctl}
        \end{center}
      \end{figure}

      In this thesis, we shall focus on the authorisation sub-system, or more
      specifically, how the policies are expressed, read and maintained. It
      therefore assumes that the access control environment in which it is used
      provides adequate authentication and enforcement mechanisms.

      \subsection{Authorisation Rules}
        \label{subs-intro-authr}

        Example \ref{exam-intro-poli1} shows a simple example of a partial
        policy that defines the authorisation rules of a file system. Note that
        in all three, a rule can be broken up into three general sorts:
        {\em subjects}, {\em access rights} and {\em objects}. In this example,
        the subjects are: $Alice$, $Bob$ and $Charlie$; the access rights are:
        $read$, $write$ and $execute$; while the objects are: $file_0$,
        $file_1$ and $file_2$. From this example, it is easy to see what each
        sort is. Subjects are the entities which are granted or denied access
        to the resources, access rights are the types of privileges assigned
        to subjects for resources, and objects are the resources themselves.
        An {\em authorisation rule}, therefore, is a binding of subjects,
        access rights and object.

        \begin{vexample}
          \label{exam-intro-poli1}
          Below is an example of a partial file system policy:
          \begin{itemize}
            \item
              $Alice$ is allowed to $read$ $file_0$
            \item
              $Bob$ is allowed to $read$, $write$ and $execute$ $file_1$
            \item
              $Charlie$ is allowed to $read$ $file_0$, $file_1$ and $file_2$
          \end{itemize}
        \end{vexample}

      \subsection{Policy Base}
        \label{subs-intro-polba}

        A policy base is used by an authorisation system as a full repository
        of authorisation policies. Note that it is inaccurate to say that a
        policy base is simply a collection of authorisation rules. In Example
        \ref{exam-intro-poli1} above, the three rules establishes the
        privileges granted to subjects $Alice$, $Bob$ and $Charlie$. However,
        the set of three rules are incomplete: it provides no information as to
        what authorisations are allowed for $Dennis$, nor does it state that
        $Alice$ is not allowed to $write$ to $file_1$. A policy base must
        contain a full or complete policy.

        To rectify the problem mentioned above, one solution might be to
        have the policy base adopt a closed-world discipline where any
        authorisation requests that are not explicitly addressed by a rule are
        rejected. The partial policy shown in Example \ref{exam-intro-poli1}
        need only a slight modification to make it complete:

        \begin{vexample}
          \label{exam-intro-poli2}
          A complete file system policy:
          \begin{itemize}
            \item
              Nobody is allowed any access to any resource, except:
            \item
              $Alice$ is allowed to $read$ $file_0$
            \item
              $Bob$ is allowed to $read$, $write$ and $execute$ $file_1$
            \item
              $Charlie$ is allowed to $read$ $file_0$, $file_1$ and $file_2$
          \end{itemize}
        \end{vexample}

    \section{Key Issues}
      \label{sect-intro-keyis}

      In this section, we identify the key issues and requirements of the
      design and implementation of an authorisation system.

      \subsection{Formal Specification of Policies}
        \label{subs-intro-specp}

        The first issue to consider in an authorisation system is the
        structure of the policies. In the previous examples, the policies are
        defined as abstract descriptions of authorisation rules. However, in a
        real access control system, or to continue with the example, a real
        file system with hundreds of subjects and several levels of directories
        will require several pages of policy descriptions if expressed in this
        abstract form. A real authorisation system requires a formalised
        specification to express policies.

        At the very least, a formal specification of an authorisation policy
        requires (1) a formal definition of entities (subjects, access rights
        and objects); (2) a formal specification of rules to bind together
        these entities to represent authorisation rules.

        The first requirement deals with the issue of mapping authorisation
        entities, conceptual or otherwise, into formal representations which
        will be used in the definition of authorisation policies. In the
        previous example, this mapping is straight forward: system users to
        subjects, file permissions to access rights and files to objects.
        However, in some scenarios, entities may be mapped to more something
        more abstract like "accounting documents" as objects or
        "administrators" as subjects. Generally, this requirement defines the
        mapping rules of entities as well as the formal definitions of the
        entities themselves.

        The second requirement ensures that there is a formal method of
        expressing the rules themselves. In Example \ref{exam-intro-poli1},
        the rules are expressed as a simple binding of the entities. However,
        as mentioned before, this example is only a partial policy since it
        does not state the rules that deal with other subjects or other
        objects. Example \ref{exam-intro-poli2} rectified this problem, but
        format of the first rule does not match the subject-access right-object
        binding format of the other three rules. This second requirement aims
        to formalise the definition of each rule.

        For example, to formalise the policy specification of our file system
        policy, we define the following:

        \begin{itemize}
          \item
            An entity is an alphanumeric string.
          \item
            $Everybody$ is a special subject entity which comprises of all
            defined subjects, $AllAccess$ is an access right entity
            composed of all defined access rights, and $AllFiles$ is an object
            entity composed of all defined objects.
          \item
            An authorisation rule is composed of a boolean value to indicate
            whether the rule is a positive or a negative authorisation,
            followed by a binding of a subject, access right and object.
          \item
            In cases where two rules are in conflict, the most recent rule
            (between two rules, the one appearing lower in the list is more
            recent) overrides the other rule.
        \end{itemize}

        As shown above, the policy specification eliminates all ambiguities
        by providing a formal specification for each rule. Note that the
        positive and negative authorisation rule specification also defines how
        each rule is to be interpreted by the enforcement or access control
        system. Another issue handled by the above specification is how to
        interpret two conflicting rules. Example \ref{exam-intro-poli3} shows
        the same policy used in the previous examples expressed in the above
        formalisation.

        \begin{vexample}
          \label{exam-intro-poli3}
          A formalised file system policy:
          \begin{itemize}
            \item
              $False$, $Everyone$, $AllAccess$, $AllFiles$
            \item
              $True$, $Alice$, $read$, $file_0$
            \item
              $True$, $Bob$, $read$, $file_1$
            \item
              $True$, $Bob$, $write$, $file_1$
            \item
              $True$, $Bob$, $execute$, $file_1$
            \item
              $True$, $Charlie$, $read$, $file_0$
            \item
              $True$, $Charlie$, $read$, $file_1$
            \item
              $True$, $Charlie$, $read$, $file_2$
          \end{itemize}
        \end{vexample}

      \subsection{Policy Updates}
        \label{subs-intro-polup}

        Up to this point, we have been dealing only with static policies. A
        typical policy base, however, requires at least a means of changing
        the rules of the policy. A naive authorisation system implementation
        might only have the ability to handle static policies, but this would
        require a system reset every time the policy is changed. A robust
        authorisation system therefore needs a built-in mechanism that would
        allow its policy base to be changed or updated at run time. We call
        such updates that are performed at run time {\em dynamic updates}.

        Continuing from our previous examples, suppose we need to add another
        file, say $file_3$, into the policy. With the current policy
        description, this file is "caught" by the negative authorisation rule
        which makes this file unreadable, unwritable and unexecutable by
        everyone. Now suppose we wish to make it readable by all current
        subjects, but not by any subject that might be added later. To do this,
        we need to add three new rules to the policy: one for $Alice$, one for
        $Bob$ and another for $Charlie$. Similarly, if we wish to revoke
        the $write$ permission held by $Bob$ for $file_1$, we simply update
        the policy base by deleting the appropriate rule.

        While the policy updating scenario described above is simple, more
        complex update requirements do exist. One such requirement might arise
        in situations where a policy needs to be updated only when when certain
        conditions are met. For example, we might require the subject $Alice$
        to be granted a $write$ access right to $file_2$ if she already holds
        a $read$ access right to the same file. Such updates are called
        {\em conditional updates}.

      \subsection{Temporal Constraints}
        \label{subs-intro-tempc}

        An authorisation rule composed only of the binding of a subject, an
        access right and an object represents a single authorisation that
        answers the question of {\em who} is allowed {\em what} permission to
        {\em which} resource. There is nothing to express {\em when} this
        authorisation rule is to hold. So far, in the examples given in the
        previous sections, we have made the assumption that these rules apply
        at all times. That is, from some time in the past, either from the time
        the rules were defined or the time the access control system is
        activated, to the time the system is shut down. However, there are
        special situations where authorisation rules need to specify the time
        at which is it in effect as well as the usual subject-access
        right-object binding. Such situations might arise, for example, in a
        roster-based organisation where one user is granted access to some
        resource from 9AM to 2PM, another user from 2PM to 8PM and so forth.

        This need to express time in authorisation rules can be easily
        satisfied by extending the rule specification to a quadruple binding
        of subjects, access rights, objects and time. For example, the
        rule ($Alice$, $read$, $file_0$, $1PM$ to $2PM$) might be used to
        represent a rule granting $Alice$ $read$ access to $file_0$ at lunch
        time. However, this approach is insufficient to express time-bound
        rules where the relationship between the time attributes is more
        important than the time attributes themselves. For example, this
        approach is unable to express the following abstract rule:

        \begin{vquote}
          $Alice$ is authorised to $read$ file $file_0$ only while $Bob$
          holds $read$ and $write$ access to the same file.
        \end{vquote}

        An authorisation system with support for temporal constraints must
        have its formal policy specification defined to express rules such
        as this.

      \subsection{Implementation}
        \label{subs-intro-imple}

        Obviously, a policy description specification is only as good as the
        authorisation system implementation on which it is used. The
        implementation of an authorisation system needs to address most
        importantly, the internal details of its policy base. The definition of
        the data structures to store entities and rules need to be considered,
        as well as the algorithms that make up the internal processes.
        Scalability is particularly important since a typical authorisation
        system policy is composed of a huge number of rules, and because each
        authorisation request usually requires instant response, efficiency
        of algorithms must also be taken into account.

        As for the specification of policies, sufficient formalisation details
        must include, if, for example, formalised as a language, the syntax and
        semantics for implementation.

    \section{Literature Review}
      \label{sect-intro-litre}

      In this section, we review the different approaches to access control
      that have been proposed or implemented over the years. 

      \subsection{Discretionary Access Control}
        \label{subs-intro-dacmo}

        The {\em Discretionary Access Control} ({\em DAC}) model is an
        authorisation model where policies are defined in such a way that a
        subject's identity determines what access rights it holds over which
        objects \cite{CAS}. The two distinct characteristics of this model are:
        (1) every resource (object) in the system is owned by a subject; and
        (2) authorisation rules in the policy are bindings of subjects, access
        rights and objects. This access control model is discretionary in the
        sense that object owners (subjects) are capable of granting or revoking
        other subjects access rights to objects that they own at their
        discretion.

        A very simple authorisation system based on the DAC model is the
        {\em access control matrix}, which was first proposed by Lampson
        \cite{LAM}, then subsequently extended in \cite{GRA,CON,HAR}. The
        access control matrix is a simple yet powerful policy base model where
        every subject's access rights of every object are stored. The matrix
        is composed of rows that represent the subjects of the system. Each
        column represents the objects of the system. The subject-object
        intersection, a cell, contains the access rights held by that subject
        to that object. An empty cell therefore means that the subject in that
        row do not possess any access rights to the object in that column.
        Table \ref{tabl-intro-acmat} shows an access control matrix with the
        same policy used in Example \ref{exam-intro-poli3}.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|l|}
              \hline
                        & $file_0$    & $file_1$    & $file_2$ \\
              \hline
              $Alice$   & $r$         &             &          \\
              \hline
              $Bob$     &             & $r$,$w$,$x$ &          \\
              \hline
              $Charlie$ & $r$         & $r$         & $r$      \\
              \hline
              $Dennis$  &             &             &          \\
              \hline
            \end{tabular}
          \end{center}
          \caption{An Example of an Access Control Matrix}
          \label{tabl-intro-acmat}
        \end{table}

        As one might imagine, an access control matrix for a system composed
        mainly of user's personal data will be very sparse: only cells of
        intersecting objects and their owners will have access right entries
        stored in them. As a result, some applications of access control
        matrices take up more space that what is actually needed. Another
        implementation, the {\em access control list} \cite{LAM}, resolves
        this issue by storing authorisation rules in individual lists instead
        of one common matrix. In an access control list implementation, the
        access control system maintains a list of subjects with access rights
        for each object in the system. Access control lists are typically used
        to implement low level authorisation mechanisms like those used in file
        systems. It should be noted that very few systems actually implement
        an access control matrix. Indeed, the access control matrix was meant
        only as a conceptual representation of the policy base, and systems
        such as those based on access control lists are considered as
        implementations of the access control matrix model.

        Figure \ref{figu-intro-aclis} shows a set of access control lists that
        contains the same policy stored in the access control matrix in Table
        \ref{tabl-intro-acmat}.

        \begin{figure}[tbhp]
          \begin{center}
            \includegraphics{acl}
            \caption{Access Control Lists}
            \label{figu-intro-aclis}
          \end{center}
        \end{figure}

        In some situations, it is more convenient to store authorisation
        policies in such a way that for each subject, the system maintains
        a {\em capability list} \cite{FAR,LEV} which contains all access rights
        the subject holds for certain objects. Since each subject has its own
        capability list, there might be cases where a certain subject's
        capability list is empty. This means the subject is not authorised to
        access any object. Figure \ref{figu-intro-calis} shows a set of
        capability lists that contains the same policy stored in the access
        control list shown in \ref{figu-intro-aclis}.

        \begin{figure}[tbhp]
          \begin{center}
            \includegraphics{cap}
            \caption{Capability Lists}
            \label{figu-intro-calis}
          \end{center}
        \end{figure}

      \subsection{Mandatory Access Control}
        \label{subs-intro-macmo}

        The {\em Mandatory Access Control} ({\em MAC}) model introduces the
        concept of defining different levels of security. These levels are
        treated as security labels or attributes which represent the level
        of sensitivity when applied to objects, and define clearance level
        when applied to subjects. A classical example of security labels is
        the classification system formalised by Bell and LaPadula
        \cite{BEL1,BEL2} for the U.S. Department of Defense: (from least to
        most sensitive) unclassified, confidential, secret, top secret.

        A subject is only allowed to read objects of equal or lower security
        level than the level assigned to the subject. Conversely, a subject can
        only write to objects that are of equal or higher security level than
        the level assigned to the subject. These two conditions are known as
        the {\em read down} and {\em write up} principles of MAC. They ensure
        that information can only be passed from a low security level to a high
        security level and not the other way.

        It is mandatory in the sense that every subject and object must be
        assigned security labels, and as opposed to owner assignments of access
        rights in DAC, these assignments are made by administrators.

      \subsection{Role-Based Access Control}
        \label{subs-intro-racmo}

        A recently proposed alternative to the DAC and MAC models is the
        {\em role-based access control} ({\em RBAC}) model. RBAC was first
        proposed in \cite{FER1,FER2}, then later, a full RBAC framework in
        \cite{SAN2}. In most organisations, different roles are defined to
        achieve certain tasks. A person undertaking a particular role is
        granted access to all resources associated with that role. A person's 
        authorisations gained from assuming a role are revoked once the person
        has relinquished the role or assumed another role. For example, in a
        hotel environment, the management role is assigned access to the
        hotel's accounting files, payroll database etc., while the front desk
        role's authorisation is limited to the guest and rooms database. A
        person assuming the role of a hotel manager is granted access to the
        resources assigned to that role, but the moment the person drops that
        role to assume the role of a front desk officer, access to these
        managerial resources are also dropped.

        The goal of the RBAC model is to closely reflect this organisational
        structure of policies into an authorisation system. In this model,
        authorisations to access objects are assigned to roles, not to
        subjects directly. Subjects are then assigned different roles that they
        are allowed to partake. The strength of the RBAC model lies in its
        ability to accurately model abstract authorisation policies in
        real-world organisations. The abstraction of authorisation rules from
        subjects allows better policy management because the assignment of
        roles to subjects is easier to perform than direct assignment of
        authorisations to subjects.

      \subsection{Logic-Based Approach}
        \label{subs-intro-lacmo}

        An effective approach to access control is the {\em logic-based access
        control} approach. In this approach, instead of explicitly defining all
        access-rights of all subjects for all objects in a domain, a set of
        logical facts and rules are used to define the policy base.

        One such model was proposed by Abadi et. al. in \cite{ABA}. Their model
        is based on a modal logic language designed for access control.
        However, this language focuses mainly on the delegation of
        authorisations and the concept of roles, rather than the expression of
        authorisation policies.

        In 1992, Woo and Lam proposed an authorisation approach based on the
        concept that the semantics of authorisation should be separated from
        the low-level and system-dependent implementation mechanisms
        \cite{WOO1,WOO2}. In this approach, the policy is expressed as a set
        of rules written in terms of a first-order logic authorisation
        language. In this language, an atom is a propositional constant of the
        form $a$($s$, $o$) representing a binding of a subject $s$, an access
        right $a$ and an object $o$. A {\em positive authorisation atom} is
        written as $a^+$($s$, $o$), while a {\em negative authorisation atom}
        is written as  $a^-$($s$, $o$). As a first-order logic language,
        it includes the usual notions of variables, negation, conjunction and
        disjunction. A {\em literal} is an atom or its negation, while a
        {\em formula} is either a literal, a conjunction of literals or a
        disjunction of literals. {\em Rules} are composed of formulas written
        in the form shown below:

        \begin{vquote}
          $\frac{f : f'}{g}$

          \hspace{1em}
          where

          \hspace{1em}
          $f$ is the prerequisite

          \hspace{1em}
          $f'$ is the assumption

          \hspace{1em}
          $g$ is the consequent
        \end{vquote}

         \noindent
         The rule above is interpreted as the following statement: "If $f$
         holds, and there is no reason not to believe that $f'$ also holds,
         then $g$ is also believed to hold". This rule construct is similar
         to the {\em default construct} used in {\em default logic} \cite{REI}
         where the absence of proof may be used as a condition for a rule.

         The rules are evaulated into a policy base. In this approach, the
         policy base is defined as a 4-tuple: ($P^+$, $P^-$, $N^+$, $N^-$)
         where each component is a set of subject-access right-object tuples.
         $P^+$ contains a set of tuples that explicitly grant authorisations.
         For example, to evaluate whether subject $s$ is given access right $a$
         to object $o$, one must check whether ($s$, $a$, $o$) $\in$ $P^+$ is
         true. $N^+$ contains a set of tuples that explicitly deny
         authorisations. $P^-$ and $N^-$ records authorisations that should
         not be explicitly granted or denied, respectively.

         Because the Woo and Lam approach explicitly expresses both positive
         and negative authorisations as well as conditional rules, it is not
         difficult to see that this approach provides a more flexible means of
         expressing authorisaton policies. Example \ref{exam-intro-wooex} shows
         the logic-based equivalent of the policy represented by the access
         control matrix shown in Table \ref{tabl-intro-acmat}.

         \begin{vexample}
           \label{exam-intro-wooex}
           In this example, the first 7 rules explicitly grant different
           authorisations to specific subjects for specific objects. The
           final rule makes use of variables to deny all authorisations that
           are not explicitly granted.

           \begin{vquote}
             $\frac{True : True}{r^{+}(Alice, file_0)}$

             $\frac{True : True}{r^{+}(Bob, file_1)}$

             $\frac{True : True}{w^{+}(Bob, file_1)}$

             $\frac{True : True}{x^{+}(Bob, file_1)}$

             $\frac{True : True}{r^{+}(Charlie, file_0)}$

             $\frac{True : True}{r^{+}(Charlie, file_1)}$

             $\frac{True : True}{r^{+}(Charlie, file_2)}$

             $\frac{True : A^{-}(S, O)}{A^{-}(S, O)}$
           \end{vquote}
         \end{vexample}

         Note that the Woo and Lam model uses a single policy description for
         authorisation. Indeed, several authorisation models and their
         resepctive access control mechanism implementations \cite{CAS}
         operate under a single authorisation policy. Such systems usually have
         this policy intertwined with its authorisation mechanism. As a
         consequence, such systems are limited to one specified authorisation
         policy, even though the authorisation requirement may change over
         time.

         In response to this problem, Jajodia, et. al. proposed a logic-based
         authorisation language, the {\em Authorization Specification
         Language} \cite{JAJ1}. Later, the approach was generalised into a full
         authorisation framework, the {\em Flexible Authorisation Framework}
         \cite{JAJ2,JAJ3}. With this framework, it is possible to enforce
         multiple authorisation policies within a single authorisation system.
         The framework itself is based on the logic-based authorisation
         language, through which administrators are allowed to choose, at their
         discretion, which policy is to be used. Other features of this
         framework include support for groups and roles, conflict resolution
         mechanisms and support for different decision strategies.

         Another approach, proposed by Bertino et. al. \cite{BER3}, uses an
         authorisation mechanism based on ordered logic. This powerful
         mechanism supports both positive and negative authorisations as well
         as implicit rule derivations and default propositions. Other notable
         features of this system include the distinction between weak and
         strong authorisations, support for administrative authorisation
         delegation and more importantly, conflict resolution.

         These systems, although effective, lack the details necessary to
         address the issues involved in the implementation of such systems.
         Another logic-based authorisation system was proposed by Halpern and
         Weissman \cite{HAL}. Their approach focuses on the tractability of
         the policy reasoning mechanism by resricting the expressivness of the
         policy language. This is achieved by using only a subset of
         first-order logic in the policy language. However, this tradeoff means
         that although the language provides sufficient expressive power for
         most applications, this approach cannot handle default propositions or
         policy updates.

       \subsection{Other Approaches and Considerations}

         The {\em Policy Description Language}, or {\em PDL}, developed by
         Lobo, et. al. \cite{LOB}, is a language for representing event and
         action oriented generic policies. {\em PDL} is later extended by
         Chomicki, et. al. \cite{CHO} to include {\em policy monitors} which,
         in effect, are policy constraints. Bertino, et. al. \cite{BER4,BER5},
         again took {\em PDL} a step further by extending {\em policy monitors}
         to allow users to express preferred constraints. While these generic
         languages are expressive enough to be used for access control systems,
         systems built for such languages will not have the ability to
         dynamically update the policies.

         Sandhu et. al. \cite{SAN1,SAN3,SAN4} was first to introduce the
         concept of {\em transformation}, or more specifically,
         {\em non-monotonic transformation} of access rights. For all intents
         and purposes, the term transformation is synonymous with our
         definition of policy updating. The non-monotonic property allows
         access rights to be revoked as well as granted in a policy update.
         Meadows \cite{MEA}, formalised the concept of dynamic upgrading of
         policies.

         Bai and Varadharajan \cite{BAI1,BAI2,BAI3} extended the concept of
         dynamic updates by developing an authorisation model based on a
         language that is not only capable of handling policy updates, but also
         sequences of policy updates. Because this model is logic-based, other
         key features include the ability to express default propositions and
         a mechanism for conflict resolution. However, the major weakness of
         this framework is its lack of sufficient details for full system
         implementation.

         Other access control approaches such as those proposed in
         \cite{RUA1, RUA2, LI} focus on authorisation delegation. Although such
         systems are useful in distributed or decentralised systems, a common
         deficiency is their inability to handle default propositions and/or
         policy updates.

         Recently, Ray \cite{RAY} proposed a formalism for updating access
         control policies in real-time. Although this formalism provides a set
         of algorithms aimed at the implementation of an authorisation system
         capable of performing dynamic policy updates, it only considers
         simple authorisation policies with no support for negative
         authorisations, conditional rules or conflict resolution.

         Bertino et. al. introduced an authorisation model in \cite{BER1} that
         is capable of expressing temporal information in its policies. By
         including time interval attributes to rules, the model allows
         authorisations to be bound to a specific time period, or hold only
         for a specific time interval. In addition to this, the model also
         supports derivation rules based on temporal propositions. This feature
         allows new temporal authorisations to be valid on the basis of the
         presence or absence of other temporal authorisations. This model was
         later extended and revised in \cite{BER2} to support periodic or
         cyclic temporal authorisations. In these models, the temporal
         derivation rules consider the validity of authorisations that
         are bound by time. However, the model cannot express relations between
         the time intervals themselves, as discussed in Section
         \ref{subs-intro-tempc}.

         Ruan et. al. \cite{RUA3} developed another logic-based authorisation
         model with support for delegation of temporal authorisations. Again,
         the main weakness of this model is that relations between time
         intervals cannot be expressed. Another authorisation model proposed by
         Atluri and Gal \cite{ATL} focuses on securing web portals. In this
         model, the authorisations are derived based on the temporal
         characteristics of the data (objects) and their relationships with
         other data. Although their work provides full implementation details,
         the model itself does not permit the assignment of temporal attributes
         to the authorisation rules.

    \section{About the Thesis}
      \label{sect-intro-about}

      The work presented in this thesis focuses on the key issues of
      authorisation systems outlined in Section \ref{sect-intro-keyis}, and
      at the same time addresses the deficiencies and limitations of the access
      control models and approaches discussed in the previous section. In
      a nutshell, the work revolves around the formalisation and implementation
      of a logic-based authorisation system, {\em PolicyUpdater}, with support
      for constraint rules with default propositions, dynamic and conditional
      policy updates and temporal constraints.

      The rest of the thesis is organised as follows:

      Chapter \ref{chap-langl} introduces language ${\cal L}$, a logic-based
      authorisation language with dynamic policy updates. The chapter discusses
      the language's syntax and semantics, and by doing so, addresses the
      underlying mechanisms by which high level authorisation policies are
      expressed and evaluated.

      Chapter \ref{chap-polup} introduces the PolicyUpdater authorisation
      system which uses language ${\cal L}$ to express policies. The chapter
      gives an overview of the PolicyUpdater system as  a whole, with its
      internal and external components. The chapter also includes a few
      algorithms that outline the system processes as well as some experimental
      results that show the relationship between input size and execution time.
      A case study which describes a web-server application of PolicyUpdater is
      also included in this chapter.

      Chapter \ref{chap-tempo} first describes an interval algebra to express
      relationships between temporal intervals, then introduces language
      ${\cal L^T}$, a non-trivial extension of language ${\cal L}$ that has
      enough expressive power to assign temporal attributes to authorisation
      rules and, by the integration of the interval algebra, allows the
      representation of temporal interval relations.

      Chapter \ref{chap-impln} provides a full comprehensive implementation
      discussion of the extended PolicyUpdater system. The chapter firstly
      outlines the full implementation details of a temporal interval relation
      reasoner, then describes the internal mechanisms of the extended
      PolicyUpdater system not previously discussed in Chapter
      \ref{chap-polup}.

      Finally, Chapter \ref{chap-concl} summarises the contributions of the
      work and outlines several future research directions.

      Note that parts of this dissertation have already been published in
      journals and conference papers \cite{CRE2,CRE1,CRE4}. Furthermore, a
      paper on the extended PolicyUpdater system \cite{CRE3} will be submitted
      soon.

  \chapter{Logic-Based Authorisation Language}
    \label{chap-langl}

    Language $\cal{L}$\footnotemark is a first-order logic language that
    represents a policy base for an authorisation system. Two key features of
    the language are: (1) the language provides a means to conditionally and
    dynamically update the policy base and (2) the semantics of the language
    allows a logic-based evaluation of an updated policy base to support
    authorisation queries.

    \footnotetext{
      The full language ${\cal L}$ specification was first introduced in
      \cite{CRE1}.
    }

    \section{Syntax}
      \label{sect-langl-syntx}

      Logic programs of language ${\cal L}$ are composed of language
      statements, each terminated by a semicolon ";" character. C-style
      comments delimited by the "/*" and "*/" characters may appear anywhere
      in the logic program. The full BNF specification of the language is
      shown in Section \ref{sect-langs-bnfll}.

      \subsubsection{Components of Language $\cal{L}$}
        \label{subs-langl-compo}

        Language ${\cal L}$ statements are made up of one or more of the
        following components: identifiers, atoms, facts and expressions.

        \begin{itemize}
          \item
            {\bf Identifiers}

            The most basic unit of language $\cal{L}$ is the identifier.
            Identifiers are used to represent the different components of
            the language. They are classified into three main categories:

            \begin{enumerate}
              \item
                {\em Entity Identifiers} are used to represent constant
                entities that make up a logical atom. They are divided into
                three types, with each type divided further into the
                {\em singular} and {\em group} entity sub-types:

                \begin{enumerate}
                  \item
                    {\em Subjects}: e.g. alice, lecturers, user-group.
                  \item
                    {\em Access Rights}: e.g. read, write, own.
                  \item
                    {\em Objects}: e.g. file, database, directory.
                \end{enumerate}

                An entity identifier is defined as a single, lower-case
                alphabetic character, followed by 0 or more alphanumeric and
                underscore characters. The following regular expression
                shows the syntax of entity identifiers:

                \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
                \end{vverbatim}

              \item
                {\em Policy Update Identifiers} are used for the sole
                purpose of naming a policy update. These identifier names
                are then used as labels to refer to policy update
                declarations and directives. As labels, identifiers of this
                class occupy a different namespace from entity identifiers.
                For this reason, policy update identifiers share the same
                syntax with entity identifiers:

                \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
                \end{vverbatim}

              \item
                {\em Variable Identifiers} are used as place-holders for
                entity identifiers. To distinguish them from entity and
                policy update identifiers, variable identifiers are prefixed
                with an upper-case character, followed by 0 or more
                alphanumeric and underscore characters. The first character
                of a variable identifier indicates its type ("S" for
                subject, "A" for access right and "O" for object). If the
                second character is an "S", then the variable is a
                place-holder for a singular entity while a "G" indicates
                that it is a place-holder for a group entity. The following
                regular expression shows the syntax of variable identifiers:

                \begin{vverbatim}
   [SAO][SG][a-zA-Z0-9\_]
                \end{vverbatim}
            \end{enumerate}

          \item
            {\bf Atoms}

            An atom is composed of a relation with 2 to 3 entity or
            variable identifiers that represents a logical relationship
            between the entities. There are three types of atoms:

            \begin{enumerate}
              \item
                {\em Holds.} An atom of this type states that the subject
                identifier $sub$ holds the access right identifier $acc$
                for the object identifier $obj$.

               \begin{vverbatim}
  holds(<sub>, <acc>, <obj>)
               \end{vverbatim}

              \item
                {\em Membership.} This type of atom states that the
                singular identifier $elt$ is a member or element of the
                group identifier $grp$. It is important to note that
                identifiers $elt$ and $grp$ must be of the same base type
                (e.g. singular subject and group subject).

                \begin{vverbatim}
  memb(<elt>, <grp>)
                \end{vverbatim}

              \item
                {\em Subset.} The subset atom states that the group
                identifiers $grp_0$ and $grp_1$ are of the same types and
                that group $grp_0$ is a subset of the group $grp_1$.

                \begin{vverbatim}
  subst(<grp-0>, <grp-1>)
                \end{vverbatim}

            \end{enumerate}

          \item
            {\bf Facts}

            A fact states that the relationship represented by an atom or
            its negation holds in the current context. Facts are negated by
            the use of the negation operator "!". The following shows the
            formal syntax of a fact:

            \begin{vverbatim}
  [!]<holds-atom> | <memb-atom> | <subst-atom>
            \end{vverbatim}

            Note that facts may be made up of atoms that contain variable
            identifiers. Facts with no variable occurrences are called
            {\em ground facts}.

          \item
            {\bf Expressions}

            An expression is either a fact or a logical conjunction of facts,
            separated by the comma "," character:

            \begin{vverbatim}
  <fact-0> [, <fact-1> [, ...]]
            \end{vverbatim}

            Expressions that are made up of only ground facts are called
            {\em ground expressions}.
        \end{itemize}

      \subsection{Declaration Statements}
        \label{subs-langl-decls}

        These statements are used to declare the different rules that make up
        the policy base.

        \begin{itemize}
          \item
            {\bf Entity Identifier Declarations}

            All entity identifiers (subjects, access rights, objects and
            groups) must first be declared before any other statements to
            define the entity domain of the policy base. The following entity
            declaration syntax illustrates how to define one or more entity
            identifiers of a particular type.

            \begin{vverbatim}
  ident sub|acc|obj[-grp] <entity-id>[, ...];
            \end{vverbatim}

          \item
            {\bf Initial Fact Declarations}

            The initial facts of the policy base, those that hold before any
            policy updates are performed, are declared by using the following
            syntax:

            \begin{vverbatim}
  initially <ground-exp>;
            \end{vverbatim}

          \item
            {\bf Constraint Declarations}

            A constraint statement is a logical rule that holds regardless
            of any changes that may occur when the policy base is updated.
            Constraint rules are true in the initial state and remain true
            after any policy update.

            The constraint syntax below shows that in any state of the policy
            base, expression $exp_0$ holds if expression $exp_1$ is true and
            there is no evidence that $exp_2$ is true. The {\em with absence}
            clause allows constraints to have a default proposition
            behaviour, where the absence of proof that an expression holds
            satisfies the clause condition of the proposition.

            It is important to note that the expressions $exp_0$, $exp_1$ and
            $exp_2$ may be non-ground expressions, which means an identifier
            occurring within these expressions may be a variable.

            \begin{vverbatim}
  always <exp-0>
    [implied by <exp-0>
    [with absence <exp-1>]];
            \end{vverbatim}

          \item
            {\bf Policy Update Declarations}

            Before a policy update can be applied, it must first be declared
            by using the following syntax:

            \begin{vverbatim}
  <update-id>([<var-id>[, ...]])
    causes <exp-0>
    [if <exp-1>];
            \end{vverbatim}

            $upd$-$id$ is the policy update identifier to be used in
            referencing this policy update. The optional parameter
            $var$-$id$ is a list which contains the variable identifiers
            occurring in expressions $exp_0$ and $exp_1$ and will be
            eventually replaced by entity identifiers when the update is
            referenced. The postcondition expression $exp_1$ is an expression
            that will hold in the state after this update is applied.
            The expression $exp_1$ is a precondition expression that must
            hold in the current state before this update is applied.

            Note that a policy update definition will have no effect on the
            policy base until it is applied by the update directive
            described in the following section.

        \end{itemize}

      \subsection{Directive Statements}
        \label{subs-langl-dires}

        These statements are used to issue policy update and query directives.

        \begin{itemize}
          \item
            {\bf Policy Update Directives}

            The policy update sequence list contains a list of references to
            define policy updates in the domain. The policy updates in the
            sequence list are applied to the current state of the policy
            base one at a time to produce a policy base state against which
            queries can be evaluated.

            The following four directives are used for policy update
            sequence list manipulation.

            \begin{enumerate}
              \item
                {\em Adding an update into the sequence.}
                Defined policy updates are added into the sequence list
                through the use of the following directive:

                \begin{vverbatim}
  seq add <update-id>([<entity-id>[, ...]]);
                \end{vverbatim}

                \noindent where $update$-$id$ is the identifier of a declared
                policy update and the $entity$-$id$ list is a comma-separated
                list of entity identifiers that will replace the variable
                identifiers that occur in the declaration of the policy
                update.

              \item
                {\em Listing the updates in the sequence.}
                The following directive may be used to list the current
                contents of the policy update sequence list.

                \begin{vverbatim}
  seq list;
                \end{vverbatim}

                This directive is answered with an ordinal list of policy
                updates in the form

                \begin{vverbatim}
  <n> <update-id>([<entity-id>[, ...]])
                \end{vverbatim}

                \noindent where $n$ is the ordinal index of the policy update
                in the sequence list starting at 0. $update$-$id$ is the
                policy update identifier and the $entity$-$id$ list is the
                comma-separated list of entity identifiers used to replace
                the variable identifier place-holders.

              \item
                {\em Removing an update from the sequence.}
                The syntax below shows the directive used to remove a
                policy update reference from the list. $n$ is the ordinal
                index of the policy update to be removed. Note that removing
                a policy update reference from the sequence list may change
                the ordinal index of other update references.

                \begin{vverbatim}
  seq del <n>;
                \end{vverbatim}

              \item
                {\em Computing an update sequence.}
                The policy updates in the sequence list does not get applied
                until the $compute$ directive is issued. The directive causes
                the policy update references in the sequence list to be
                applied one at a time in the same order that they appear in
                the list. The directive also causes the system to generate
                the policy base models against which query requests can be
                evaluated.

                \begin{vverbatim}
  compute;
                \end{vverbatim}
            \end{enumerate}

          \item
            {\bf Query Directives}

            A ground query expression may be issued against the current state
            of the policy base. This current state is derived after all the
            updates in the update sequence have been applied, one at a time,
            to the initial state. Query expressions are answered with a
            {\em true}, {\em false} or {\em unknown}, depending on whether
            the queried expression holds, its negation holds, or neither,
            respectively. Syntax is as follows:

            \begin{vverbatim}
  query <ground-exp>;
            \end{vverbatim}

        \end{itemize}

      \begin{vexample}
        \label{exam-langl-syntx}
        The following language ${\cal L}$ program code listing shows a
        simple rule-based document access control system scenario.

        In this example, the subject $alice$ is initially a member of the
        subject group $grp_2$, which is a subset of group $grp_1$. The
        group $grp_1$ also initially holds a $read$ access right for the
        object $file$. The constraint states that if the group $grp_1$ has
        $read$ access for $file$, and no other information is present to
        indicate that $grp_3$ does not have $write$ access for $file$, then
        the group $grp_1$ is granted $write$ access for $file$. For
        simplicity, we only consider one policy update $delete\_read$ and a
        few queries that are evaluated after the policy update is
        performed.

        \begin{vverbatim}
  /* entity declarations */

  ident sub alice;
  ident sub-grp grp1, grp2, grp3;
  ident acc read, write;
  ident obj file;

  /* initial fact statement */

  initially
    memb(alice, grp2),
    holds(grp1, read, file),
    subst(grp2, grp1);

  /* constraint statement */

  always holds(grp1, write, file)
    implied by
      holds(grp1, read, file)
    with absence
      !holds(grp3, write, file);

  /* policy update declaration */

  delete\_read(SG0, OS0)
    causes !holds(SG0, read, OS0);

  /* add delete\_read to policy update sequence list */

  seq add delete\_read(grp1, file);

  compute;

  /* queries */

  query holds(grp1, write, file);
  query holds(grp1, read, file);
  query holds(alice, write, file);
  query holds(alice, read, file);
        \end{vverbatim}
      \end{vexample}

    \section{Semantics}
      \label{sect-langl-seman}

      After giving a detailed syntactic definition of language ${\cal L}$,
      we now define its formal semantics. The semantics of language
      ${\cal L}$ is based on the well-known answer set (stable model)
      semantics of extended logic programs proposed by Gelfond and Lifschitz
      \cite{GEL1}. The definition below formally defines the answer set of a
      logic program.

      \begin{vdefinition}
        \label{defn-langl-ansrs}

        Given an extended logic program $\pi$ composed of ground facts and
        rules that do not have the negation-as-failure operator $not$ and a
        set ${\cal F}$ of all ground facts in $\pi$. A set $\lambda$ is
        then said to be an answer set of $\pi$ if it is the smallest set
        that satisfies the following conditions:

        \begin{enumerate}
          \item
            For any rule of the form $\rho_{0}$ $\leftarrow$ $\rho_{1}$,
            $\hdots$, $\rho_{n}$ where $n$ $\geq$ 1, if $\rho_{1}$, $\hdots$,
            $\rho_{n}$ $\in$ $\lambda$, then
            $\rho_{0}$ $\in$ $\lambda$.

          \item
            If $\lambda$ contains a pair of complementary facts (i.e. a fact
            and its negation), then $\lambda$ = ${\cal F}$.
        \end{enumerate}

        For a ground extended logic program $\pi$ that is composed of rules
        that may have the negation-as-failure operator $not$, a set $\lambda$
        is the answer set of $\pi$ if and only if $\lambda$ is the answer set
        of $\pi'$, where $\pi'$ is obtained from $\pi$ by deleting the
        following:

        \begin{enumerate}
          \item
            Each rule that contains a fact of the form $not$ $\rho$ in its
            body where $\rho$ $\in$ $\lambda$.
          \item
            All facts of the form $not$ $\rho$ in the bodies of the remaining
            rules.
        \end{enumerate}
      \end{vdefinition}

      \subsection{Domain Description of Language ${\cal L}$}
        \label{subs-langl-domai}

        The definition below gives a formal definition of the domain
        description of language ${\cal L}$.

        \begin{vdefinition}
          \label{defn-langl-domai}
          The domain description ${\cal D}_{\cal L}$ of language ${\cal L}$
          is defined as a finite set of ground initial state facts,
          constraint rules and policy update definitions.
        \end{vdefinition}

        In addition to the domain description ${\cal D}_{\cal L}$, language
        ${\cal L}$ also includes an additional ordered set: the sequence list
        $\psi$. The sequence list $\psi$ is an ordered set that contains a
        sequence of references to policy update definitions. Each policy
        update reference consists of the policy update identifier and a
        series of zero or more identifier entities to replace the variable
        place-holders in the policy update definitions.

      \subsection{Language ${\cal L}^{*}$}
        \label{subs-langl-langl}

        In language ${\cal L}$, the policy base is subject to change, which
        is triggered by the application of policy updates. Such changes bring
        forth the concept of policy base states. Conceptually, a state may be
        thought of as a set of facts and constraints of the policy base at a
        particular instant. The state transition notation below shows that a
        new state $PB'$ is generated from the current state $PB$ after the
        policy update $u$ is applied.

        \begin{vquote}
          $PB$ $\overrightarrow{_{u}}$ $PB'$
        \end{vquote}

        This concept of a state means that for every policy update applied
        to the policy base, a new instance of the policy base or a new set of
        facts and constraints are generated. To precisely define the
        underlying semantics of domain description ${\cal D}_{\cal L}$ in
        language ${\cal L}$, we introduce language ${\cal L}^{*}$, which is
        an extended logic program representation of language ${\cal L}$, with
        state as an explicit sort.

        Language ${\cal L}^{*}$ contains only one special state constant
        $S_{0}$ to represent the initial state of a given domain description.
        All other states are represented as a resulting state obtained by
        applying the $Res$ function. The $Res$ function takes a policy update
        reference $u$ ($u$ $\in$ $\psi$) and the current state $\sigma$ as
        input arguments and returns the resulting state $\sigma'$ after
        update $u$ has been applied to state $\sigma$:

        \begin{vquote}
          $\sigma'$ $=$ $Res$($u$, $\sigma$)
        \end{vquote}

        \noindent
        Given an initial state $S_{0}$ and a policy update sequence list
        $\psi$, each state $\sigma_{i}$ ($0$ $\leq$ $i$ $\leq$ $|\psi|$)
        may be represented as follows:

        \begin{vquote}
          $\sigma_{0}$ $=$ $S_{0}$

          $\sigma_{1}$ $=$ $Res$($u_{0}$, $\sigma_{0}$)

          $\vdots$

          $\sigma_{|\psi|}$ $=$
            $Res$($u_{|\psi| - 1}$, $\sigma_{|\psi| - 1}$)
        \end{vquote}

        \noindent
        Substituting each state with a recursive call to the $Res$ function,
        the final state $S_{|\psi|}$ is defined as follows:

        \begin{vquote}
          $S_{|\psi|}$ $=$
            $Res$($u_{|\psi| - 1}$, $Res$($\ldots$, $Res$($u_{0}$, $S_{0}$)))
        \end{vquote}

        \subsubsection{Entities}

          The entity set ${\cal E}$ is the union of six disjoint entity sets:
          single subject ${\cal E}_{ss}$, group subject ${\cal E}_{sg}$,
          single access right ${\cal E}_{as}$, group access right
          ${\cal E}_{ag}$, single object ${\cal E}_{os}$ and group object
          ${\cal E}_{og}$. Each entity in set ${\cal E}$ corresponds directly
          to the entity identifiers of language ${\cal L}$.

          \begin{vquote}
            ${\cal E}$ $=$
            ${\cal E}_{s}$ $\cup$ ${\cal E}_{a}$ $\cup$ ${\cal E}_{o}$

            ${\cal E}_{s}$ $=$ ${\cal E}_{ss}$ $\cup$ ${\cal E}_{sg}$

            ${\cal E}_{a}$ $=$ ${\cal E}_{as}$ $\cup$ ${\cal E}_{ag}$

            ${\cal E}_{o}$ $=$ ${\cal E}_{os}$ $\cup$ ${\cal E}_{og}$
          \end{vquote}

        \subsubsection{Atoms}

          The main difference between language ${\cal L}$ and language
          ${\cal L}^{*}$ lies in the definition of an atom. Atoms in language
          ${\cal L}^{*}$ represent a logical relationship of two to three
          entities, as with atoms of language ${\cal L}$. Furthermore, atoms
          of language ${\cal L}^{*}$ extends this definition by defining the
          state of the policy base in which the relationship holds. In this
          paper, atoms of language ${\cal L}^{*}$ are written with the
          hat character ($\hat{holds}$, $\hat{memb}$ and $\hat{subst}$) to
          differentiate from the atoms of language ${\cal L}$. The atom set
          ${\cal A}^{\sigma}$ is the set of all atoms in state $\sigma$.

          \begin{vquote}
            ${\cal A}^{\sigma}$ $=$
              ${\cal A}^{\sigma}_{h}$ $\cup$
              ${\cal A}^{\sigma}_{m}$ $\cup$
              ${\cal A}^{\sigma}_{s}$

            ${\cal A}^{\sigma}_{h}$ $=$
              $\{\hat{holds}$($s$, $a$, $o$, $\sigma$) $\mid$
                $s$ $\in$ ${\cal E}_{s}$,
                $a$ $\in$ ${\cal E}_{a}$,
                $o$ $\in$ ${\cal E}_{o}\}$

            ${\cal A}^{\sigma}_{m}$ $=$
             ${\cal A}^{\sigma}_{ms}$ $\cup$
             ${\cal A}^{\sigma}_{ma}$ $\cup$
             ${\cal A}^{\sigma}_{mo}$

            ${\cal A}^{\sigma}_{s}$ $=$
              ${\cal A}^{\sigma}_{ss}$ $\cup$
              ${\cal A}^{\sigma}_{sa}$ $\cup$
              ${\cal A}^{\sigma}_{so}$

            ${\cal A}^{\sigma}_{ms}$ $=$
              $\{\hat{memb}$($e$, $g$, $\sigma$) $\mid$
                $e$ $\in$ ${\cal E}_{ss}$,
                $g$ $\in$ ${\cal E}_{sg}\}$

            ${\cal A}^{\sigma}_{ma}$ $=$
              $\{\hat{memb}$($e$, $g$, $\sigma$) $\mid$
                $e$ $\in$ ${\cal E}_{as}$,
                $g$ $\in$ ${\cal E}_{ag}\}$

            ${\cal A}^{\sigma}_{mo}$ $=$
              $\{\hat{memb}$($e$, $g$, $\sigma$) $\mid$
                $e$ $\in$ ${\cal E}_{os}$,
                $g$ $\in$ ${\cal E}_{og}\}$

            ${\cal A}^{\sigma}_{ss}$ $=$
              $\{\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$) $\mid$
                $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{sg}\}$

            ${\cal A}^{\sigma}_{sa}$ $=$
              $\{\hat{subst}(g_{1}, g_{2}, \sigma)$ $\mid$
                $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{ag}\}$

            ${\cal A}^{\sigma}_{so}$ $=$
              $\{\hat{subst}(g_{1}, g_{2}, \sigma)$ $\mid$
                $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{og}\}$
          \end{vquote}

        \subsubsection{Facts}

          A fact is a logical statement that makes a claim that an atom either
          holds or does not hold at a particular state. A fact that does not
          hold is said to be a {\em classically negated} fact \cite{GEL2}. The
          following is the formal definition of fact $\hat{\rho}$ in state
          $\sigma$:

          \begin{vquote}
            $\hat{\rho}^{\sigma}$ $=$
              $[\lnot]$$\hat{\alpha}$,
              $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$
          \end{vquote}

      \subsection{Translating Language ${\cal L}$ to Language ${\cal L^{*}}$}
        \label{subs-langl-trans}

        Given a domain description ${\cal D_{L}}$ of language ${\cal L}$, we
        translate ${\cal D_{L}}$ into an extended logic program of language
        ${\cal L^{*}}$, as denoted by $Trans$(${\cal D_{L}}$). The semantics
        of ${\cal D_{L}}$ are provided by the answer sets of the extended
        logic program $Trans$(${\cal D_{L}}$). Before we can fully define
        $Trans$(${\cal D}_{\cal L}$), we must first define the following
        functions:

        The $CopyAtom$() function takes two arguments: an atom $\hat{\alpha}$
        of language ${\cal L}^{*}$ at some state $\sigma$ and another state
        $\sigma'$. The function returns an equivalent atom of the same type
        and with the same entities, but in the new state specified.

        \begin{vquote}
          $CopyAtom$($\hat{\alpha}$, $\sigma'$)
          $=$
          \begin{math}
            \begin{cases}
              \mbox{
                $\hat{holds}$($s$, $a$, $o$, $\sigma'$),
                  if $\hat{\alpha}$ $=$
                    $\hat{holds}$($s$, $a$, $o$, $\sigma$)
              } \\
              \mbox{
                $\hat{memb}$($e$, $g$, $\sigma'$),
                  if $\hat{\alpha}$ $=$
                    $\hat{memb}$($e$, $g$, $\sigma$)
              } \\
              \mbox{
                $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma'$),
                  if $\hat{\alpha}$ $=$
                    $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$)
              }
            \end{cases}
          \end{math}
        \end{vquote}

        Another function, $TransAtom$(), takes an atom $\alpha$ of language
        ${\cal L}$ and an arbitrary state $\sigma$ and returns the equivalent
        atom of language ${\cal L}^{*}$.

        \begin{vquote}
          $TransAtom$($\alpha$, $\sigma$)
          $=$
          \begin{math}
            \begin{cases}
              \mbox{
                $\hat{holds}$($s$, $a$, $o$, $\sigma$),
                  if $\alpha$ $=$ $holds$($s$, $a$, $o$)
              } \\
              \mbox{
                $\hat{memb}$($e$, $g$, $\sigma$),
                  if $\alpha$ $=$ $memb$($e$, $g$)
              } \\
              \mbox{
                $\hat{subst}$($g_{1}$, $g_{2}$, $\sigma$),
                  if $\alpha$ $=$ $subst$($g_{1}$, $g_{2}$)
              }
            \end{cases}
          \end{math}
        \end{vquote}

        The $TransFact$() function is similar to the $TransAtom$()
        function, but instead of translating an atom, it takes a fact
        from language ${\cal L}$ and a state then returns the equivalent
        fact in language ${\cal L}^{*}$.

        \subsubsection{Initial Fact Rules}

          The process of translating initial fact expressions of language
          ${\cal L}$ to language ${\cal L}^{*}$ rules is a trivial procedure:
          translate each fact that make up the initial fact expression of
          language ${\cal L}$ with its corresponding equivalent initial state
          atom of language ${\cal L}^{*}$. Given the following
          {\em initially} statement in language ${\cal L}$:

          \begin{vverbatim}
  initially \(\rho\sb{0}\), \ldots, \(\rho\sb{n}\);
          \end{vverbatim}

          \noindent
          The language ${\cal L}^{*}$ translation of this statement is shown
          below:

          \begin{vquote}
            $\hat{\rho}_{0}$ $\leftarrow$

            $\vdots$

            $\hat{\rho}_{n}$ $\leftarrow$
          \end{vquote}

          \begin{vquote}
            where

            \hspace{1em}
            $\hat{\rho}_{i}$ $=$ $TransFact$($\rho_{i}$, $S_{0}$),

            \hspace{1em}
            $0$ $\leq$ $i$ $\leq$ $n$
          \end{vquote}

          As shown above, the number of initial fact rules generated from the
          translation is the number of facts $n$ in the given language
          ${\cal L}$ initial fact expression. The following code shows a
          more realistic example of language ${\cal L}$ {\em initially}
          statements:

          \begin{vverbatim}
  initially
    holds(admins, read, sys\_data),
    memb(alice, admins);

  initially
    memb(bob, admins);
          \end{vverbatim}

          \noindent
          In language ${\cal L}^{*}$, the above statements are translated to:

          \begin{vquote}
            $\hat{holds}$($admins$, $read$, $sys\_data$, $S_{0}$)
              $\leftarrow$

            $\hat{memb}$($alice$, $admins$, $S_{0}$) $\leftarrow$

            $\hat{memb}$($bob$, $admins$, $S_{0}$) $\leftarrow$
          \end{vquote}

        \subsubsection{Constraint Rules}

          Each constraint rule in language ${\cal L}$ is expressed as a
          series of logical rules in language ${\cal L}^{*}$. Given that all
          variable occurrences have been grounded to entity identifiers, a
          constraint in language ${\cal L}$, with $n_0$, $n_1$, $n_2$ $\geq$
          $0$ may be represented as:

          \begin{vverbatim}
  always \(\rho\sb{0\sb{0}}\), \ldots, \(\rho\sb{0\sb{n\sb{0}}}\)
    implied by \(\rho\sb{1\sb{0}}\), \ldots, \(\rho\sb{1\sb{n\sb{1}}}\)
    with absence \(\rho\sb{2\sb{0}}\), \ldots, \(\rho\sb{2\sb{n\sb{2}}}\);
          \end{vverbatim}

          Each fact in the {\em always} clause of language ${\cal L}$
          corresponds to a new rule, where it is the consequent. Each of
          these new rules will have expression $\rho_{1}$ in the
          {\em implied by} clause as the positive premise and the expression
          $\rho_{2}$ in the {\em with absence} clause as the negative
          premise.

          \begin{vquote}
            $\rho_{0_{0}}$ $\leftarrow$
              $\rho_{1_{0}}$, \ldots, $\rho_{1_{n_1}}$,
              $not$ $\rho_{2_{0}}$, \ldots, $not$ $\rho_{2_{n_2}}$

            $\vdots$

            $\rho_{0_{n_{0}}}$ $\leftarrow$
              $\rho_{1_{0}}$, \ldots, $\rho_{1_{n_1}}$,
              $not$ $\rho_{2_{0}}$, \ldots, $not$ $\rho_{2_{n_2}}$
          \end{vquote}

          Under the definition of constraint rules, each of the rules listed
          above must be made to hold in all states as defined by the sequence
          list $\psi$. This can be accomplished by translating each of the
          above rules to a set of $|\psi|$ rules, one for each state.

          \begin{vquote}
            $\hat{\rho}^{S_{0}}_{0_{0}}$ $\leftarrow$
              $\hat{\rho}^{S_{0}}_{1_{0}}$, \ldots,
                $\hat{\rho}^{S_{0}}_{1_{n_1}}$,
              $not$ $\hat{\rho}^{S_{0}}_{2_{0}}$, \ldots,
                $not$ $\hat{\rho}^{S_{0}}_{2_{n_2}}$

            $\vdots$

            $\hat{\rho}^{S_{|\psi|}}_{0_{0}}$ $\leftarrow$
              $\hat{\rho}^{S_{|\psi|}}_{1_{0}}$, \ldots,
                $\hat{\rho}^{S_{|\psi|}}_{1_{n_1}}$,
              $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{0}}$, \ldots,
                $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{n_2}}$

            $\vdots$

            $\hat{\rho}^{S_{0}}_{0_{n_0}}$ $\leftarrow$
              $\hat{\rho}^{S_{0}}_{1_{0}}$, \ldots,
                $\hat{\rho}^{S_{0}}_{1_{n_1}}$,
              $not$ $\hat{\rho}^{S_{0}}_{2_{0}}$, \ldots,
                $not$ $\hat{\rho}^{S_{0}}_{2_{n_2}}$

            $\vdots$

            $\hat{\rho}^{S_{|\psi|}}_{0_{n_0}}$ $\leftarrow$
              $\hat{\rho}^{S_{|\psi|}}_{1_{0}}$, \ldots,
                $\hat{\rho}^{S_{|\psi|}}_{1_{n_1}}$,
              $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{0}}$, \ldots,
                $not$ $\hat{\rho}^{S_{|\psi|}}_{2_{n_2}}$
          \end{vquote}

          \begin{vquote}
            where

            \hspace{1em}
            $\hat{\rho}^{\sigma}_{0_i}$ $=$
              $TransFact$($\rho_{0_i}$, $\sigma$), $0$ $\leq$ $i$ $\leq$ $n_0$,

            \hspace{1em}
            $\hat{\rho}^{\sigma}_{1_j}$ $=$
              $TransFact$($\rho_{1_j}$, $\sigma$), $0$ $\leq$ $j$ $\leq$ $n_1$,

            \hspace{1em}
            $\hat{\rho}^{\sigma}_{2_k}$ $=$
              $TransFact$($\rho_{2_k}$, $\sigma$), $0$ $\leq$ $k$ $\leq$ $n_2$,

            \hspace{1em}
            $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
          \end{vquote}

          For a given language ${\cal L}$ constraint rule, the number of
          constraint rules generated in the translation is:

          \begin{quote}
            $n_0$ $|\psi|$
          \end{quote}

          \begin{quote}
            where

            \hspace{1em}
            $n_0$ is the number of facts in the {\em always} clause

            \hspace{1em}
            $|\psi|$ is the number of states
          \end{quote}

          The example below shows how the following language ${\cal L}$ code
          fragment is translated to language ${\cal L}^{*}$:

          \begin{vverbatim}
  always
    holds(alice, read, data),
    holds(alice, write, data)
  implied by
    memb(alice, admin)
  with absence
    !holds(alice, own, data);
          \end{vverbatim}

          \noindent
          Given a policy update reference in the sequence list $\psi$ (i.e.
          $|\psi|$ = $1$), the language ${\cal L}^{*}$ equivalent is as
          follows:

          \begin{vquote}
            $\hat{holds}$($alice$, $read$, $data$, $S_{0}$) $\leftarrow$

            \hspace{1em}
            $\hat{memb}$($alice$, $admin$, $S_{0}$),
            $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{0}$)

            $\hat{holds}$($alice$, $write$, $data$, $S_{0}$) $\leftarrow$

            \hspace{1em}
            $\hat{memb}$($alice$, $admin$, $S_{0}$),
            $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{0}$)
          \end{vquote}

          \begin{vquote}
            $\hat{holds}$($alice$, $read$, $data$, $S_{1}$) $\leftarrow$

            \hspace{1em}
            $\hat{memb}$($alice$, $admin$, $S_{1}$),
            $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{1}$)

            $\hat{holds}$($alice$, $write$, $data$, $S_{1}$) $\leftarrow$

            \hspace{1em}
            $\hat{memb}$($alice$, $admin$, $S_{1}$),
            $not$ $\lnot\hat{holds}$($alice$, $own$, $data$, $S_{1}$)
          \end{vquote}

        \subsubsection{Policy Update Rules}

          Given that $n_0$, $n_1$ $\geq$ $0$, all occurrences of variable
          place-holders grounded to entity identifiers, a policy update $u$
          in language ${\cal L}$ is in the form:

          \begin{vverbatim}
  \(u\) causes \(\rho\sb{0\sb{0}}\), \ldots, \(\rho\sb{0\sb{n\sb{0}}}\)
  if \(\rho\sb{1\sb{0}}\), \ldots, \(\rho\sb{1\sb{n\sb{1}}}\);
          \end{vverbatim}

          In language ${\cal L}^{*}$, such policy updates may be represented
          as a set of implications, with each fact $\rho_{0}$ in the
          postcondition expression as the consequent and precondition
          expression $\rho_{1}$ as the premise. However, the translation
          process must also take into account that the premise of the
          implication holds in the state before the policy update is applied
          and that the consequent holds in the state after the application.

          \begin{vquote}
            $\hat{\rho}_{0_{0}}$ $\leftarrow$
              $\hat{\rho}_{1_{0}}$, \ldots, $\hat{\rho}_{1_{n_1}}$

            $\vdots$

            $\hat{\rho}_{0_{n_0}}$ $\leftarrow$
              $\hat{\rho}_{1_{0}}$, \ldots, $\hat{\rho}_{1_{n_1}}$
          \end{vquote}

          \begin{vquote}
            where

            \hspace{1em}
            $\hat{\rho}_{0_i}$ $=$
              $TransFact$($\rho_{0_i}$, $Res$($u$, $\sigma$)),
              $0$ $\leq$ $i$ $\leq$ $n_0$,

            \hspace{1em}
            $\hat{\rho}_{1_j}$ $=$
              $TransFact$($\rho_{1_j}$, $\sigma$),
              $0$ $\leq$ $j$ $\leq$ $n_1$
          \end{vquote}

          Intuitively, a given language ${\cal L}$ policy update definition
          will generate $n_0$ policy update rules in language ${\cal L^{*}}$,
          where $n_0$ is the number of facts in the postcondition expression.
          For example, given the following 2 language ${\cal L}$ policy
          update definitions:

          \begin{vverbatim}
  grant\_read()
    causes holds(alice, read, file)
    if memb(alice, readers);

  grant\_write()
    causes holds(alice, write, file)
    if memb(alice, writers);
          \end{vverbatim}

          Given the update sequence list $\psi$ contains
          \{$grant\_read$, $grant\_write$\}, the above statements are written
          in language ${\cal L}^{*}$ as:

          \begin{vquote}
            $\hat{holds}$($alice$, $read$, $file$, $S_{1}$) $\leftarrow$
            $\hat{memb}$($alice$, $readers$, $S_{0}$)
          \end{vquote}

          \begin{vquote}
            $\hat{holds}$($alice$, $write$, $file$, $S_{2}$) $\leftarrow$
            $\hat{memb}$($alice$, $writers$, $S_{1}$)
          \end{vquote}

        \subsubsection{Additional Constraints}

          In addition to the translations discussed above, there are a few
          other implicit constraint rules implied by language ${\cal L}$
          that need to be explicitly defined in language ${\cal L}^{*}$.

          \begin{enumerate}
            \item
              {\em Inheritance Rules.}
              All properties held by a group is inherited by all the members
              and subsets of that group. This rule is easy to apply for
              subject group entities. However, careful attention must be
              given to access right and object groups. A subject holding an
              access right for an object group implies that the subject also
              holds that access right for all objects in the object group.
              Similarly, a subject holding an access right group for a
              particular object implies that the subject holds all access
              rights contained in the access right group for that object.

              A conflict is encountered when a particular property is to be
              inherited by an entity from a group of which it is a member or
              subset, and the contained entity already holds the negation of
              that property. This conflict is resolved by giving negative
              facts higher precedence over its positive counterpart: by
              allowing member or subset entities to inherit its parent
              group's properties only if the entities do not already hold
              the negation of those properties.

              The following are the inheritance constraint rules to allow the
              properties held by a group to propagate to its members and
              subsets that do not already hold the negation of the
              properties.

              \begin{enumerate}
                \item
                  Subject Group Membership Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($ss$, $sg$, $a$, $o$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($ss$, $a$, $o$, $\sigma$) $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($sg$, $a$, $o$, $\sigma$),
                    $\hat{memb}$($ss$, $sg$, $\sigma$),
                    $not$ $\lnot\hat{holds}$($ss$, $a$, $o$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($ss$, $a$, $o$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($sg$, $a$, $o$, $\sigma$),
                    $\hat{memb}$($ss$, $sg$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $ss$ $\in$ ${\cal E}_{ss}$,

                    \hspace{1em}
                    $sg$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Access Right Group Membership Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $as$, $ag$, $o$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $as$, $o$, $\sigma$) $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $ag$, $o$, $\sigma$),
                    $\hat{memb}$($as$, $ag$, $\sigma$),
                    $not$ $\lnot\hat{holds}$($s$, $as$, $o$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $as$, $o$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $ag$, $o$, $\sigma$),
                    $\hat{memb}$($as$, $ag$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $as$ $\in$ ${\cal E}_{as}$,

                    \hspace{1em}
                    $ag$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $S_{0}$ ${\leq}$ ${\sigma}$ ${\leq}$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Object Group Membership Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $a$, $os$, $og$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $a$, $os$, $\sigma$) $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $a$, $og$, $\sigma$),
                    $\hat{memb}$($os$, $og$, $\sigma$),
                    $not$ $\lnot\hat{holds}$($s$, $a$, $os$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $a$, $os$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $a$, $og$, $\sigma$),
                    $\hat{memb}$($os$, $og$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $os$ $\in$ ${\cal E}_{os}$,

                    \hspace{1em}
                    $og$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $S_{0}$ ${\leq}$ ${\sigma}$ ${\leq}$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Subject Group Subset Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($sg_{0}$, $sg_{1}$, $a$, $o$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($sg_{0}$, $a$, $o$, $\sigma$) $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($sg_{1}$, $a$, $o$, $\sigma$),
                    $\hat{subst}$($sg_{0}$, $sg_{1}$, $\sigma$),
                    $not$ $\lnot\hat{holds}$($sg_{0}$, $a$, $o$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($sg_{0}$, $a$, $o$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($sg_{1}$, $a$, $o$, $\sigma$),
                    $\hat{subst}$($sg_{0}$, $sg_{1}$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $sg_{0}$, $sg_{1}$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $sg_{0}$ $\neq$ $sg_{1}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq S_{|\psi|}$
                  \end{vquote}

                \item
                  Access Right Group Subset Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $ag_{0}$, $ag_{1}$, $o$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $ag_{0}$, $o$, $\sigma$) $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $ag_{1}$, $o$, $\sigma$),
                    $\hat{subst}$($ag_{0}$, $ag_{1}$, $\sigma$),
                    $not$ $\lnot$ $\hat{holds}$($s$, $ag_{0}$, $o$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $ag_{0}$, $o$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $ag_{1}$, $o$, $\sigma$),
                    $\hat{subst}$($ag_{0}$, $ag_{1}$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $ag_{0}$, $ag_{1}$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $ag_{0}$ $\neq$ $ag_{1}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Object Group Subset Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $a$, $og_{0}$, $og_{1}$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $a$, $og_{0}$, $\sigma$) $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $a$, $og_{1}$, $\sigma$),
                    $\hat{subst}$($og_{0}$, $og_{1}$, $\sigma$),
                    $not$ $\lnot\hat{holds}$($s$, $a$, $og_{0}$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $a$, $og_{0}$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $a$, $og_{1}$, $\sigma$),
                    $\hat{subst}$($og_{0}$, $og_{1}$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $og_{0}$, $og_{1}$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $og_{0}$ $\neq$ $og_{1}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}
              \end{enumerate}

            \item
              {\em Transitivity Rules.}
              Given three distinct groups $g_0$, $g_1$ and $g_2$. If $g_0$ is
              a subset of $g_1$ and $g_1$ is a subset of $g_2$, then $g_0$
              must also be a subset of $g_2$. The following rules ensure that
              the transitive property of subject, access right and object
              groups holds:

              \begin{enumerate}
                \item
                  Subject Group Transitivity Rules

                  \begin{vquote}
                    $\forall$ ($sg_{0}$, $sg_{1}$, $sg_{2}$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($sg_{0}$, $sg_{2}$, $\sigma$) $\leftarrow$
                    $\hat{subst}$($sg_{0}$, $sg_{1}$, $\sigma$),
                    $\hat{subst}$($sg_{1}$, $sg_{2}$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $sg_{0}$, $sg_{1}$, $sg_{2}$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $sg_{0}$ $\neq$ $sg_{1}$ $\neq$ $sg_{2}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Access Right Group Transitivity Rules

                  \begin{vquote}
                    $\forall$ ($ag_{0}$, $ag_{1}$, $ag_{2}$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($ag_{0}$, $ag_{2}$, $\sigma$) $\leftarrow$
                    $\hat{subst}$($ag_{0}$, $ag_{1}$, $\sigma$),
                    $\hat{subst}$($ag_{1}$, $ag_{2}$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $ag_{0}$, $ag_{1}$, $ag_{2}$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $ag_{0}$ $\neq$ $ag_{1}$ $\neq$ $ag_{2}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Object Group Transitivity Rules

                  \begin{vquote}
                    $\forall$ ($og_{0}$, $og_{1}$, $og_{2}$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($og_{0}$, $og_{2}$, $\sigma$) $\leftarrow$
                    $\hat{subst}$($og_{0}$, $og_{1}$, $\sigma$),
                    $\hat{subst}$($og_{1}$, $og_{2}$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $og_{0}$, $og_{1}$, $og_{2}$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $og_{0}$ $\neq$ $og_{1}$ $\neq$ $og_{2}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}
              \end{enumerate}

            \item
              {\em Inertial Rules.}
              Intuitively, all facts in the current state that are not
              affected by a policy update should be carried over to the
              next state after the update. In language ${\cal L}^{*}$,
              this rule must be explicitly defined as a constraint. Formally,
              the inertial rules are expressed as follows:

              \begin{vquote}
                $\forall$ ($\hat{\alpha}$,$u$) $\exists$$\hat{\alpha}'$,
              \end{vquote}

              \begin{vquote}
                $\hat{\alpha}'$ $\leftarrow$
                  $\hat{\alpha}$, $not$ $\lnot$ $\hat{\alpha}'$

                $\lnot$ $\hat{\alpha}'$ $\leftarrow$
                  $\lnot$ $\hat{\alpha}$, $not$ $\hat{\alpha}'$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$,

                \hspace{1em}
                $u$ $\in$ $\psi$,

                \hspace{1em}
                $\hat{\alpha}'$ $=$
                $CopyAtom$($\hat{\alpha}$, $Res$($u$, $\sigma$))
              \end{vquote}

            \item
              {\em Reflexivity Rules.}
              Finally, explicit rules must be given to show that every set is
              a subset of itself.

              \begin{vquote}
                $\forall$ ($g$, $\sigma$),
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($g$, $g$, $\sigma$)
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $g$ $\in$
                  (${\cal E}_{sg}$ $\cup$ ${\cal E}_{ag}$ $\cup$ ${\cal E}_{og}$),

                \hspace{1em}
                $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
              \end{vquote}
          \end{enumerate}

        \begin{vexample}
          \label{exam-langl-seman}
          The following shows the language ${\cal L^{*}}$ translation of the
          language ${\cal L}$ program listing shown in Example
          \ref{exam-langl-syntx}.

          \begin{enumerate}
            \item
              Initial Fact Rules

              \begin{vquote}
                $\hat{memb}(alice, grp_2, S_{0}) \leftarrow$

                $\hat{holds}(grp_1, read, file,S_{0}) \leftarrow$

                $\hat{subst}(grp_2, grp_1, S_{0}) \leftarrow$
              \end{vquote}

            \item
              Constraint Rules

              \begin{vquote}
                % constraints (S0)
                $\hat{holds}(grp_1, write, file, S_{0})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_1, read, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_3, write, file, S_{0})$
              \end{vquote}

              \begin{vquote}
                % constraints (S1)
                $\hat{holds}(grp_1, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_1, read, file, S_{1})$,
                $not$ $\lnot\hat{holds}(grp_3, write, file, S_{1})$
              \end{vquote}

            \item
              Policy Update Rules

              \begin{vquote}
                $\lnot\hat{holds}(grp_1, read, file, S_{1})$ $\leftarrow$
              \end{vquote}
            \item
              Inheritance Rules

              \begin{vquote}
                % inheritance rules (positive, read, S0)
                $\hat{holds}(alice, read, file, S_{0})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_1, read, file, S_{0})$,
                $\hat{memb}(alice, grp_1, S_{0})$,

                \hspace{1em}
                $not$ $\lnot\hat{holds}(alice, read, file, S_{0})$
              \end{vquote}

              \begin{vquote}
                % inheritance rules (negative, read, S0)
                $\lnot\hat{holds}(alice, read, file, S_{0})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_1, read, file, S_{0})$,
                $\hat{memb}(alice, grp_1, S_{0})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                % inheritance rules (positive, write, S1)
                $\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_3, write, file, S_{1})$,
                $\hat{memb}(alice, grp_3, S_{1})$,

                \hspace{1em}
                $not$ $\lnot\hat{holds}(alice, write, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inheritance rules (negative, write, S1)
                $\lnot\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_3, write, file, S_{1})$,
                $\hat{memb}(alice, grp_3, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inheritance rules (subset positive, read, S0)
                $\hat{holds}(grp_1, read, file, S_{0})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_2, read, file, S_{0})$,
                $\hat{subst}(grp_1, grp_2, S_{0})$

                \hspace{1em}
                $not$ $\lnot\hat{holds}(grp_1, read, file, S_{0})$,
              \end{vquote}

              \begin{vquote}
                % inheritance rules (subset negative, read, S0)
                $\lnot\hat{holds}(grp_1, read, file, S_{0})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_2, read, file, S_{0})$,
                $\hat{subst}(grp_1, grp_2, S_{0})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                % inheritance rules (subset positive, write, S1)
                $\hat{holds}(grp_3, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_2, write, file, S_{1})$,
                $\hat{subst}(grp_3, grp2, S_{1})$

                \hspace{1em}
                $not$ $\lnot\hat{holds}(grp_3, write, file, S_{1})$,
              \end{vquote}

              \begin{vquote}
                % inheritance rules (subset negative, write, S1)
                $\lnot\hat{holds}(grp_3, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_2, write, file, S_{1})$,
                $\hat{subst}(grp_3, grp_2, S_{1})$
              \end{vquote}

            \item
              Transitivity Rules

              \begin{vquote}
                $\hat{subst}(grp_1, grp_3, S_{0})$ $\leftarrow$
                $\hat{subst}(grp_1, grp_2, S_{0})$,
                $\hat{subst}(grp_2, grp_3, S_{0})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}(grp_3, grp_1, S_{0})$ $\leftarrow$
                $\hat{subst}(grp_3, grp_2, S_{0})$,
                $\hat{subst}(grp_2, grp_1, S_{0})$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}(grp_1, grp_3, S_{1})$ $\leftarrow$
                $\hat{subst}(grp_1, grp_2, S_{1})$,
                $\hat{subst}(grp_2, grp_3, S_{1})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}(grp_3, grp_1, S_{1})$ $\leftarrow$
                $\hat{subst}(grp_3, grp_2, S_{1})$,
                $\hat{subst}(grp_2, grp_1, S_{1})$
              \end{vquote}

            \item
              Inertial Rules

              \begin{vquote}
                % inertial rule holds(alice, read, file)
                $\hat{holds}(alice, read, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(alice, read, file, S_{0})$,
                $not$ $\lnot\hat{holds}(alice, read, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !holds(alice, read, file)
                $\lnot\hat{holds}(alice, read, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(alice, read, file, S_{0})$,
                $not$ $\lnot\hat{holds}(alice, read, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule holds(alice, write, file)
                $\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(alice, write, file, S_{0})$,
                $not$ $\lnot\hat{holds}(alice, write, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !holds(alice, write, file)
                $\lnot\hat{holds}(alice, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(alice, write, file, S_{0})$,
                $not$ $\lnot\hat{holds}(alice, write, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule holds(grp1, read, file)
                $\hat{holds}(grp_1, read, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_1, read, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp1, read, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !holds(grp1, read, file)
                $\lnot\hat{holds}(grp_1, read, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_1, read, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_1, read, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                % inertial rule holds(grp3, read, file)
                $\hat{holds}(grp_3, read, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_3, read, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_3, read, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !holds(grp3, read, file)
                $\lnot\hat{holds}(grp_3, read, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_3, read, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_3, read, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule holds(grp1, write, file)
                $\hat{holds}(grp_1, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp_1, write, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_1, write, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !holds(grp1, write, file)
                $\lnot\hat{holds}(grp_1, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_1, write, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_1, write, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                % inertial rule holds(grp3, write, file)
                $\hat{holds}(grp_3, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{holds}(grp3, write, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_3, write, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !holds(grp3, write, file)
                $\lnot\hat{holds}(grp_3, write, file, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{holds}(grp_3, write, file, S_{0})$,
                $not$ $\lnot\hat{holds}(grp_3, write, file, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule memb(alice, grp1)
                $\hat{memb}(alice, grp_1, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{memb}(alice, grp_1, S_{0})$,
                $not$ $\lnot\hat{memb}(alice, grp_1, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !memb(alice, grp1)
                $\lnot \hat{memb}(alice, grp_1, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{memb}(alice, grp_1, S_{0})$,
                $not$ $\hat{memb}(alice, grp_1, S_{1})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                % inertial rule memb(alice, grp3)
                $\hat{memb}(alice, grp_3, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{memb}(alice, grp_3, S_{0})$,
                $not$ $\lnot\hat{memb}(alice, grp_3, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !memb(alice, grp3)
                $\lnot\hat{memb}(alice, grp_3, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{memb}(alice, grp_3, S_{0})$,
                $not$ $\hat{memb}(alice, grp_3, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule subst(grp1, grp1)
                $\hat{subst}(grp1, grp_1, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{subst}(grp1, grp_1, S_{0})$,
                $not$ $\lnot\hat{subst}(grp_1, grp_1, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !subst(grp1, grp1)
                $\lnot\hat{subst}(grp_1, grp_1, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{memb}(grp_1, grp_1, S_{0})$,
                $not$ $\hat{memb}(grp_1, grp_1, S_{1})$
              \end{vquote}

              \begin{vquote}
                \hspace{2em}$\vdots$
              \end{vquote}

              \begin{vquote}
                % inertial rule subst(grp3, grp3)
                $\hat{subst}(grp_3, grp_3, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\hat{subst}(grp_3, grp_3, S_{0})$,
                $not$ $\lnot\hat{subst}(grp_3, grp_3, S_{1})$
              \end{vquote}

              \begin{vquote}
                % inertial rule !subst(grp3, grp3)
                $\lnot\hat{subst}(grp_3, grp_3, S_{1})$ $\leftarrow$

                \hspace{1em}
                $\lnot\hat{memb}(grp_3, grp_3, S_{0})$,
                $not$ $\hat{memb}(grp_3, grp_3, S_{1})$
              \end{vquote}

            \item
              Reflexivity Rules

              \begin{vquote}
                $\hat{subset}(grp_1, grp_1, S_{0})$ $\leftarrow$

                $\hat{subset}(grp_2, grp_2, S_{0})$ $\leftarrow$

                $\hat{subset}(grp_3, grp_3, S_{0})$ $\leftarrow$

                $\hat{subset}(grp_1, grp_1, S_{1})$ $\leftarrow$

                $\hat{subset}(grp_2, grp_2, S_{1})$ $\leftarrow$

                $\hat{subset}(grp_3, grp_3, S_{1})$ $\leftarrow$
             \end{vquote}
          \end{enumerate}
        \end{vexample}

        \begin{vdefinition}
          \label{defn-langl-trans}
          Given a domain description ${\cal D_{L}}$ of language ${\cal L}$,
          the language ${\cal L^{*}}$ translation $Trans$(${\cal D_{L}}$)
          is an extended logic program of language ${\cal L}$ consisting of:
          (1) initial fact rules, (2) constraint rules, (3) policy update
          rules, (4) inheritance rules, (5) transitivity rules, (6) inertial
          rules, and (7) reflexivity rules as described above.
        \end{vdefinition}

        Note that given a domain description ${\cal D_{L}}$, the translation
        $Trans$(${\cal D_{L}}$) may contain more rules than the original
        statements in ${\cal D_{L}}$. However, as the theorem below defines
        the maximum number of rules generated in a translation
        $Trans$(${\cal D_{L}}$), it shows that the size of a translated
        domain $|$$Trans$(${\cal D_{L}}$)$|$ can only be polynomially larger
        than the size of the given domain $|$${\cal D_{L}}$$|$. Therefore,
        from a computational viewpoint, computing the answer sets of
        $Trans$(${\cal D_{L}}$) is always feasible.

        \begin{vtheorem}{Translation Size}
          \label{theo-langl-tsize}
          Given a domain description ${\cal D_{L}}$; the sets $\Gamma_{int}$,
          $\Gamma_{con}$ and $\Gamma_{upd}$ containing the initially,
          constraint and policy update statements in ${\cal D_{L}}$,
          respectively; the set ${\cal E}$ containing all the entities in
          ${\cal D_{L}}$, including its subsets ${\cal E}_{s}$,
          ${\cal E}_{a}$, ${\cal E}_{s}$, ${\cal E}_{ss}$, ${\cal E}_{as}$,
          ${\cal E}_{os}$, ${\cal E}_{sg}$, ${\cal E}_{ag}$, ${\cal E}_{og}$;
          the set ${\cal A}$ containing all the atoms in ${\cal D_{L}}$; the
          maximum number of facts $Max$($\Gamma_{int}$) in the expression of
          any {\em initially} statement in $\Gamma_{int}$; the maximum
          number of facts $Max$($\Gamma_{con}$) in the {\em always} clause
          expression of any constraint statement in $\Gamma_{con}$; the
          maximum number of facts $Max$($\Gamma_{upd}$) in the postcondition
          expression of any policy update statement in $\Gamma_{upd}$; and
          finally the policy update sequence list $\psi$, then the size of
          the translation $Trans$(${\cal D_{L}}$) is:

          \begin{vquote}
            $|$$Trans$(${\cal D_{L}}$)$|$ $\leq$

            % initially
            \hspace{1em}
            $Max$($\Gamma_{int}$) $|\Gamma_{int}|$ $+$

            % constraints
            \hspace{1em}
            $|\psi|$ $Max$($\Gamma_{con}$) $|\Gamma_{con}|$ $+$

            % policy updates
            \hspace{1em}
            $|\psi|$ $Max$($\Gamma_{upd}$) $+$

            % membership inheritance
            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{ss}|$ $|{\cal E}_{sg}|$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{as}|$ $|{\cal E}_{ag}|$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{os}|$ $|{\cal E}_{og}|$ $+$

            % subset inheritance
            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{sg}|^{2}$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{ag}|^{2}$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{og}|^{2}$ $+$

            % transitivity rules
            \hspace{1em}
            $|\psi|$
            $($$|{\cal E}_{sg}|^{3}$ $+$
            $|{\cal E}_{ag}|^{3}$ $+$
            $|{\cal E}_{og}|^{3}$$)$ $+$

            % inertial rules
            \hspace{1em}
            $2$ $|\psi|$ $|{\cal A}|$ $+$

            % reflexivity rules
            \hspace{1em}
            $|\psi|$
            $($$|{\cal E}_{sg}|$ $+$ $|{\cal E}_{ag}|$ $+$ $|{\cal E}_{og}|$$)$
          \end{vquote}
        \end{vtheorem}

        \begin{vproof}
          From Definition \ref{defn-langl-trans}, it follows that the size of
          a language ${\cal L}^{*}$ translation is as follows:

          \begin{vquote}
            $|$$Trans$(${\cal D_{L}}$)$|$ $=$
              $|{\cal F}_{int}|$ $+$
              $|{\cal F}_{con}|$ $+$
              $|{\cal F}_{upd}|$ $+$
              $|{\cal F}_{inh}|$ $+$
              $|{\cal F}_{tra}|$ $+$
              $|{\cal F}_{ine}|$ $+$
              $|{\cal F}_{ref}|$
          \end{vquote}

          \noindent
          where ${\cal F}_{int}$, ${\cal F}_{con}$, ${\cal F}_{upd}$,
          ${\cal F}_{inh}$, ${\cal F}_{tra}$, ${\cal F}_{ine}$, and
          ${\cal F}_{ref}$ are the sets of initial fact rules, constraint
          rules, policy update rules, inheritance rules, transitivity rules,
          inertial rules, and reflexivity rules, respectively.

          As no {\em initially} statement in the set $\Gamma_{int}$ contain
          an expression with more than $Max$($\Gamma_{int}$) facts, the
          maximum number of initial fact rules generated in the translation
          is:

          \begin{vquote}
            $|{\cal F}_{int}|$ $\leq$
              $Max$($\Gamma_{int}$) $|\Gamma_{int}|$
          \end{vquote}

          Each language ${\cal L}$ constraint statement in $\Gamma_{con}$
          corresponds to $n$ rules in language ${\cal L}^{*}$, where $n$ is
          the number of policy update states times the number of facts in the
          {\em always} clause of the statement. With $Max$($\Gamma_{con}$) as
          the maximum number of facts in the {\em always} clause of any
          constraint statement, we have:

          \begin{vquote}
            $|{\cal F}_{con}|$ $\leq$
              $|\psi|$ $Max$($\Gamma_{con}$) $|\Gamma_{con}|$
          \end{vquote}

          For policy update statements, only those that are applied are
          actually translated to language ${\cal L}^{*}$. With
          $Max$($\Gamma_{upd}$) as the maximum number of facts in the
          postcondition expression of any applied policy update statement, we
          have:

          \begin{vquote}
            $|{\cal F}_{upd}|$ $\leq$ $|\psi|$ $Max$($\Gamma_{upd}$)
          \end{vquote}

          The total number of inheritance rules generated in the translation
          is the sum of the number of member inheritance rules and the number
          of subset inheritance rules:

          \begin{vquote}
            $|{\cal F}_{inh}|$ $=$
              $|{\cal F}_{inh_{mem}}|$ $+$
              $|{\cal F}_{inh_{sub}}|$
          \end{vquote}

          Since the membership inheritance rules show the relationships
          between every possible combination of single and group entities
          times the number of states times 2 (for negative facts), we have:

          \begin{vquote}
            $|{\cal F}_{inh_{mem}}|$ $=$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{ss}|$ $|{\cal E}_{sg}|$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{as}|$ $|{\cal E}_{ag}|$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{os}|$ $|{\cal E}_{og}|$
          \end{vquote}

          For subset inheritance rules, only the relationships between group
          entities are considered:

          \begin{vquote}
            $|{\cal F}_{inh_{sub}}|$ $=$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{sg}|^{2}$ $|{\cal E}_{a}|$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{ag}|^{2}$ $|{\cal E}_{o}|$ $+$

            \hspace{1em}
            $2$ $|\psi|$ $|{\cal E}_{s}|$ $|{\cal E}_{a}|$ $|{\cal E}_{og}|^{2}$
          \end{vquote}

          As transitivity rules enumerate every possible combinations of any
          three group entities, for each entity type, the total number of
          transitivity rules is shown below:

          \begin{vquote}
            $|{\cal F}_{tra}|$ $=$
            $|\psi|$
            ($|{\cal E}_{sg}|^{3}$ $+$ $|{\cal E}_{ag}|^{3}$ $+$ $|{\cal E}_{og}|^{3}$)
          \end{vquote}

          A single atom in language ${\cal L}$ corresponds to $n$ inertial
          rules in language ${\cal L}^{*}$, where $n$ is the number of states
          times 2 (for negative facts). This means the total number of
          inertial rules generated is:

          \begin{vquote}
            $|{\cal F}_{ine}|$ $=$ $2$ $|\psi|$ $|{\cal A}|$
          \end{vquote}

          Lastly, the total number of reflexivity rules is equal to the total
          number of group entities times the number of states:

          \begin{vquote}
            $|{\cal F}_{ref}|$ $=$
            $|\psi|$
            ($|{\cal E}_{sg}|$ $+$ $|{\cal E}_{ag}|$ $+$ $|{\cal E}_{og}|$)
          \end{vquote}
        \end{vproof}

    \section{Domain Consistency and Query Evaluation}
      \label{sect-langl-consi}

      A domain description of language ${\cal L}$ must be consistent in order
      to generate a consistent answer set for the evaluation of queries. This
      section considers two issues: the problem of identifying whether a given
      domain description is consistent\footnotemark, and how query evaluation
      is performed given a consistent language domain description. By using
      Definition \ref{defn-langl-trans}, we define consistency as follows:

      \footnotetext{
        The strategy used here for determining domain consistency is based on a
        similar strategy used by Zhang \cite{ZHA} for characterising consistent
        action domains.
      }

      \begin{vdefinition}
        \label{defn-langl-consi}
        The domain description ${\cal D_L}$ of language ${\cal L}$ is said to
        be {\bf consistent} if and only if the translation
        $Trans$(${\cal D_L}$) has a consistent answer set.
      \end{vdefinition}

      First, we introduce a few notational constructs. Given a domain
      description ${\cal D_L}$ composed of the following language ${\cal L}$
      statements:

      \begin{vverbatim}
  initially \(\rho\sb{0\sb{0}}\), \(\ldots\), \(\rho\sb{0\sb{n\sb{0}}}\), \(!\)\(\rho\sb{1\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{1\sb{n\sb{1}}}\);

  always \(\rho\sb{2\sb{0}}\), \(\ldots\), \(\rho\sb{2\sb{n\sb{2}}}\), \(!\)\(\rho\sb{3\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{3\sb{n\sb{3}}}\)
    implied by \(\rho\sb{4\sb{0}}\), \(\ldots\), \(\rho\sb{4\sb{n\sb{4}}}\), \(!\)\(\rho\sb{5\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{5\sb{n\sb{5}}}\)
    with absence \(\rho\sb{6\sb{0}}\), \(\ldots\), \(\rho\sb{6\sb{n\sb{6}}}\), \(!\)\(\rho\sb{7\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{7\sb{n\sb{7}}}\);

  update \(u\)()
    causes \(\rho\sb{8\sb{0}}\), \(\ldots\), \(\rho\sb{8\sb{n\sb{8}}}\), \(!\)\(\rho\sb{9\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{9\sb{n\sb{9}}}\)
    if \(\rho\sb{10\sb{0}}\), \(\ldots\), \(\rho\sb{10\sb{n\sb{10}}}\), \(!\)\(\rho\sb{11\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{11\sb{n\sb{11}}}\);
      \end{vverbatim}

      Let $\gamma_{int}$ be an initial fact definition statement,
      $\gamma_{con}$ a constraint definition statement, and $\gamma_{upd}$
      a policy update definition statement, where $\gamma_{int}$,
      $\gamma_{con}$, $\gamma_{upd}$ $\in$ ${\cal D}_{\cal L}$. We then define
      the following set constructor functions:

      \begin{vquote}
        ${\cal F}^{+}_{int}$($\gamma_{int}$) $=$
          \{$\rho_{0_i}$ $\mid$ $0$ $\leq$ $i$ $\leq$ $n_0$\}

        ${\cal F}^{-}_{int}$($\gamma_{int}$) $=$
          \{$\rho_{1_i}$ $\mid$ $0$ $\leq$ $i$ $\leq$ $n_1$\}

        ${\cal F}^{+}_{con}$($\gamma_{upd}$) $=$
          \{$\rho_{2_i}$ $\mid$ $0$ $\leq$ $i$ $\leq$ $n_2$\}

        ${\cal F}^{-}_{con}$($\gamma_{upd}$) $=$
          \{$\rho_{3_i}$ $\mid$ $0$ $\leq$ $i$ $\leq$ $n_3$\}

        ${\cal F}^{+}_{upd}$($\gamma_{con}$) $=$
          \{$\rho_{4_i}$ $\mid$ $0$ $\leq$ $i$ $\leq$ $n_4$\}

        ${\cal F}^{-}_{upd}$($\gamma_{con}$) $=$
          \{$\rho_{5_i}$ $\mid$ $0$ $\leq$ $i$ $\leq$ $n_5$\}
      \end{vquote}

      \noindent
      Using these functions, we define the following sets of ground facts:

      \begin{vquote}
        ${\cal F}^{+}_{int}$ $=$
        \{$\rho$ $\mid$ $\rho$ $\in$ ${\cal F}^{+}_{int}$($\gamma_{int}$), $\gamma_{int}$ $\in$ ${\cal D}_{\cal L}$\}

        ${\cal F}^{-}_{int}$ $=$
        \{$\rho$ $\mid$ $\rho$ $\in$ ${\cal F}^{-}_{int}$($\gamma_{int}$), $\gamma_{int}$ $\in$ ${\cal D}_{\cal L}$\}

        ${\cal F}^{+}_{con}$ $=$
        \{$\rho$ $\mid$ $\rho$ $\in$ ${\cal F}^{+}_{con}$($\gamma_{con}$), $\gamma_{con}$ $\in$ ${\cal D}_{\cal L}$\}

        ${\cal F}^{-}_{con}$ $=$
        \{$\rho$ $\mid$ $\rho$ $\in$ ${\cal F}^{-}_{con}$($\gamma_{con}$), $\gamma_{con}$ $\in$ ${\cal D}_{\cal L}$\}

        ${\cal F}^{+}_{upd}$ $=$
        \{$\rho$ $\mid$ $\rho$ $\in$ ${\cal F}^{+}_{upd}$($\gamma_{upd}$), $\gamma_{upd}$ $\in$ ${\cal D}_{\cal L}$\}

        ${\cal F}^{-}_{upd}$ $=$
        \{$\rho$ $\mid$ $\rho$ $\in$ ${\cal F}^{-}_{upd}$($\gamma_{upd}$), $\gamma_{upd}$ $\in$ ${\cal D}_{\cal L}$\}
      \end{vquote}

      \noindent
      Additionally, we use the complementary set notation $\overline{{\cal F}}$
      to denote a set containing the negation of facts in set ${\cal F}$.

      \begin{vquote}
        $\overline{{\cal F}}$ =
        \{$\lnot\rho$ $\mid$ $\rho$ $\in$ ${\cal F}$\}.
      \end{vquote}

      Let $\gamma$ be an {\em initially}, {\em constraint} or
      {\em policy update} declaration statement of language ${\cal L}$. We then
      define the following functions:

      \begin{vquote}
        $Eff$($\gamma$)
        $=$
        \begin{math}
          \begin{cases}
            \mbox{
              \{
                $\rho_{0_0}$, \ldots, $\rho_{0_{n_0}}$,
                $\lnot\rho_{1_0}$, \ldots, $\lnot\rho_{1_{n_1}}$
              \},
              if $\gamma$ is {\em initially}
            } \\
            \mbox{
              \{
                $\rho_{2_0}$, \ldots, $\rho_{2_{n_2}}$,
                $\lnot\rho_{3_0}$, \ldots, $\lnot\rho_{3_{n_3}}$
              \},
              if $\gamma$ is {\em constraint}
            } \\
            \mbox{
              \{
                $\rho_{8_0}$, \ldots, $\rho_{8_{n_8}}$,
                $\lnot\rho_{9_0}$, \ldots, $\lnot\rho_{9_{n_9}}$
              \},
              if $\gamma$ is {\em policy update}
            } \\
          \end{cases}
        \end{math}
      \end{vquote}

      \begin{vquote}
        $Def$($\gamma$)
        $=$
        \begin{math}
          \begin{cases}
            \mbox{
              $\emptyset$,
              if $\gamma$ is {\em initially}
            } \\
            \mbox{
              \{
                $\rho_{6_0}$, \ldots, $\rho_{6_{n_6}}$,
                $\lnot\rho_{7_0}$, \ldots, $\lnot\rho_{7_{n_7}}$
              \},
              if $\gamma$ is {\em constraint}
            } \\
            \mbox{
              $\emptyset$,
              if $\gamma$ is {\em policy update}
            } \\
          \end{cases}
        \end{math}
      \end{vquote}

      \begin{vquote}
        $Pre$($\gamma$)
        $=$
        \begin{math}
          \begin{cases}
            \mbox{
              $\emptyset$,
              if $\gamma$ is {\em initially}
            } \\
            \mbox{
              \{
                $\rho_{4_0}$, \ldots, $\rho_{4_{n_4}}$,
                $\lnot\rho_{5_0}$, \ldots, $\lnot\rho_{5_{n_5}}$
              \},
              if $\gamma$ is {\em constraint}
            } \\
            \mbox{
              \{
                $\rho_{10_0}$, \ldots, $\rho_{10_0}$,
                $\lnot\rho_{11_0}$, \ldots, $\lnot\rho_{11_{n_11}}$
              \},
              if $\gamma$ is {\em policy update}
            } \\
          \end{cases}
        \end{math}
      \end{vquote}

      \begin{vdefinition}
        \label{defn-langl-mutex}
        Given a domain description ${\cal D_{L}}$ of language ${\cal L}$,
        two ground facts $\rho$ and $\rho'$ are {\bf mutually exclusive}
        in ${\cal D_{L}}$ if:

        \begin{vquote}
          $\rho$ $\in$ \{${\cal F}^{+}_{int}$ $\cup$
          $\overline{{\cal F}^{-}_{int}}$ $\cup$ ${\cal F}^{+}_{con}$ $\cup$
          $\overline{{\cal F}^{-}_{con}}$ $\cup$ ${\cal F}^{+}_{upd}$ $\cup$
          $\overline{{\cal F}^{-}_{upd}}$\}

          implies

          $\rho'$ $\not\in$ \{${\cal F}^{+}_{int}$ $\cup$
          $\overline{{\cal F}^{-}_{int}}$ $\cup$ ${\cal F}^{+}_{con}$ $\cup$
          $\overline{{\cal F}^{-}_{con}}$ $\cup$ ${\cal F}^{+}_{upd}$ $\cup$
          $\overline{{\cal F}^{-}_{upd}}$\}
        \end{vquote}
      \end{vdefinition}

      Stated simply, a pair of mutually exclusive facts cannot both be true
      in any given state. The following two definitions refer to language
      ${\cal L}$ statements.

      \begin{vdefinition}
        \label{defn-langl-compl}
        Given a domain description ${\cal D_{L}}$ of language ${\cal L}$,
        two statements $\gamma$ and $\gamma'$ are {\bf complementary} in
        ${\cal D_{L}}$ if one of the following conditions holds:

        \begin{enumerate}
          \item
            $\gamma$ and $\gamma'$ are both constraint statements and
            $Eff(\gamma)$ $=$ $\overline{Eff(\gamma')}$.
          \item
            $\gamma$ is a constraint statement, $\gamma'$ is a policy update
            statement and $Eff(\gamma)$ $=$ $\overline{Eff(\gamma')}$.
        \end{enumerate}
      \end{vdefinition}

      \begin{vdefinition}
        \label{defn-langl-norml}
        Given a domain description ${\cal D_{L}}$, ${\cal D_{L}}$ is said to
        be {\bf normal} if it satisfies all of the following conditions:

        \begin{enumerate}
          \item
            \label{defn-langl-norml-1}
            ${\cal F}^{+}_{int}$ $\cap$ ${\cal F}^{-}_{int}$ $=$ $\emptyset$.
          \item
            \label{defn-langl-norml-2}
            For any two constraint statements $\gamma$ and $\gamma'$ in
            ${\cal D_{L}}$, including $\gamma$ $=$ $\gamma'$, $Def(\gamma)$
            $\cap$ $Eff(\gamma')$ = $\emptyset$.
          \item
            \label{defn-langl-norml-3}
            For all constraint statements $\gamma$ in ${\cal D_{L}}$,
            $\overline{Eff(\gamma)}$ $\cap$ $Pre(\gamma)$ $=$ $\emptyset$.
          \item
            \label{defn-langl-norml-4}
            For any two complementary statements $\gamma$ and $\gamma'$
            in ${\cal D_{L}}$, there exists a pair of ground expression
            $\epsilon$ $\in$ $Pre(\gamma)$ and $\epsilon'$ $\in$
            $Pre(\gamma')$ such that $\epsilon$ and $\epsilon'$ are
            mutually exclusive.
        \end{enumerate}
      \end{vdefinition}

      With the above definitions, we can now provide a sufficient condition to
      ensure the consistency of a domain description.

      \begin{vtheorem}{Domain Consistency}
        \label{theo-langl-consi}
        A {\bf normal} domain description of language ${\cal L}$ is also
        {\bf consistent}.
      \end{vtheorem}

      \begin{vproof}
        From Definition \ref{defn-langl-consi}, given a normal domain
        description ${\cal D}_{\cal L}$, we only need to show that
        $Trans$(${\cal D}_{\cal L}$) has at least one consistent answer set to
        prove that ${\cal D}_{\cal L}$ is also consistent.

        Given a normal domain description ${\cal D}_{\cal L}$, Condition
        \ref{defn-langl-norml-2} in Definition \ref{defn-langl-norml} ensures
        that the translation $Trans$(${\cal D}_{\cal L}$) do not contain rules
        of the following form:

        \begin{vquote}
          $\hat{\rho}_{0}$ $\leftarrow$
            $\hdots$, $not$ $\hat{\rho}_{k}$, $\hdots$

          $\hat{\rho}_{1}$ $\leftarrow$
            $\hdots$, $\hat{\rho}_{0}$, $\hdots$

          $\vdots$

          $\hat{\rho}_{k - 1}$ $\leftarrow$
            $\hdots$, $\hat{\rho}_{k - 2}$, $\hdots$

          $\hat{\rho}_{k}$ $\leftarrow$
            $\hdots$, $\hat{\rho}_{k - 1}$, $\hdots$
        \end{vquote}

        \noindent
        The absence of these rules means $Trans$(${\cal D}_{\cal L}$) is a
        program without negative cycles \cite{LIN}. As no other rule in
        ${\cal D}_{\cal L}$ can cause $Trans$(${\cal D}_{\cal L}$) to have
        these rules, we conclude that a normal domain description
        ${\cal D}_{\cal L}$, as defined by Definition \ref{defn-langl-norml},
        will generate an extended logic program $Trans$(${\cal D}_{\cal L}$)
        without negative cycles. Also, from \cite{BAR,LIN}, we further
        conclude that the translated program $Trans$(${\cal D}_{\cal L}$)
        must have an answer set.

        Condition \ref{defn-langl-norml-1} of Definition \ref{defn-langl-norml}
        prevents rules of the following form from occurring in
        $Trans$(${\cal D}_{\cal L}$):

        \begin{vquote}
          $\hat{\rho}^{S_{0}}$ $\leftarrow$

          $\lnot\hat{\rho}^{S_{0}}$ $\leftarrow$
        \end{vquote}

        \noindent
        This shows that a subset of the answer set which contains facts from
        the initial state $S_{0}$ is consistent.

        Condition \ref{defn-langl-norml-3} of Definition \ref{defn-langl-norml}
        guarantees that rules of the following form do not occur in
        $Trans$(${\cal D}_{\cal L}$):

        \begin{vquote}
          $\hat{\rho}$ $\leftarrow$ $\hdots$, $\lnot\hat{\rho}$, $\hdots$
        \end{vquote}

        \noindent
        This ensures that all constraint rules translated from
        ${\cal D}_{\cal L}$ are consistent.

        Finally, Condition \ref{defn-langl-norml-4} of Definition
        \ref{defn-langl-norml} ensures that rules in
        $Trans$(${\cal D}_{\cal L}$) of the following form:

        \begin{vquote}
          $\hat{\rho}$ $\leftarrow$ $\hdots$, $\hat{\rho}'$, $\hdots$

          $\lnot \hat{\rho}$ $\leftarrow$ $\hdots$, $\hat{\rho}''$, $\hdots$
        \end{vquote}

        \noindent
        cannot both affect the answer set as the premises $\rho'$ and $\rho''$
        are mutually exclusive and therefore only one is true in any given
        state.

        These guarantee that the answer set do not contain complementary facts,
        and therefore guarantee that the answer set is consistent.
      \end{vproof}

      Since only consistent domain descriptions can be evaluated in terms of
      user queries, Theorem \ref{theo-langl-consi} may be used to check whether
      a domain description is consistent.

      \begin{vdefinition}
        \label{defn-langl-evalu}
        Given a consistent domain description ${\cal D}_{\cal L}$, a ground
        query expression $\phi$ and a finite sequence list $\psi$, we say
        {\em query $\phi$ holds in ${\cal D}_{\cal L}$ after the policy updates
        in sequence list $\psi$ have been applied}, denoted as

        \begin{vquote}
          ${\cal D}_{\cal L}$ $\models$ \{$\phi$, $\psi$\}
        \end{vquote}

        \noindent
        if and only if

        \begin{vquote}
          $\forall$ ($\rho$, $\lambda$),
          $\hat{\rho}$ $\in$ $\lambda$

        \end{vquote}

        \begin{vquote}
          where

          \hspace{1em}
          $\rho$ $\in$ $\phi$,

          \hspace{1em}
          $\lambda$ $\in$ $\Lambda$,

          \hspace{1em}
          $\hat{\rho}$ $=$ $TransFact$($\rho$, $S_{|\psi|}$),

          \hspace{1em}
          $\Lambda$ $=$ answer sets of $Trans$(${\cal D}_{\cal L}$)
        \end{vquote}
      \end{vdefinition}

      Definition \ref{defn-langl-evalu} shows that given a finite list of
      policy updates $\psi$, a query expression $\phi$ may be evaluated from a
      consistent language ${\cal L}$ domain ${\cal D_{L}}$. This is
      achieved by generating a set of answer sets from the normal logic
      program translation $Trans$(${\cal D_{L}}$). $\phi$ is then said to
      hold in ${\cal D_{L}}$ after the policy updates in $\psi$ have been
      applied if and only if every answer set generated contains every fact
      in the query expression $\phi$.

      \begin{vexample}
        \label{exam-langl-evalu}
        Given the language ${\cal L}$ code listing in Example
        \ref{exam-langl-syntx} and its translation in Example
        \ref{exam-langl-seman}, where the update sequence list
        $\psi$ = \{$delete\_read$($grp_1$, $file$)\}. The following shows the
        evaluated results of each query $\phi$:

        \begin{vquote}
          $\phi_{0}$ = $holds$($grp_1$, $write$, $file$) : $TRUE$

          $\phi_{1}$ = $holds$($grp_1$, $read$, $file$) : $FALSE$

          $\phi_{2}$ = $holds$($alice$, $write$, $file$) : $TRUE$

          $\phi_{3}$ = $holds$($alice$, $read$, $file$) : $FALSE$
        \end{vquote}
      \end{vexample}

  \chapter{PolicyUpdater System}
    \label{chap-polup}

    The PolicyUpdater system is a fully-implemented access control system
    that uses language ${\cal L}$ policy descriptions. The first part of this
    chapter focuses on the underlying mechanisms that make up the system,
    followed by an analysis of the performance of the implementation. The final
    part of the chapter describes the application of a PolicyUpdater module to
    a web server to enforce logic-based authorisation policies\footnotemark.

    \footnotetext{
      Implementation and performance analysis was published in \cite{CRE2}. The
      web server module was first introduced in \cite{CRE4}.
    }

    The source code and other technical information of the
    core PolicyUpdater system and the web server module can be found in the
    PolicyUpdater website at:

    \begin{vquote}
      {\tt\scriptsize http://www.scm.uws.edu.au/\~{}jcrescin/projects/policyupdater/index.html}
    \end{vquote}

    \section{System Structure}
      \label{sect-polup-struc}

      As shown in Figure \ref{figu-polup-sysst}, the PolicyUpdater system
      works with an authorisation agent program that queries the policy base
      to determine whether to allow users access to resources. Through an
      authorisation agent program, the PolicyUpdater system also allows
      administrators to dynamically update the policy base by adding or
      removing update directives in the policy update table.

      \begin{figure}[tbhp]
        \begin{center}
          \includegraphics{sys-01}
          \caption{Structure of PolicyUpdater}
          \label{figu-polup-sysst}
        \end{center}
      \end{figure}

      \subsection{Parsers}
        \label{subs-polup-parse}

        As the policy itself is written in language ${\cal L}$, the system uses
        two parsers to act as interfaces to the authorisation agent and
        the language ${\cal L}$ policy.

        \subsubsection{Policy Parser}

          The policy parser is responsible for correctly reading the policy
          file into the core PolicyUpdater system. The parser ensures that
          the policy file strictly adheres to the language $\cal{L}$ syntax
          then systematically stores entity identifiers into the symbol table
          while initial state facts, constraint expressions and policy update
          definitions are stored into their respective tables in the policy
          base.

        \subsubsection{Agent Parser}

           The agent parser is the direct link between the core PolicyUpdater
          system and the authorisation agent program. The parser's sole purpose
          is to receive language $\cal{L}$ directives from an agent, perform
          the directive upon the policy base and return a reply if the
          directive requires one. Such directives may be to query the policy
          base or to manipulate the policy update sequence table.

      \subsection{Data Structures}
        \label{subs-polup-dstru}

        As language ${\cal L}$ program is parsed, each statement containing
        entity declarations, initial facts, constraint rules and policy
        updates must first be stored into a structure before the translation
        process is started. This structure is composed of the symbol table,
        the policy base and the policy update sequence table. The symbol table
        is used to store all entity identifiers defined in the policy, while
        the rest of the policy definitions are stored in the policy base. The
        sequence of policy update directives are stored separately in the
        policy update sequence table.

        Each of the tables and lists used in the system inherits from a generic
        ordered and indexed list implementation. Each node in this list holds a
        generic data type that can be used to store strings, an arbitrary data
        type or another list type. This list structure implements the following
        operations:

        \begin{itemize}
          \item
            $LIST$.$Add$($item$) appends $item$ to the end of $LIST$.
          \item
            $LIST$.$Length$() returns the number of elements in $LIST$.

          \item
            $LIST$.$Find$($item$) returns true if $item$ is in the list and
            false otherwise.

          \item
            $LIST$.$Index$($item$) returns the index of the item $item$
            in $LIST$.

          \item
            $LIST$.$Get$($index$) returns the $index$'th item in $LIST$.
        \end{itemize}

        \noindent
        For simplicity, the following notations are used in the rest of this
        paper:

        \begin{vquote}
          $|LIST|$ = $LIST$.$Length$()

          $LIST$[$i$] = $LIST$.$Get$($i$)
        \end{vquote}

        \subsubsection{Symbol Table}

          The symbol table is used to store the entity identifiers defined by
          the entity identifier declaration statements of language ${\cal L}$
          programs. The symbol table is composed of 6 separate string lists
          as shown in \ref{tabl-polup-sytab}.

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|l|l|l|}
                \hline
                \textbf{Field} & \textbf{Type}  & \textbf{Description} \\
                \hline
                $ss$           & String List    & Single Subject \\
                \hline
                $sg$           & String List    & Group Subject \\
                \hline
                $as$           & String List    & Single Access Right \\
                \hline
                $ag$           & String List    & Group Access Right \\
                \hline
                $os$           & String List    & Single Object \\
                \hline
                $og$           & String List    & Group Object \\
                \hline
              \end{tabular}
            \end{center}
            \caption{Symbol Table Data Structure}
            \label{tabl-polup-sytab}
          \end{table}

          In addition to the 6 lists in the symbol table, 3 additional lists
          are defined: $s$, $a$ and $o$. These lists are simple concatenations
          of the other lists in the table (i.e. $s$ = $ss$ $+$ $sg$, etc.).
          Each entity identifier are sorted in the symbol table lists
          according to their type, and ordered according to the order in which
          they are declared in the program. Each list is indexed by positive
          integers starting from zero.

        \subsubsection{Policy Base}

          When a language ${\cal L}$ program is parsed, each of the facts,
          rules and policy updates must first be stored into the policy base.
          The policy base is composed of 4 tables to store the following:
          initial facts, constraint rules, policy update definitions and
          the policy update sequence.

          \paragraph{Atoms.}

            The three types of atoms, i.e. {\em holds}, {\em membership}
            and {\em subset}, are represented as structures of 2 to 3
            strings, with each string matching an entity identifier from
            the symbol table. Table \ref{tabl-polup-atdsr} shows the
            fields associated with each atom type.

            \begin{table}[tbhp]
              \begin{center}
                \begin{tabular}[t]{|l|l|l|l|}
                  \hline
                  \textbf{Atom}             & \textbf{Field} & \textbf{Type}             & \textbf{Description} \\
                  \hline
                  {\multirow{3}{*}{holds}}  & $sub$          & String                    & Subject Entity \\
                  \cline{2-4}
                                            & $acc$          & String                    & Access Right Entity \\
                  \cline{2-4}
                                            & $obj$          & String                    & Object Entity \\
                  \hline
                  {\multirow{3}{*}{member}} & $elt$          & String                    & Single Entity \\
                  \cline{2-4}
                                            & $grp$          & String                    & Group Entity \\
                  \cline{2-4}
                                            & $type$         & \{$sub$$|$$acc$$|$$obj$\} & Type Specifier \\
                  \hline
                  {\multirow{3}{*}{subset}} & $grp_0$        & String                    & Subgroup Entity \\
                  \cline{2-4}
                                            & $grp_1$        & String                    & Supergroup Entity \\
                  \cline{2-4}
                                            & $type$         & \{$sub$$|$$acc$$|$$obj$\} & Type Specifier \\
                  \hline
                \end{tabular}
              \end{center}
              \caption{Atom Data Structure}
              \label{tabl-polup-atdsr}
            \end{table}

          \paragraph{Facts.}

            Facts are stored in a three-element structure composed of the
            following: polymorphic type which can be any of the three atom
            structures above; a type indicator to specify whether the fact is
            {\em holds}, {\em member} or {\em subset} type; and a truth flag
            to indicate whether the atom is classically negated or not
            ({\em true} if the fact holds and {\em false} if the negation of
            the fact holds). Table \ref{tabl-polup-fadsr} shows the data
            structure for storing facts.

            \begin{table}[tbhp]
              \begin{center}
                \begin{tabular}[t]{|l|l|l|}
                  \hline
                  \textbf{Field} & \textbf{Type}       & \textbf{Description} \\
                  \hline
                  $atom$         & Atom Type           & Polymorphic Structure \\
                  \hline
                  $type$         & \{$h$$|$$m$$|$$s$\} & Holds, Member or Subset \\
                  \hline
                  $truth$        & Boolean             & Negation Indicator \\
                  \hline
                \end{tabular}
              \end{center}
              \caption{Fact Data Structure}
              \label{tabl-polup-fadsr}
            \end{table}

          \paragraph{Expressions.}

            Since expressions are simply conjunctions of facts, they are
            represented as a list of fact structures.

          \paragraph{Initial Facts Table.}

            The initial facts table is represented as a single list of
            fact structures, or an expression. Each fact in all {\em initially}
            statements are added into the initial facts table.

          \paragraph{Constraints Table.}

            The constraints table, as shown in Table \ref{tabl-polup-cntab}, is
            represented as a list of constraint structures, with each
            structure composed of three expression fields.

            \begin{table}[tbhp]
              \begin{center}
                \begin{tabular}[t]{|l|l|l|}
                  \hline
                  \textbf{Field} & \textbf{Type}   & \textbf{Description} \\
                  \hline
                  $exp$          & Expression Type & Consequent \\
                  \hline
                  $pcn$          & Expression Type & Positive Premise \\
                  \hline
                  $ncn$          & Expression Type & Negative Premise \\
                  \hline
                \end{tabular}
              \end{center}
              \caption{Constraints Table}
              \label{tabl-polup-cntab}
            \end{table}

          \paragraph{Policy Update Definitions Table.}

            Another list of structures is the policy update table. Each element
            structure of this table, as shown in Table \ref{tabl-polup-pdtab}
            is composed of 4 fields.

            \begin{table}[tbhp]
              \begin{center}
                \begin{tabular}[t]{|l|l|l|}
                  \hline
                  \textbf{Field} & \textbf{Type}       & \textbf{Description} \\
                  \hline
                  $name$         & String              & Update Identifier \\
                  \hline
                  $vlist$        & Ordered String List & Variables \\
                  \hline
                  $pre$          & Expression Type     & Precondition \\
                  \hline
                  $pst$          & Expression Type     & Postcondition \\
                  \hline
                \end{tabular}
              \end{center}
              \caption{Policy Update Definitions Table}
              \label{tabl-polup-pdtab}
            \end{table}

        \subsubsection{Policy Update Sequence Table}

          The policy update sequence table is an ordered list of sequence
          structures, each with two fields. Table \ref{tabl-polup-pstab}
          shows the structure of this table.

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|l|l|l|}
                \hline
                \textbf{Field} & \textbf{Type}       & \textbf{Description} \\
                \hline
                $name$         & String              & Update Identifier \\
                \hline
                $ilist$        & Ordered String List & Identifiers \\
                \hline
              \end{tabular}
            \end{center}
            \caption{Policy Update Sequence Table}
            \label{tabl-polup-pstab}
          \end{table}

    \section{System Processes}
      \label{sect-polup-proce}

      The processes presented in this section shows how the language
      ${\cal L}$ policy stored in the data structures is translated into a
      normal logic program and how it can be dynamically updated and
      manipulated to evaluate queries. The flowchart in Figure
      \ref{figu-polup-sysfl} gives an overview of the system processes.

      \begin{figure}[tbhp]
        \begin{center}
          \includegraphics{sys-02}
          \caption{System Flowchart}
          \label{figu-polup-sysfl}
        \end{center}
      \end{figure}

      \subsection{Grounding Constraint Variables}
        \label{sect-polup-groun}

        As the constraints are in the process of being added into the
        constraints table, each variable identifier that occurs in a
        constraint is grounded by replacing that constraint with a set of
        constraints wherein each instance of the variable is replaced by all
        entity identifiers defined in the symbol table. Note that only those
        entity identifiers that are valid for each fact in the current
        constraint are used to replace the variable (e.g. only singular
        subject entity identifiers are used to replace an element variable
        occurring in a subject member fact).

        For example, given that the symbol table contains three singular
        subject entity identifiers: $alice$, $bob$ and $charlie$, and the
        following constraint:

        \begin{vverbatim}
  always holds(SSUB, write, file)
    implied by
      holds(SSUB, read, file),
      memb(SSUB, students)
    with absence
      !holds(SSUB, write, file);
        \end{vverbatim}

        Grounding the constraint statement above yields three new constraint
        rules, each replacing occurrences of the variable $SSUB$ with
        $alice$, $bob$ and $charlie$, respectively.

      \subsection{Policy Updates}
        \label{subs-polup-polup}

        In Section \ref{sect-langl-seman}, it is shown that policy updates are
        performed by treating each update as a constraint. This constraint is
        composed of a premise, which is the precondition in the current state
        and a consequent, which is the postcondition of the resulting state
        after the application of the policy update. The resulting state in this
        procedure represents the updated policy.

        The most crucial step in performing a policy update is the translation
        of the policy updates into normal logic program constraints. This step
        involves identifying which policy updates are to be applied from the
        update sequence table and then composing the required constraint from
        the update definition in the policy base. Once the policy update
        constraints are composed, they are then treated as any other
        constraint rules and are translated with the rest of the policy into
        a normal logic program.

      \subsection{Translation to Normal Logic Program}
        \label{subs-polup-norlp}

        The semantics of language ${\cal L}$ shows that any consistent language
        ${\cal L}$ program can be translated into an equivalent extended logic
        program then translated again into an equivalent normal logic program.
        However, the implementation of such translations can be greatly
        simplified by translating language ${\cal L}$ programs directly into
        normal logic programs.

        \subsubsection{Removing Classical Negation}

          In order to remove classical negation from facts of language
          ${\cal L}$, each classically negated fact $\lnot$$\rho$ is replaced
          by a new and unique positive fact $\rho'$ that represents the
          negation of fact $\rho$. To preserve the consistency of the policy
          base for all facts $\rho$ in the domain, the following constraint
          rule must be added:

          \begin{vquote}
            $FALSE$ $\leftarrow$ $\rho$, $\rho'$
          \end{vquote}

          The removal process involves adding a boolean parameter to each fact
          to indicate whether the fact is classically negated or not. For
          example, given the fact:

          \begin{vquote}
            $\lnot$ $holds$($alice$, $exec$, $file$)
          \end{vquote}

          \noindent
          To remove classical negation, it is replaced by:

          \begin{vquote}
            $holds$($alice$, $exec$, $file$, $false$)
          \end{vquote}

          \noindent
          To ensure consistency, that is, to ensure that the fact and its
          negation are never both true at any one time, the following rule is
          added:

          \begin{vquote}
            $FALSE$ $\leftarrow$
            $holds$($alice$, $exec$, $file$, $true$),
            $holds$($alice$, $exec$, $file$, $false$)
          \end{vquote}

        \subsubsection{Representing Facts in Propositional Form}

          A fact expressed in normal logic program form is composed of the
          atom relation, the state in which it holds and a boolean flag to
          indicate classical negation. For notational simplicity, this tuple
          may be represented by a unique positive integer $i$, where
          $0$ $\leq$ $i$ $<$ $|{\cal F}|$ ($|{\cal F}|$ is the total
          number of facts in the domain). The process of translating facts of
          language ${\cal L}$ into normal logic program form is summarised by
          the following function:

          \begin{vquote}
            $i$ = $Encode$($\alpha$, $\sigma$, $\tau$)
          \end{vquote}

          As shown above, the $Encode$ function takes a language ${\cal L}$
          atom $\alpha$, the state $\sigma$ in which $\alpha$ holds, and a
          boolean value $\tau$ to indicate whether or not $\alpha$ is
          classically negated. $Encode$ returns a unique index $i$ for that
          fact. The steps below outlines how the $Encode$ function computes
          the index $i$.

          \begin{itemize}
            \item
              {\em Enumerate all possible atoms.}
              By using all the entities in the symbol table, all possible
              language ${\cal L}$ atoms may be enumerated by grouping together
              2 to 3 entities together. All possible atoms of type $holds$ are
              generated by enumerating all possible combinations of subject,
              access right and object entities. The set of $member$ atoms is
              generated from all the different combinations of singular and
              group entities of types subject, access right and object.
              Similarly, the set of $subset$ atoms is derived from different
              subject, access right and object group pair combinations.

            \item
              {\em Arrange the atoms in a predefined order.}
              This procedure relies on the assumption that the list of all
              possible atoms derived from the step above is arranged in a
              predefined order. In this step we ensure that the atoms are
              enumerated in the following order: $holds$, $subject$ $member$,
              $access$ $right$ $member$, $object$ $member$, $subject$
              $subset$, $access$ $right$ $subset$ and $object$ $subset$. In
              addition to the ordering of atom types, atoms of each type are
              themselves sorted according to the order in which their entities
              appear in the symbol table.

            \item
              {\em Assign an ordinal index for each enumerated atom.}
              Since the enumerated list of atoms are ordered, consecutive
              positive integers may be assigned to each atom as an ordinal
              index $i$, where $0$ $\leq$ $i$ $<$ $n$ ($n$ is the total number
              of atoms enumerated).

            \item
              {\em Extend indexing procedure to represent facts.} At the
              implementation level, facts are just atoms with truth values.
              As such, we can treat each atom as positive facts. Since negative
              facts are just mirror images of their positive counterparts,
              their indices are calculated by adding $n$ to the indices of the
              corresponding positive facts. Thus, indices $i$, where $n$ $\leq$
              $i$ $<$ $2n$ are negative facts while indices $i$, where $0$
              $\leq$ $i$ $<$ $n$ are positive facts. Furthermore, this
              procedure is again extended to represent the states of the
              facts. The process is similar: indices $i$, where $0$ $\leq$ $i$
              $<$ $2n$ represent facts of state $S_{0}$, indices $i$, where
              $2n$ $\leq$ $i$ $<$ $4n$ represent facts of state $S_{1}$, and
              so on.
          \end{itemize}

        \subsubsection{Generating the Normal Logic Program from the Policy Base}

          With the language ${\cal L}$ policy elements stored into the storage
          structures described in Section \ref{subs-polup-dstru}, a normal
          logic program can then be generated for evaluation. The following
          algorithm generates a normal logic program, given the Symbol Table
          $\theta$, Initial State Facts Table $\omega_i$, Constraint Rules
          Table $\omega_c$, Policy Update Definition Table $\omega_u$, and
          Policy Update Sequence Table $\psi$:

          \begin{valgorithm}{GenNLP()}{algo-polup-genlp}
FUNCTION \(GenNLP\)(\(\theta\), \(\omega\sb{i}\), \(\omega\sb{c}\), \(\omega\sb{u}\), \(\psi\))
  \(TransInitStateRules\)(\(\omega\sb{i}\))
  \(TransConstRules\)(\(\omega\sb{c}\), \(\psi\))
  \(TransUpdateRules\)(\(\omega\sb{u}\), \(\psi\))
  \(GenInherRules\)(\(\theta\), \(\psi\))
  \(GenTransRules\)(\(\theta\), \(\psi\))
  \(GenInertRules\)(\(\theta\), \(\psi\))
  \(GenRefleRules\)(\(\theta\), \(\psi\))
  \(GenConsiRules\)(\(\theta\), \(\psi\))
ENDFUNCTION
          \end{valgorithm}

          The first three $Trans*$() functions in Algorithm
          \ref{algo-polup-genlp} perform a direct translation of language
          ${\cal L}$ statements to normal logic program. The remaining five
          $Gen*$() functions generate additional constraint rules. In the
          following algorithms, we use the following rule constructor functions
          to generate normal logic program rules:

          \begin{itemize}
            \item
              $RuleBegin$() marks the beginning of a new rule.
            \item
              $RuleHead$($\alpha$) generates the consequent of the rule.
              $\alpha$ is a numeric representation of an atom (e.g. returned by
              the $Encode$() function).
            \item
              $RuleBody$($\alpha$, $\tau$) generates the premise of the rule.
              $\alpha$ is an atom in numeric form like that of $RuleHead$().
              $\tau$ is either $true$ or $false$, indicating whether the atom
              is positive or negative (negation-as-failure).
            \item
              $RuleEnd$() marks the end of a rule.
          \end{itemize}

          Algorithm \ref{algo-polup-tisr} illustrates how initial state rules
          are generated from the storage structures. The process itself is
          straightforward: each fact in the initial state facts table is
          translated by the $Encode$() function and is made the head of a new
          rule whose body is the literal $true$ fact.

          \begin{valgorithm}{TransInitStateRules()}{algo-polup-tisr}
FUNCTION \(TransInitStateRules\)(\(\omega\sb{i}\))
  FOR \(i\) = \(0\) TO (\(|\omega\sb{i}|\) - \(1\)) DO
    \(RuleBegin\)()
    \(RuleHead\)(\(Encode\)(\(\omega\sb{i}\)[\(i\)].\(atom\), \(0\), \(\omega\sb{i}\)[\(i\)].\(truth\)))
    \(RuleBody\)(\(true\), \(true\))
    \(RuleEnd\)()
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          The constraint rules generating algorithm (Algorithm
          \ref{algo-polup-tconr}) works by creating a new rule that is
          composed of facts from the constraints table translated by the
          $Encode$() function. The outer loop ensures that a rule is
          generated for every policy update state.


          \begin{valgorithm}{TransConstRules()}{algo-polup-tconr}
FUNCTION \(TransConstRules\)(\(\omega\sb{c}\), \(\psi\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\omega\sb{c}|\) - \(1\)) DO
      FOR \(k\) = \(0\) TO (\(|\)\(\omega\sb{c}\)[\(j\)].\(exp\)\(|\) - \(1\)) DO
        \(\alpha\) = \(Encode\)(\(\omega\sb{c}\)[\(j\)].\(exp\)[\(k\)].\(atom\), \(i\), \(\omega\sb{c}\)[\(j\)].\(exp\)[\(k\)].\(truth\))
        \(RuleBegin\)()
        \(RuleHead\)(\(\alpha\))
        FOR \(k\) = \(0\) TO (\(|\)\(\omega\sb{c}\)[\(j\)].\(pcn\)\(|\) - \(1\)) DO
          \(\alpha\) = \(Encode\)(\(\omega\sb{c}\)[\(j\)].\(pcn\)[\(k\)].\(atom\), \(i\), \(\omega\sb{c}\)[\(j\)].\(pcn\)[\(k\)].\(truth\))
          \(RuleBody\)(\(\alpha\), \(true\))
        ENDDO
        FOR \(k\) = \(0\) TO (\(|\)\(\omega\sb{c}\)[\(j\)].\(ncn\)\(|\) - \(1\)) DO
          \(\alpha\) = \(Encode\)(\(\omega\sb{c}\)[\(j\)].\(ncn\)[\(k\)].\(atom\), \(i\), \(\omega\sb{c}\)[\(j\)].\(ncn\)[\(k\)].\(truth\))
          \(RuleBody\)(\(\alpha\), \(false\))
        ENDDO
        \(RuleEnd\)()
      ENDDO
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          Algorithm \ref{algo-polup-tupdr} generates the policy update rules
          from the given policy update definition table. Note that only those
          policy updates that also appear in the policy update sequence list
          are actually translated. The actual translation process is similar
          to that of constraint rules, except each variable that may occur
          within the expressions is first grounded and the policy update state
          of each fact in the rule head is one more than that of each fact in
          the rule body.

          \begin{valgorithm}{TransUpdateRules()}{algo-polup-tupdr}
FUNCTION \(TransUpdateRules\)(\(\omega\sb{u}\), \(\psi\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\omega\sb{u}|\) - \(1\)) DO
      IF \(\psi\)[\(i\)].\(name\) == \(\omega\sb{u}\)[\(j\)].\(name\) THEN
        \(upd\) = \(GndUpdate\)(\(\omega\sb{u}\)[\(j\)], \(\psi\)[\(i\)].\(ilist\))
        FOR \(k\) = \(0\) TO (\(|\)\(upd\).\(pst\)\(|\) - \(1\)) DO
          \(\alpha\) = \(Encode\)(\(upd\).\(pst\)[\(k\)].\(atom\), \(i\) + \(1\), \(upd\).\(pst\)[\(k\)].\(truth\))
          \(RuleBegin\)()
          \(RuleHead\)(\(\alpha\))
          FOR \(l\) = \(0\) TO (\(|\)\(upd\).\(pre\)\(|\) - \(1\)) DO
            \(\alpha\) = \(Encode\)(\(upd\).\(pre\)[\(l\)].\(atom\), \(i\), \(upd\).\(pre\)[\(l\)].\(truth\))
            \(RuleBody\)(\(\alpha\), \(true\))
          ENDDO
          \(RuleEnd\)()
        ENDDO
      ENDIF
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          The function $GndUpdate$($u$, $ilist$) used in Algorithm
          \ref{algo-polup-tupdr} returns a structure composed of two
          expressions $pre$ and $pst$, which corresponds with the $pre$ and
          $pst$ fields of the given policy update definition $u$. All
          variables occurring in the facts of these expressions are replaced
          with the corresponding entities from the given entity identifier list
          $ilist$.

          Algorithm \ref{algo-polup-ginhr} generates 6 types of inheritance
          rules: subset subject, subset access right, subset object, membership
          subject, membership access right and membership object. Each of
          these 6 algorithms work in a similar way: a rule is generated by
          composing every possible combination of either subject, access right
          and object entities to form either a subset or membership fact. As
          with the constraint rule generating algorithm, each new rule
          generated is replicated for each policy update state.

          \begin{valgorithm}{GenInherRules()}{algo-polup-ginhr}
FUNCTION \(GenInherRules\)(\(\theta\), \(\psi\))
  \(GenSubSubstInherRules\)(\(\theta\), \(\psi\))
  \(GenAccSubstInherRules\)(\(\theta\), \(\psi\))
  \(GenObjSubstInherRules\)(\(\theta\), \(\psi\))
  \(GenSubMembInherRules\)(\(\theta\), \(\psi\))
  \(GenAccMembInherRules\)(\(\theta\), \(\psi\))
  \(GenObjMembInherRules\)(\(\theta\), \(\psi\))
ENDFUNCTION
          \end{valgorithm}

          The function $GenSubSubstInherRules()$ shown in Algorithm
          \ref{algo-polup-gssir} generates the subject subset inheritance
          rules. Similar techniques are used for the generation of other
          subset and membership inheritance rules and are therefore not shown.

          \begin{valgorithm}{GenSubSubstInherRules()}{algo-polup-gssir}
FUNCTION \(GenSubSubstInherRules\)(\(\theta\), \(\psi\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\)\(\theta\).\(sg\)\(|\) - \(1\)) DO
      FOR \(k\) = \(0\) TO (\(|\)\(\theta\).\(sg\)\(|\) - \(1\)) DO
        IF \(\theta\).\(sg\)[\(j\)] != \(\theta\).\(sg\)[\(k\)] THEN
          FOR \(l\) = \(0\) TO (\(|\)\(\theta\).\(a\)\(|\) - \(1\)) DO
            FOR \(m\) = \(0\) TO (\(|\)\(\theta\).\(o\)\(|\) - \(1\)) DO
              \(\alpha\sb{0}\) = \(holds\)(\(\theta\).\(sg\)[\(j\)], \(\theta\).\(ag\)[\(l\)], \(\theta\).\(og\)[\(m\)])
              \(\alpha\sb{1}\) = \(holds\)(\(\theta\).\(sg\)[\(k\)], \(\theta\).\(ag\)[\(l\)], \(\theta\).\(og\)[\(m\)])
              \(\alpha\sb{2}\) = \(subst\)(\(\theta\).\(sg\)[\(j\)], \(\theta\).\(sg\)[\(k\)])
              \(RuleBegin\)()
              \(RuleHead\)(\(Encode\)(\(\alpha\sb{0}\), \(i\), \(true\)))
              \(RuleBody\)(\(Encode\)(\(\alpha\sb{1}\), \(i\), \(true\)), \(true\))
              \(RuleBody\)(\(Encode\)(\(\alpha\sb{2}\), \(i\), \(true\)), \(true\))
              \(RuleBody\)(\(Encode\)(\(\alpha\sb{0}\), \(i\), \(false\)), \(false\))
              \(RuleEnd\)()
              \(RuleBegin\)()
              \(RuleHead\)(\(Encode\)(\(\alpha\sb{0}\), \(i\), \(false\)))
              \(RuleBody\)(\(Encode\)(\(\alpha\sb{1}\), \(i\), \(false\)), \(true\))
              \(RuleBody\)(\(Encode\)(\(\alpha\sb{2}\), \(i\), \(true\)), \(true\))
              \(RuleEnd\)()
            ENDDO
          ENDDO
        ENDIF
      ENDDO
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          Algorithm \ref{algo-polup-gtrar} generates all the transitivity
          rules. Each subject, access right and object transitivity rule
          generation algorithm follows a similar procedure: every possible
          combination of subject, access right or object group entities are
          used to form subset facts, then each of these facts are used to
          form a transitivity rule. As with inheritance rules, each
          transitivity rule is replicated for each policy update state.
          As similar techniques are used to generate the access right and
          object transitivity rules, only the function that generates the
          subject transitivity rules is shown in Algorithm
          \ref{algo-polup-gstrr}.

          \begin{valgorithm}{GenTransRules()}{algo-polup-gtrar}
FUNCTION \(GenTransRules\)(\(\theta\), \(\psi\))
  \(GenSubTransRules\)(\(\theta\), \(\psi\))
  \(GenAccTransRules\)(\(\theta\), \(\psi\))
  \(GenObjTransRules\)(\(\theta\), \(\psi\))
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{GenSubTransRules()}{algo-polup-gstrr}
FUNCTION \(GenSubTransRules\)(\(\theta\), \(\psi\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\)\(\theta\).\(sg\)\(|\) - \(1\)) DO
      FOR \(k\) = \(0\) TO (\(|\)\(\theta\).\(sg\)\(|\) - \(1\)) DO
        FOR \(l\) = \(0\) TO (\(|\)\(\theta\).\(sg\)\(|\) - \(1\)) DO
          IF \(j\) != \(k\) AND \(j\) != \(l\) AND \(k\) != \(l\) THEN
            \(\alpha\sb{0}\) = \(subst\)(\(\theta\).\(sg\)[\(j\)], \(\theta\).\(sg\)[\(l\)])
            \(\alpha\sb{1}\) = \(subst\)(\{\(\theta\).\(sg\)[\(j\)], \(\theta\).\(sg\)[\(k\)])
            \(\alpha\sb{2}\) = \(subst\)(\{\(\theta\).\(sg\)[\(k\)], \(\theta\).\(sg\)[\(l\)])
            \(RuleBegin\)()
            \(RuleHead\)(\(Encode\)(\(\alpha\sb{0}\), \(i\), \(true\)))
            \(RuleBody\)(\(Encode\)(\(\alpha\sb{1}\), \(i\), \(true\)), \(true\))
            \(RuleBody\)(\(Encode\)(\(\alpha\sb{2}\), \(i\), \(true\)), \(true\))
            \(RuleEnd\)()
          ENDIF
        ENDDO
      ENDDO
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          The inertial rules generation function shown in Algorithm
          \ref{algo-polup-giner} is composed of 3 functions that generate
          inertial rules for each atom type: holds, membership and
          subset. Each type of rule is generated by composing
          different combinations of entity identifiers together to form a fact.
          Each rule is then formed by stating that for each policy update
          state, a fact holds in the current state if it also holds in the
          previous state and its negation does not hold in the current state.

          \begin{valgorithm}{GenInertRules()}{algo-polup-giner}
FUNCTION \(GenInertRules\)(\(\theta\), \(\psi\))
  \(GenHldsInertRules\)(\(\theta\), \(\psi\))
  \(GenMembInertRules\)(\(\theta\), \(\psi\))
  \(GenSubsInertRules\)(\(\theta\), \(\psi\))
ENDFUNCTION
          \end{valgorithm}

          Algorithm \ref{algo-polup-ghinr} shows the $GenHldsInertRules$()
          function which generates the inertial rules for holds atoms. A
          similar method is used by the functions that generate the inertial
          rules for the other two atom types.

          \begin{valgorithm}{GenHldsInertRules()}{algo-polup-ghinr}
FUNCTION \(GenHldsInertRules\)(\(\theta\), \(\psi\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\)\(\theta\).\(s\)\(|\) - \(1\)) DO
      FOR \(k\) = \(0\) TO (\(|\)\(\theta\).\(a\)\(|\) - \(1\)) DO
        FOR \(l\) = \(0\) TO (\(|\)\(\theta\).\(o\)\(|\) - \(1\)) DO
          \(\alpha\) = \(holds\)(\(\theta\).\(s\)[\(j\)], \(\theta\).\(a\)[\(k\)], \(\theta\).\(o\)[\(l\)])
          \(RuleBegin\)()
          \(RuleHead\)(\(Encode\)(\(\alpha\), \(i\) \(+\) \(1\), \(true\)))
          \(RuleBody\)(\(Encode\)(\(\alpha\), \(i\), \(true\)), \(true\))
          \(RuleBody\)(\(Encode\)(\(\alpha\), \(i\) \(+\) \(1\), \(false\)), \(false\))
          \(RuleEnd\)()
          \(RuleBegin\)()
          \(RuleHead\)(\(Encode\)(\(\alpha\), \(i\) \(+\) \(1\), \(false\)))
          \(RuleBody\)(\(Encode\)(\(\alpha\), \(i\), \(false\)), \(true\))
          \(RuleBody\)(\(Encode\)(\(\alpha\), \(i\) \(+\) \(1\), \(true\)), \(false\))
          \(RuleEnd\)()
        ENDDO
      ENDDO
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          The function $GenRefleRules$() shown in Algorithm
          \ref{algo-polup-grefr} generates the reflexivity rules for each atom
          type: subject, access right and object. A simple procedure is
          followed by each of the 3 functions: for every subject, access right
          and object group entities, a subset rule is formed to
          show that a group is a subset of itself. As with the other rules,
          each rule generated by these functions is replicated for each policy
          update state. Algorithm \ref{algo-polup-gsrer} shows how the
          $GenSubRefleRules$() function generates the reflexivity rules for
          subject groups.

          \begin{valgorithm}{GenRefleRules()}{algo-polup-grefr}
FUNCTION \(GenRefleRules\)(\(\theta\), \(\psi\))
  \(GenSubRefleRules\)(\(\theta\), \(\psi\))
  \(GenAccRefleRules\)(\(\theta\), \(\psi\))
  \(GenObjRefleRules\)(\(\theta\), \(\psi\))
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{GenSubRefleRules()}{algo-polup-gsrer}
FUNCTION \(GenSubRefleRules\)(\(\theta\), \(\psi\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\)\(\theta\).\(sg\)\(|\) - \(1\)) DO
      \(RuleBegin\)()
      \(RuleHead\)(\(Encode\)(\(subst\)(\(\theta\).\(sg\)[\(j\)], \(\theta\).\(sg\)[\(j\)]), \(i\), \(true\)))
      \(RuleBody\)(\(true\), \(true\))
      \(RuleEnd\)()
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          The last two functions shown in Algorithm \ref{algo-polup-gconr}
          and Algorithm \ref{algo-polup-ghcor} shows the algorithm to generate
          consistency rules for each atom type: holds, membership and subset.
          As these rules use a similar process to generate rules, only the
          holds consistency rule generation algorithm is shown. The rules that
          are generated ensure that only a fact or its negation, but never
          both, holds in the same policy update state.

          \begin{valgorithm}{GenConsiRules()}{algo-polup-gconr}
FUNCTION \(GenConsiRules\)(\(\theta\), \(\psi\))
  \(GenHldsConsiRules\)(\(\theta\), \(\psi\))
  \(GenMembConsiRules\)(\(\theta\), \(\psi\))
  \(GenSubsConsiRules\)(\(\theta\), \(\psi\))
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{GenHldsConsiRules()}{algo-polup-ghcor}
FUNCTION \(GenHldsConsiRules\)(\(\theta\), \(\psi\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\)\(\theta\).\(s\)\(|\) - \(1\)) DO
      FOR \(k\) = \(0\) TO (\(|\)\(\theta\).\(a\)\(|\) - \(1\)) DO
        FOR \(l\) = \(0\) TO (\(|\)\(\theta\).\(o\)\(|\) - \(1\)) DO
          \(\alpha\) = \(holds\)(\(\theta\).\(s\)[\(j\)], \(\theta\).\(a\)[\(k\)], \(\theta\).\(o\)[\(l\)])
          \(RuleBegin\)()
          \(RuleHead\)(\(false\))
          \(RuleBody\)(\(Encode\)(\(\alpha\), \(i\), \(true\)), \(true\))
          \(RuleBody\)(\(Encode\)(\(\alpha\), \(i\), \(false\)), \(true\))
          \(RuleEnd\)()
        ENDDO
      ENDDO
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

      \subsection{Query Evaluation}
        \label{subs-polup-evalu}

        Once a normal logic program has been generated from the authorisation
        policy stored in the storage structure, a set of answer sets may then
        be generated through the use of the stable model semantics
        \cite{SIM1,NIE} with the {\em SModels} program\footnotemark. Query
        evaluation then becomes possible by checking whether each fact of a
        given query expression holds in each generated answer set of the
        normal logic program.

        \footnotetext{
          SModels Package from
          {\tt \scriptsize http://www.tcs.hut.fi/Software/smodels}
        }

        Query evaluation works as follows. Given a set of answer sets
        $\Lambda$, an expression $exp$, the process of query evaluation returns
        either either {\em true}, {\em false} or {\em unknown} depending on the
        following conditions:

        \begin{enumerate}
          \item
            If each fact in the query expression $exp$ is also in every answer
            set $\Lambda$, then $exp$ is evaluated as {\em true}.

          \item
            If the negation of each fact in $exp$ is also in every answer set
            $\Lambda$, then $exp$ is evaluated as {\em false}.

          \item
            If none of the first two conditions are met, then $exp$ is
            evaluated as {\em unknown}.
        \end{enumerate}

    \section{Experimental Results}
      \label{sect-polup-exper}

      In this section, we investigate the effects of domain size over
      computation time. The following tests  were conducted with PolicyUpdater
      version 1.0.4 on an AMD Athlon XP 2000+ machine with 512 MB of RAM,
      running the Debian GNU/Linux 3.0r5 operating system with a plain
      Linux 2.4.30 kernel.

      Table \ref{tabl-polup-tedom} shows the domain size for each test case.
      $S_{E_{s}}$ and $S_{E_{g}}$ are the numbers of singular and group
      entities, respectively; $S_{I}$ is the number of initial state facts;
      $S_{C}$ is the number of constraint rules; $S_{U}$ is the number of
      policy update definitions; $S_{S}$ is the number of policy updates in
      the sequence list; and $S_{Q}$ is the number of facts to be queried.

      \begin{table}[tbhp]
        \begin{center}
          \begin{tabular}[t]{|r|r|r|r|r|r|r|r|}
            \hline
            &
            \textbf{$S_{E_{s}}$} &
            \textbf{$S_{E_{g}}$} &
            \textbf{$S_{I}$} &
            \textbf{$S_{C}$} &
            \textbf{$S_{U}$} &
            \textbf{$S_{S}$} &
            \textbf{$S_{Q}$} \\
            \hline
            1 & 4 & 3 & 3 & 1 & 1 & 1 & 4 \\
            \hline
            2 & 24 & 23 & 3 & 1 & 1 & 1 & 4 \\
            \hline
            3 & 104 & 3 & 3 & 1 & 1 & 1 & 4 \\
            \hline
            4 & 4 & 103 & 3 & 1 & 1 & 1 & 4 \\
            \hline
            5 & 24 & 23 & 103 & 1 & 1 & 1 & 4 \\
            \hline
            6 & 24 & 23 & 3 & 101 & 1 & 1 & 4 \\
            \hline
            7 & 24 & 23 & 3 & 1 & 101 & 1 & 4 \\
            \hline
            8 & 24 & 23 & 3 & 1 & 101 & 101 & 4 \\
            \hline
            9 & 24 & 23 & 3 & 1 & 1 & 1 & 104 \\
            \hline
            10 & 24 & 23 & 103 & 1 & 101 & 101 & 4 \\
            \hline
            11 & 24 & 23 & 3 & 101 & 101 & 101 & 4 \\
            \hline
            12 & 24 & 23 & 103 & 101 & 101 & 101 & 104 \\
            \hline
            13 & 104 & 103 & 103 & 101 & 101 & 101 & 104 \\
            \hline
          \end{tabular}
        \end{center}
        \caption{Thirteen Test Cases with Different Domain Sizes}
        \label{tabl-polup-tedom}
      \end{table}

      The language {\cal L} code listing in Example \ref{exam-langl-syntx} is
      used in the first test case. In the second test case, the same code is
      used with 20 new singular entities and 20 new group entities. Test cases
      3 and 4 are similar to test case 1, except 100 new singular and group
      entities were added, respectively. Test cases 5 and 6 are similar to test
      case 2, except 100 new initial state facts and constraint rules were
      added, respectively. In test case 7, 100 new policy update definitions
      were added, and in test case 8, these policy update definitions were
      applied. Test case 9 is similar to test case 2, but this one tries to
      evaluate 100 additional query facts. Test case 11 is a combination of
      test cases 6 and 8. Test case 12 is a combination of test cases 5, 9
      and 11. Finally, test case 13 is a combination of test cases 3 to 9,
      where the number of each domain component is over 100.

      Table \ref{tabl-polup-teres} shows the execution times of each test case.
      $T_{C}$ is the total time (in seconds) spent by the system to translate
      the language {\cal L} statements to a normal logic program and to
      generate the answer sets. $T_{Q}$ is the total time (in seconds) used by
      the system to evaluate all the queries. To increase result accuracy,
      each test was conducted 10 times. The figures in Table
      \ref{tabl-polup-teres} are the averages.

      \begin{table}[tbhp]
        \begin{center}
          \begin{tabular}[t]{|r|r|r|}
            \hline
            &
            \textbf{$T_{C}$} &
            \textbf{$T_{Q}$} \\
            \hline
            1 & 0.000794 & 0.000472 \\
            \hline
            2 & 0.261828  & 0.600932 \\
            \hline
            3 & 0.072069 & 0.157254 \\
            \hline
            4 & 14.017335 & 32.109291 \\
            \hline
            5 & 0.309517 & 0.698068 \\
            \hline
            6 & 0.306517 & 0.694729 \\
            \hline
            7 & 0.304570 & 0.696636 \\
            \hline
            8 & 15.315347 & 32.111353 \\
            \hline
            9 & 0.301429 & 25.147113 \\
            \hline
            10 & 15.375953 & 32.537575 \\
            \hline
            11 & 15.889154 & 33.246048 \\
            \hline
            12 & 15.715761 & 575.237985 \\
            \hline
            13 & - & - \\
            \hline
          \end{tabular}
        \end{center}
        \caption{Average Computation Times in Seconds}
        \label{tabl-polup-teres}
      \end{table}

      As shown in Table \ref{tabl-polup-teres}, the first two execution times
      are minimal when the domain size is small. Test 3 shows that having a
      large number of singular entities have a measurable, but insignificant
      effect on computation time. However, test 4 shows that an increase in
      the number of group entities have a great impact on computation speed.
      This is to be expected, as Section \ref{sect-langl-seman} shows that the
      number of group entities directly affect the number of transitivity,
      inheritance and identity rules generated in the translation.

      Comparing test 2 with tests 5 and 6, where the number of initial state
      facts and constraint rules are increased by 100, respectively, we observe
      that that there is a slight increase in the times required to perform the
      computation and query evaluation. One would expect that an increase in
      the number of constraint rules will have more impact in execution times
      than an increase in initial state facts. However, in test 6, the
      computation times were low because only one policy update was actually
      applied.

      Test 7 shows that increasing the number of policy update definitions
      has little impact on the computation times. However, as test 8 shows,
      if these policy updates are actually applied to the policy base,
      computation time increases dramatically.

      Test case 9 shows that evaluating 100 additional queries has little
      effect on translation and computation time, but obviously affects
      evaluation time.

      Test case 10 shows the combined effects of an increased number of policy
      updates and initial state facts. As expected, the times are only slightly
      larger than the times in test case 8, where only the number of policy
      updates were increased. This is due to the fact that initial state facts
      are translated directly into normal logic program rules. On the other
      hand, test case 11 shows a significant increase in both computation and
      evaluation times. This is expected, as the translation of a single
      constraint rule results in a constraint rule in every policy update
      state.

      Test case 12 shows that although large numbers of initial state facts and
      query requests by themselves have little effect on performance, if
      combined together with the effects of a large number of policy updates,
      computation time is significantly increased, particularly the query
      evaluation time. Note that the value of $T_{Q}$ for this test is the
      average total time for 104 query evaluations. Using this value, each
      query evaluation takes an average of 5.531135 seconds to complete.

      Unfortunately, the test system used in this experiment ran out of memory
      while performing test case 13. Again, this is expected, as the combined
      effects of having a large number of entities, constraint rules, policy
      updates and queries will result in approximately 5.7 billion rules, using
      the formula given in Theorem \ref{theo-langl-tsize}.

    \section{Case Study: Web Server Application}
      \label{sect-polup-cases}

      The expressiveness of language $\cal{L}$ and the effectiveness of the
      PolicyUpdater system can be demonstrated by a web server authorisation
      application. In this application, the core PolicyUpdater system serves as
      an authorisation module for the {\em Apache}\footnotemark web server.

      \footnotetext{
        Apache Web Server from {\tt \scriptsize http://www.apache.org}
      }

      The Apache web server provides a generic access control system as
      provided by its {\em mod\_auth} and {\em mod\_access} modules
      \cite{AP,LAU}. With this built-in access control system, Apache provides
      the standard HTTP {\em Basic} and {\em Digest} authentication schemes
      \cite{HTTP2}, as well as an authorisation system to enforce access
      control policies. Although the PolicyUpdater module do not provide the
      full functionality of Apache's built-in authorisation module
      {\em mod\_auth}, it does provide a flexible logic-based authorisation
      mechanism.

      As shown in Figure \ref{figu-polup-modul}, Apache's Access Control
      module, together with its policy base, is replaced by the PolicyUpdater
      module and its own policy base. The sole purpose of the PolicyUpdater
      module is to act as an interface between the web server and the core
      PolicyUpdater system. The system works as follows: as the server is
      started, the PolicyUpdater module initialises the core PolicyUpdater
      system by sending the policy base. When a client makes an arbitrary
      HTTP request for a resource from the server (1), the client (user) is
      authenticated against the password table by the built-in authentication
      module; once the client is properly authenticated (2) the request is
      transferred to the PolicyUpdater module, which in turn generates a
      language ${\cal L}$ query (3) from the request details, then sends the
      query to the core PolicyUpdater system for evaluation; if the query is
      successful and access control is granted, the original request is sent to
      the other request handlers of the web server (4) where the request is
      eventually honoured; then finally (5), the resource (or acknowledgement
      for HTTP requests other than GET) is sent back to the client. Optionally,
      client can be an administrator who, after being authenticated, is
      presented with a special administrator interface by the module to allow
      the policy base to be updated.

      \begin{figure}[tbhp]
        \begin{center}
          \includegraphics{sys-03}
          \caption{PolicyUpdater Module for the Apache Web Server}
          \label{figu-polup-modul}
        \end{center}
      \end{figure}

      \subsection{Policy Description in Language ${\cal L}'$}
        \label{subs-polup-polde}

        The policy description in the policy base is written in language
        ${\cal L'}$, which is syntactically and semantically similar to
        language ${\cal L}$ except for the lack of entity identifier
        definitions. Entity identifiers need not be explicitly defined in
        the policy definition:

        \begin{itemize}
          \item
            {\em Subjects} of the authorisation policies are the users. Since
            all users must first be authenticated, the password table used
            in authentication may also be used to extract the list of subjects.
          \item
            {\em Access Rights} are the HTTP request methods defined by the
            HTTP 1.1 standard \cite{HTTP1}: {\em OPTIONS}, {\em GET},
            {\em HEAD}, {\em POST}, {\em PUT}, {\em DELETE}, {\em TRACE} and
            {\em CONNECT}.
          \item
            {\em Objects} are the resources available in the server themselves.
            Assuming that the document root is a hierarchy of directories and
            files, each of these are mapped as a unique object of language
            ${\cal L'}$.
        \end{itemize}

        Like language ${\cal L}$, language ${\cal L'}$ allows the definition of
        initial state facts, constraint rules and policy update definitions.

      \subsection{Mapping the Policy to Language ${\cal L}$}
        \label{subs-polup-mappi}

        As mentioned above, one task of the PolicyUpdater module is to
        generate a language ${\cal L}$ policy from the given language
        ${\cal L'}$ to be evaluated by the core PolicyUpdater system.
        This process is outlined below:

        \begin{itemize}
          \item
            {\em Generating entity identifier definitions.} Subject entities are
            taken from the authentication (password) table; access rights are
            hard-coded built-ins; and the list of objects are generated by
            traversing the document root for files and directories.
          \item
            {\em Generating additional constraints.} Additional constraint
            rules are generated to preserve the relationship between groups
            and elements. This is useful to model the assertion that unless
            explicitly stated, users holding particular access rights to a
            directory automatically hold those access rights to every file in
            that directory (recursively, if with subdirectories). The module
            makes this assertion by generating non-conditional constraint rules
            that state that each file (object) is a member of the directory
            (object group) in which it is contained.
        \end{itemize}

        All other language ${\cal L'}$ statements (initial state declarations,
        constraint declarations and policy update declarations) are already in
        language ${\cal L}$ form.

      \subsection{Evaluation of HTTP Requests}
        \label{subs-polup-httpr}

         A HTTP request may be represented as a simplified tuple:

         \begin{quote}
           $<$$usr$, $req\_meth$, $req\_res$$>$
         \end{quote}

         $usr$ is the authenticated username that made the request (subject);
         $req\_meth$ is a standard HTTP request method (access right); and
         $req\_res$ is the resource associated with the request (object).
         Intuitively, such a tuple may be expressed as a language ${\cal L}$
         atom:

         \begin{vverbatim}
 holds(usr, req\_meth, req\_res)
         \end{vverbatim}

         With each request expressed as language ${\cal L}$ atoms, a language
         ${\cal L}$ query statement can be composed to check if the request is
         to be honoured:

         \begin{vverbatim}
 query holds(usr, req\_meth, req\_res);
         \end{vverbatim}

         Once the query statement is composed, it is then sent by the
         PolicyUpdater module to the core PolicyUpdater system for evaluation
         against the policy base.

      \subsection{Policy Updates by Administrators}
        \label{subs-polup-admin}

        After being properly authenticated, an administrator can perform policy
        updates through the use of a special interface generated by the
        PolicyUpdater module. This interface lists all the predefined policy
        updates that are allowed, as defined in the policy description in
        language ${\cal L'}$, as well as all the policy updates that have been
        previously applied and are in effect. As with the core PolicyUpdater
        system, administrators are allowed only the following operations:

        \begin{itemize}
          \item
            Apply a policy update or a sequence of policy updates to the policy
            base. Note that like language ${\cal L}$, in language ${\cal L'}$
            policy updates are predefined within the policy base themselves.
          \item
            Revert to a previous state of the policy base by removing a
            previously applied policy update from the policy base.
        \end{itemize}

  \chapter{Temporal Constraints in Authorisation Policies}
    \label{chap-tempo}

    \section{Introduction}
      \label{sect-intro}

      An obvious limitation of language ${\cal L}$ is its lack of expressive
      power to represent time-dependent authorisations. Consider the following
      authorisation rule:

      \begin{vquote}
        $Bob$ holds $read$ access to file $f$ between $9:00$ $AM$ and $5:00$
        $PM$
      \end{vquote}

      The authorisation information above can be broken down into two parts: an
      authorisation part, i.e. "Bob holds read access to file $f$", and a
      temporal part, i.e. "between 9:00 AM and 5:00 PM". As language ${\cal L}$
      can already express authorisations, we focus our attention to the
      temporal part. A naive attempt to extend language ${\cal L}$ to express
      time may involve adding two extra parameters to each authorisation atom
      to represent the starting and ending time points of the interval. For
      example, the authorisation rule above can be represented as:

      \begin{vquote}
        $holds$($bob$, $read$, $f$, $900$, $1700$)
      \end{vquote}

      The atom above may be interpreted to mean that the authorisation holds
      for all times between 9:00 AM and 5:00 PM, inclusive. In this example,
      the granularity of time, or the smallest unit of time that can be
      expressed, is one minute. Of course, a more general approach is to use
      the domain of positive integers. With this approach, the system can
      handle different granularities of time, where the choice of what time
      unit each discrete value is interpreted as is left to the application.
      For example, if the temporal values are defined to be the number of
      seconds since 12 midnight, 01 Jan 1970 (i.e. the beginning of the UNIX
      epoch), then the atom below states that the authorisation holds at an
      interval starting at 9:00 AM, 18 March 1976 and ending at 5:00 PM, 18
      March 1976:

      \begin{vquote}
        $holds$($bob$, $read$, $f$, $195951600$, $195980400$)
      \end{vquote}

      While this approach gives the language enough expressive power to
      represent authorisations bound by literal time values, it is by no means
      expressive enough to model relationships between the time values
      themselves. This deficiency is shown in the example below:

      \begin{vquote}
        $Alice$ holds a $write$ access right to file $f_0$ after $Bob$ holds a
        $read$ access right to file $f_1$
      \end{vquote}

      Such authorisation rule might arise in a situation where the access right
      $write$ to file $f_0$ can only be granted at some time after the $read$
      access right to file $f_1$ has been granted and revoked. This example
      shows that the specific times at which authorisations hold are not as
      important as the relationship between the times themselves. This
      authorisation rule may be represented as follows:

      \begin{vquote}
        $holds$($alice$, $write$, $f_0$, $\iota_0$)

        $holds$($bob$, $read$, $f_0$, $\iota_1$)

        $after$($\iota_0$, $\iota_1$)
      \end{vquote}

      The example above states that $alice$ holds a $write$ access right to
      file $f_0$ at some time interval $\iota_0$, $bob$ holds a $read$ access
      right to file $f_1$ at some time interval $\iota_1$, and that the
      interval $\iota_0$ occurs at some time after the interval $\iota_1$. As
      mentioned earlier, the actual values of the time intervals $\iota_0$ and
      $\iota_1$ is not as important as the fact that the interval $\iota_0$
      occurs after interval $\iota_1$.

      The rest of this chapter discusses how temporal constraints can be
      incorporated into the authorisation language. The next section introduces
      Allen's temporal interval algebra to express relations between time
      values, followed by a section that outlines extensions to this algebra,
      and finally, the last section gives a detailed formalisation of a new
      authorisation language that utilises the interval algebra to support
      temporal constraints.

    \section{Allen's Temporal Interval Algebra}
      \label{sect-tempo-algeb}

      Allen's interval algebra \cite{ALE} is based on the fact that for any
      two well defined time intervals, there exists exactly one interval
      relation between them. The strength of the algebra lies not just on
      the formalisation of these relations, but also on its ability to handle
      disjunctive interval relations between undefined time intervals.

      For example, given an interval $\iota_0$, defined as 24th of September,
      1995 to 25th of September, 1995; and interval $\iota_1$, defined as 25th
      of December 1995 to 1st of January 1996. From the definitions of these
      intervals, it is easy to conclude that interval $\iota_0$ is {\em before}
      interval $\iota_1$, since the finishing end point of interval $\iota_0$
      occurs before the starting end point of interval $\iota_1$.

      The strength of the interval algebra can be illustrated by considering
      intervals without endpoint definitions, but rather as having disjunctive
      relations with other intervals. For example, given three intervals
      $\iota_0$, $\iota_1$ and $\iota_2$ whose bounding endpoints are not
      known. The algebra allows us to conclude that if $\iota_0$ occurs either
      {\em before} or {\em during} $\iota_1$ and $\iota_2$ occurs {\em after}
      $\iota_1$, then the interval $\iota_0$ must occur {\em before} $\iota_2$.

      The rest of the section gives a detailed overview of Allen's interval
      algebra.

      \subsection{Time Points and Time Intervals}
        \label{subs-tempo-tpint}

        The preceding introduction hinted the difference between a time point
        and a time interval. This sub section aims to give a more formal
        distinction between the two.

        A point in time represents an event with zero duration, or an event
        that occurs instantaneously, such as the switching on of a light bulb,
        or the moment the sun has risen in the morning.

        A time interval, on the other hand, is defined to be the time that has
        elapsed between two given time points. For example, the interval one
        might call lunch hour may be defined as the time elapsed between the
        time points 1 PM and 2 PM.

        Formally, a time interval $\iota$ is defined by its starting end point
        $\iota^-$ and a finishing end point $\iota^+$, where $\iota^-$ $<$
        $\iota^+$.

        One might argue that time point events such as the switching on of a
        light bulb are not instantaneous, meaning that time, no matter how
        small the value, has elapsed between the instant that electricity
        flowed through light bulb's filament and the instant the light from
        the bulb reaches the observer's eyes. One can further argue that the
        "instant" that electricity flowed through the bulb's filament is not
        instantaneous, once we realise that the speed of light and electricity
        is finite. In other words, any given event can always be divided into
        sub-events. This argument is more evident in the sunrise example.

        To solve this problem, Allen's algebra defines time intervals as the
        most basic entities. This means time points are not used to define
        time intervals, but instead, each interval is defined only in terms
        of its relationship with other intervals.

      \subsection{Time Interval Relations}
        \label{subs-tempo-inrel}

        As shown in Figure \ref{figu-tempo-13rel}, the algebra defines 13
        disjoint relations that can occur between any two intervals. For
        the sake of clarity, we define each temporal interval relation
        below in terms of the relationships of the end points of their
        intervals:

        \begin{figure}[tbhp]
          \begin{center}
            \includegraphics{rels}
            \caption{Thirteen Temporal Interval Relations}
            \label{figu-tempo-13rel}
          \end{center}
        \end{figure}

        \begin{enumerate}
          \item
            {\em Before}.
            Interval $\iota_0$ is said to be {\em before} interval $\iota_1$
            if and only if $\iota_0^+$ $<$ $\iota_1^-$.

          \item
            {\em After}.
            Interval $\iota_0$ is said to be {\em after} interval $\iota_1$ if
            and only if $\iota_0^-$ $>$ $\iota_1^+$. Note that this is an
            inverse of the {\em before} relation.

          \item
            {\em Meets}.
            Interval $\iota_0$ is said to {\em meet} interval $\iota_1$ if and
            only if $\iota_0^+$ $=$ $\iota_1^-$.

          \item
            {\em Met By}.
            Interval $\iota_0$ is said to be {\em met by} interval $\iota_1$ if
            and only if $\iota_0^-$ $=$ $\iota_1^+$. Note that this is an
            inverse of the {\em meets} relation.

          \item
            {\em During}.
            Interval $\iota_0$ is said to be {\em during} interval $\iota_1$ if
            and only if $\iota_0^-$ $>$ $\iota_1^-$ and $\iota_0^+$ $<$
            $\iota_1^+$.

          \item
            {\em Contains}.
            Interval $\iota_0$ is said to {\em contain} interval $\iota_1$ if
            and only if $\iota_0^-$ $<$ $\iota_1^-$ and $\iota_0^+$ $>$
            $\iota_1^+$. Note that this is an inverse of the {\em during}
            relation.

          \item
            {\em Overlaps}.
            Interval $\iota_0$ is said to {\em overlap} interval $\iota_1$ if
            and only if $\iota_0^-$ $<$ $\iota_1^-$, $\iota_0^+$ $>$
            $\iota_1^-$ and $\iota_0^+$ $<$ $\iota_1^+$.

          \item
            {\em Overlapped By}.
            Interval $\iota_0$ is said to be {\em overlapped by} interval
            $\iota_1$ if and only if $\iota_0^-$ $>$ $\iota_1^-$, $\iota_0^-$
            $<$ $\iota_1^+$ and $\iota_0^+$ $>$ $\iota_1^+$. Note that this is
            an inverse of the {\em overlaps} relation.

          \item
            {\em Starts}.
            Interval $\iota_0$ is said to {\em start} interval $\iota_1$ if and
            only if $\iota_0^-$ $=$ $\iota_1^-$ and $\iota_0^+$ $<$
            $\iota_1^+$.

          \item
            {\em Started By}.
            Interval $\iota_0$ is said to be {\em started by} interval
            $\iota_1$ if and only if $\iota_0^-$ $=$ $\iota_1^-$ and
            $\iota_0^+$ $>$ $\iota_1^+$. Note that this is an inverse of the
            the {\em starts} relation.

          \item
            {\em Finishes}.
            Interval $\iota_0$ is said to {\em finish} interval $\iota_1$ if
            and only if $\iota_0^-$ $>$ $\iota_1^-$ and $\iota_0^+$ $=$
            $\iota_1^+$.

          \item
            {\em Finished By}.
            Interval $\iota_0$ is said to be {\em finished by} interval
            $\iota_1$ if and only if $\iota_0^-$ $<$ $\iota_1^-$ and
            $\iota_0^+$ $=$ $\iota_1^+$. Note that this is an inverse of the
            {\em finishes} relation.

          \item
            {\em Equals}.
            Interval $\iota_0$ {\em equals} interval $\iota_1$ if and only if
            $\iota_0^-$ $=$ $\iota_1^-$ and $\iota_0^+$ $=$ $\iota_1^+$.
        \end{enumerate}

        For example, given intervals {\em lunch hour} and {\em work hours},
        defined as 1 PM to 2 PM and 9 AM to 5 PM, respectively. Since 1 PM
        (1300 hours) is greater than 9 AM (0900 hours) and 2 PM (1400 hours) is
        less than 5 PM (1700 hours), then the interval {\em lunch hour} is
        {\em during} the interval {\em work hours}.

      \subsection{Inferring New Relations}
        \label{subs-tempo-infer}

        As mentioned earlier, the strength of the algebra is its ability to
        infer new relations from existing ones. This is achieved by taking
        advantage of the transitive properties of relations. For example,
        given that interval $\iota_0$ is {\em before} interval $\iota_1$ and
        interval $\iota_1$ is {\em before} interval $\iota_2$. Regardless of
        what the end points are, interval $\iota_0$ is {\em before} interval
        $\iota_2$.

        While simple relations like the one shown in the above example may seem
        intuitive, we quickly realise that it may not be so if we consider that
        a relation that exists between any two intervals may be given as a
        disjunctive set of possible relations. For example, the relation
        between interval $\iota_0$ and interval $\iota_1$ may be given as a set
        of possible relations \{{\em before}, {\em after}, {\em during}\}.

        Another issue is propagation. Given that the temporal knowledge base
        is populated by these disjunctive interval relations, adding new
        pieces of information may narrow down the set of possible relations
        between two intervals. This in turn may lead to the trimming down of
        other relations between other interval pairs. In fact, as new and more
        specific information are added into the knowledge base, its effects may
        propagate to other relations.

        \subsubsection{Interval Relation Network}

          The temporal interval relation knowledge base is represented as a
          network whose nodes represent intervals and the arcs between them
          represent a set of possible relations that hold between the two
          intervals. Note that although this representation allows the
          assignment of a set of relations between any two intervals, because
          the relations are mutually exclusive, we know that only one of these
          relations actually holds. The fact that some interval pairs have a
          set of relations between them only suggests that the information
          given is insufficient to define the exact relation that holds
          between the intervals. Formally, we define the interval relation
          network as follows:

          \begin{vdefinition}
            \label{defn-tempo-netwk}
            A {\bf interval relation network} is a collection of {\bf nodes}
            and {\bf arcs}, where each node represents a single temporal
            interval and each arc represents a set of possible relations
            between two intervals. For any node pair, there is exactly one arc
            between them.
          \end{vdefinition}

          The interval relation network is maintained in such a way that each
          node is connected to every other node in the network. In cases where
          no information is given to define an arc, we use the default arc
          which  contains a set of all 13 relations. As a matter of convention
          in the notation, we only show one arc between two nodes. The reverse
          arc, composed of the inverses of the relations represented by the
          first arc, is omitted.

          Figure \ref{figu-tempo-ntwk1} gives an example of a network with
          three nodes: $\iota_0$, $\iota_1$ and $\iota_2$ and the following
          relations:

          \begin{itemize}
            \item
              Interval $\iota_0$ is {\em before} or {\em during} interval
              $\iota_1$.
            \item
              Interval $\iota_1$ {\em overlaps} interval $\iota_2$.
          \end{itemize}

          In this example, note that because no relation is defined for
          intervals $\iota_0$ and $\iota_2$, the corresponding arc between
          these nodes in Figure \ref{figu-tempo-ntwk1} is labelled {\em All},
          meaning the relation set contains all 13 possible relations.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-01}
              \caption{Network Representation Example}
              \label{figu-tempo-ntwk1}
            \end{center}
          \end{figure}

          With the network structure defined, we can now formally define the
          three basic network operators:

          \begin{vdefinition}
            \label{defn-tempo-netop}
            Given a temporal interval network $NET$. The three basic network
            operations are as follows:

            \begin{enumerate}
              \item
                The $NET.Get$($\iota_0$, $\iota_1$) operator returns the
                relation set on the arc between intervals $\iota_0$ and
                $\iota_1$.

              \item
                The $NET$.$Replace$($\iota_0$, $\iota_1$, $rs$) operator
                replaces the relation set on the arc between intervals
                $\iota_0$ and $\iota_1$ with the relation set $rs$.
              \item
                The $NET.AddRel$($\iota_0$, $\iota_1$, $rs$) operator adds the
                relation set $rs$ to the arc between intervals $\iota_0$ and
                $\iota_1$, and propagates the effects of this change to the
                rest of the network.
            \end{enumerate}
          \end{vdefinition}

          As described in the definition above, the $NET.Get$() and
          $NET.Replace$() operators are simple $get$() and $set$() operations
          on arc labels. In contrast, the $NET.AddRel$() operator requires a
          more complex algorithm to perform the propagation. This algorithm is
          discussed in detail in the next section.

          \begin{table}[p]
            \begin{vvarmargin}{-4cm}{-4cm}
              \begin{center}
                \tiny
                \begin{tabular}[t]{|r|l|l|l|l|l|l|l|l|l|l|l|l|}
                  \hline
                                          & \textbf{Before}         & \textbf{After}          & \textbf{During}         & \textbf{Contains}       & \textbf{Overlaps}       & \textbf{Overlapped By}  & \textbf{Meets}          & \textbf{Met}            & \textbf{Starts}         & \textbf{Started By}     & \textbf{Finishes}       & \textbf{Finished By}    \\
                                          & (BEF)                   & (BEI)                   & (DUR)                   & (DUI)                   & (OVR)                   & (OVI)                   & (MET)                   & (MEI)                   & (STA)                   & (STI)                   & (FIN)                   & (FII)                   \\
                  \hline
                  \textbf{Before}         & BEF                     & ALL                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     \\
                  (BEF)                   &                         &                         & OVR                     &                         &                         & OVR                     &                         & OVR                     &                         &                         & OVR                     &                         \\
                                          &                         &                         & MET                     &                         &                         & MET                     &                         & MET                     &                         &                         & MET                     &                         \\
                                          &                         &                         & DUR                     &                         &                         & DUR                     &                         & DUR                     &                         &                         & DUR                     &                         \\
                                          &                         &                         & STA                     &                         &                         & STA                     &                         & STA                     &                         &                         & STA                     &                         \\
                  \hline
                  \textbf{After}          & ALL                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     \\
                  (BEI)                   &                         &                         & OVI                     &                         & OVI                     &                         & OVI                     &                         & OVI                     &                         &                         &                         \\
                                          &                         &                         & MEI                     &                         & MEI                     &                         & MEI                     &                         & MEI                     &                         &                         &                         \\
                                          &                         &                         & DUR                     &                         & DUR                     &                         & DUR                     &                         & DUR                     &                         &                         &                         \\
                                          &                         &                         & FIN                     &                         & FIN                     &                         & FIN                     &                         & FIN                     &                         &                         &                         \\
                  \hline
                  \textbf{During}         & BEF                     & BEI                     & DUR                     & ALL                     & BEF                     & BEI                     & BEF                     & BEI                     & DUR                     & BEI                     & DUR                     & BEF                     \\
                  (DUR)                   &                         &                         &                         &                         & OVI                     & OVI                     &                         &                         &                         & OVI                     &                         & OVR                     \\
                                          &                         &                         &                         &                         & MET                     & MEI                     &                         &                         &                         & MEI                     &                         & MET                     \\
                                          &                         &                         &                         &                         & DUR                     & DUR                     &                         &                         &                         & DUR                     &                         & DUR                     \\
                                          &                         &                         &                         &                         & STI                     & FIN                     &                         &                         &                         & FIN                     &                         & STA                     \\
                  \hline
                  \textbf{Contains}       & BEF                     & BEI                     & OVR                     & DUI                     & OVR                     & OVI                     & OVR                     & OVI                     & DUI                     & DUI                     & DUI                     & DUI                     \\
                  (DUI)                   & MET                     & DUI                     & DUR                     &                         & DUI                     & DUI                     & DUI                     & DUI                     & FII                     &                         & STI                     &                         \\
                                          & DUI                     & MEI                     & STA                     &                         & FII                     & STI                     & FII                     & STI                     & OVR                     &                         & OVI                     &                         \\
                                          & FII                     & STI                     & FIN                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Overlaps}       & BEF                     & BEI                     & OVR                     & BEF                     & BEF                     & OVR                     & BEF                     & OVI                     & OVR                     & DUI                     & DUR                     & BEF                     \\
                  (OVR)                   &                         & OVI                     & DUR                     & OVR                     & OVR                     & OVI                     &                         & DUI                     &                         & FII                     & STA                     & OVR                     \\
                                          &                         & DUI                     & STA                     & MET                     & MET                     & DUR                     &                         & STI                     &                         & OVR                     & OVR                     & MET                     \\
                                          &                         & MEI                     &                         & DUI                     &                         & STA                     &                         &                         &                         &                         &                         &                         \\
                                          &                         & STI                     &                         & FII                     &                         & FIN                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Overlapped By}  & BEF                     & BEI                     & OVI                     & BEI                     & OVR                     & BEI                     & OVR                     & BEI                     & OVI                     & OVI                     & OVI                     & OVI                     \\
                  (OVI)                   & OVR                     &                         & DUR                     & OVI                     & OVI                     & OVI                     & DUI                     &                         & DUR                     & BEI                     &                         & DUI                     \\
                                          & MET                     &                         & FIN                     & MEI                     & DUR                     & MEI                     & FII                     &                         & FIN                     & MEI                     &                         & STI                     \\
                                          & DUI                     &                         &                         & DUI                     & STA                     &                         &                         &                         &                         &                         &                         &                         \\
                                          & FII                     &                         &                         & STI                     & FIN                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Meets}          & BEF                     & BEI                     & OVR                     & BEF                     & BEF                     & OVR                     & BEF                     & FIN                     & MET                     & MET                     & DUR                     & BEF                     \\
                  (MET)                   &                         & OVI                     & DUR                     &                         &                         & DUR                     &                         & FII                     &                         &                         & STA                     &                         \\
                                          &                         & MEI                     & STA                     &                         &                         & STA                     &                         & EQL                     &                         &                         & OVR                     &                         \\
                                          &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Met By}         & BEF                     & BEI                     & OVI                     & BEI                     & OVI                     & BEI                     & STA                     & BEI                     & DUR                     & BEI                     & MEI                     & MEI                     \\
                  (MEI)                   & OVR                     &                         & DUR                     &                         & DUR                     &                         & STI                     &                         & FIN                     &                         &                         &                         \\
                                          & MET                     &                         & FIN                     &                         & FIN                     &                         & EQL                     &                         & OVI                     &                         &                         &                         \\
                                          & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Starts}         & BEF                     & BEI                     & DUR                     & BEF                     & BEF                     & OVI                     & BEF                     & MEI                     & STA                     & STA                     & DUR                     & BEF                     \\
                  (STA)                   &                         &                         &                         & OVR                     & OVR                     & DUR                     &                         &                         &                         & STI                     &                         & MET                     \\
                                          &                         &                         &                         & MET                     & MET                     & FIN                     &                         &                         &                         & EQL                     &                         & OVR                     \\
                                          &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Started By}     & BEF                     & BEI                     & OVI                     & DUI                     & OVR                     & OVI                     & OVR                     & MEI                     & STA                     & STI                     & OVI                     & DUI                     \\
                  (STI)                   & OVR                     &                         & DUR                     &                         & DUI                     &                         & DUI                     &                         & STI                     &                         &                         &                         \\
                                          & MET                     &                         & FIN                     &                         & FII                     &                         & FII       y             &                         & EQL                     &                         &                         &                         \\
                                          & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Finishes}       & BEF                     & BEI                     & DUR                     & BEI                     & OVR                     & BEI                     & MET                     & BEI                     & DUR                     & BEI                     & FIN                     & FIN                     \\
                  (FIN)                   &                         &                         &                         & OVI                     & DUR                     & OVI                     &                         &                         &                         & OVI                     &                         & FII                     \\
                                          &                         &                         &                         & MEI                     & STA                     & MEI                     &                         &                         &                         & MEI                     &                         & EQL                     \\
                                          &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                  \textbf{Finished By}    & BEF                     & BEI                     & OVR                     & DUI                     & OVR                     & OVI                     & MET                     & STI                     & OVR                     & DUI                     & FIN                     & FII                     \\
                  (FII)                   &                         & OVI                     & DUR                     &                         &                         & DUI                     &                         & OVI                     &                         &                         & FII                     &                         \\
                                          &                         & MEI                     & STA                     &                         &                         & STI                     &                         & DUI                     &                         &                         & EQL                     &                         \\
                                          &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                          &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                  \hline
                \end{tabular}
              \end{center}
              \caption{Transitivity Table}
              \label{tabl-tempo-ttabl}
            \end{vvarmargin}
          \end{table}

        \subsubsection{Propagation Algorithm}

          The algorithm works as follows. As a starting point, we assume that
          the network contains complete interval relation information, i.e. at
          each node, there is an arc that connects it to every other node.
          Where there is no defined relationship between two nodes, the default
          arc is used to connect these two nodes. The algorithm is invoked
          whenever new information is to be added into the network. Whenever a
          new relation is added into the network, all consequences of this new
          relation are also added into the network. These consequences are
          computed through the transitive closure of the network. The following
          example illustrates this procedure.

          Given 3 intervals $\iota_0$, $\iota_1$ and $\iota_2$, and the
          relation $\iota_0$ is {\em before} $\iota_1$. Suppose the new
          relation $\iota_2$ is {\em during} $\iota_1$ is added into the
          network. The algorithm then infers that $\iota_0$ is {\em before}
          $\iota_2$. This new relation is again added into the network in a
          similar way, possibly inferring other new relations as it is added.
          This procedure is repeated until no new information is yielded.

          Table \ref{tabl-tempo-ttabl} shows the basic transitivity rules. For
          any 3 intervals $\iota_0$, $\iota_1$ and $\iota_2$, the relation(s)
          between intervals $\iota_0$ and $\iota_2$ is shown in the
          intersection of the row that contains the relation between $\iota_0$
          and $\iota_1$, and the column that contains the relation between
          $\iota_1$ and $\iota_2$.

          Before we can define the actual algorithm, we must first define a few
          functions. For any single relations $r_0$ and $r_1$, the function
          $Trans_1$($r_0$, $r_1$) returns the relation set $rs$ that
          corresponds to the intersection of $r_0$ and $r_1$ in Table
          \ref{tabl-tempo-ttabl}.

          Using this function, we can then define the extended function
          $Trans_2$($rs_0$, $rs_1$) shown in Algorithm \ref{algo-tempo-trns2},
          which takes a pair of relation sets $rs_0$ and $rs_1$ as input, and
          returns the relation set $rs$ which contains all the possible
          relations inferred from the two given relation sets using the
          $Trans_1$() function.

          \begin{valgorithm}{Trans$_2$()}{algo-tempo-trns2}
FUNCTION \(Trans\sb{2}\)(\(rs\sb{0}\), \(rs\sb{1}\))
  \(rs\) = \(\emptyset\)
  FOR each \(r\sb{0}\) \(\in\) \(rs\sb{0}\) DO
    FOR each \(r\sb{1}\) \(\in\) \(rs\sb{1}\) DO
      \(rs\) = \(rs\) \(\cup\) \(Trans\sb{1}\)(\(r\sb{0}\), \(r\sb{1}\))
    ENDDO
  ENDDO
  RETURN \(rs\)
ENDFUNCTION
          \end{valgorithm}

          In addition to these functions, we also define a standard queue
          structure $Q$ which stores network arcs, i.e. a pair of intervals
          and a relation set that holds between the two intervals. Thus, we
          have three operators for the queue structure:

          \begin{itemize}
            \item
              $Q.Enqueue$($\iota_0$, $\iota_1$, $RS$) stores the given arc to
              the end of the structure.

            \item
              $Q.Dequeue$() returns and removes the arc at the front of the
              structure.

            \item
              $Q.IsEmpty$() returns true if the queue is empty and false
              otherwise.
          \end{itemize}

          The $NET.AddRel()$ algorithm shown in Algorithm
          \ref{algo-tempo-ntadr} works as follows. Every time a new arc
          ($\iota_0$, $\iota_1$, $rs$) is added, the algorithm finds the
          transitive relation set $RS$ between each of these intervals and
          every other interval $I$ in the network, i.e. the algorithm finds
          $RS$ = $Trans_2$($NET.Get$($\iota$, $\iota_0$), $rs$) for every other
          interval $I$ in the network. If this new relation set $RS$
          contains more specific information than what is already in the
          network, i.e. $RS$ $\subset$ $NET.Get$($I$, $\iota_1$), then this new
          arc between $I$ and $\iota_1$ (shown in Figure
          \ref{figu-tempo-ntwk2}) is again put through the same algorithm, as
          it might yield more relation changes.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-02}
              \caption{New Relation $RS$ From Interval $I$ and Interval $\iota_1$}
              \label{figu-tempo-ntwk2}
            \end{center}
          \end{figure}

          Note that the algorithm also attempts to form new transitive
          relations between the given intervals $\iota_0$ and $\iota_1$ and all
          other intervals $I$ in the network such that interval $I$ is to the
          right of the other two intervals (shown in Figure
          \ref{figu-tempo-ntwk3}).

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-03}
              \caption{New Relation $RS$ From Interval $\iota_0$ and Interval $I$}
              \label{figu-tempo-ntwk3}
            \end{center}
          \end{figure}

          \begin{valgorithm}{NET.AddRel()}{algo-tempo-ntadr}
FUNCTION \(NET.AddRel\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  \(Q.Enqueue\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  WHILE NOT \(Q.IsEmpty\)() DO
    (\(\iota\sb{0}'\), \(\iota\sb{1}'\), \(rs'\)) = \(Q.Dequeue\)()
    \(NET.Replace\)(\(\iota\sb{0}'\), \(\iota\sb{1}'\), \(rs'\))
    FOR each interval \(\iota''\) \(\in\) \(NET\) DO
      IF \(\iota''\) != \(\iota\sb{0}'\) AND \(\iota''\) != \(\iota\sb{1}'\) THEN
        \(rs''\) =  \(Trans\sb{2}\)(\(NET.Get\)(\(\iota''\), \(\iota\sb{0}'\)), \(rs'\))
        \(rs'''\) = \(NET.Get\)(\(\iota''\), \(\iota\sb{1}'\)) \(\cap\) \(rs''\)
        IF \(rs'''\) \(\subset\) \(NET.Get\)(\(\iota''\), \(\iota\sb{1}'\)) THEN
          \(Q.Add\)(\(\iota''\), \(\iota\sb{1}'\), \(rs'''\))
        ENDIF
      ENDIF
    ENDDO
    FOR each interval \(\iota''\) \(\in\) \(NET\) DO
      IF \(\iota''\) != \(\iota\sb{0}'\) AND \(\iota''\) != \(\iota\sb{1}'\) THEN
        \(rs''\) =  \(Trans\sb{2}\)(\(rs'\), \(NET.Get\)(\(\iota\sb{1}'\), \(\iota''\)))
        \(rs'''\) = \(NET.Get\)(\(\iota\sb{0}'\), \(\iota''\)) \(\cap\) \(rs''\)
        IF \(rs'''\) \(\subset\) \(NET.Get\)(\(\iota\sb{0}'\), \(\iota''\)) THEN
          \(Q.Add\)(\(\iota\sb{0}'\), \(\iota''\), \(rs'''\))
        ENDIF
      ENDIF
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          \begin{vexample}
            \label{exam-tempo-expl1}
            Given a network with three intervals $\iota_0$, $\iota_1$ and
            $\iota_2$ where no relation between any of the intervals are known.
            As no relations are given, each arc in the network as shown in
            Figure \ref{figu-tempo-ntwk4} is the default arc.

            \begin{figure}[tbhp]
              \begin{center}
                \includegraphics{net-04}
                \caption{Network with 3 Default Arcs}
                \label{figu-tempo-ntwk4}
              \end{center}
            \end{figure}

            \noindent
            Now, suppose the relation between interval $\iota_0$ and interval
            $\iota_1$ is narrowed down to the relation set \{$before$, $meets$,
            $overlaps$\}, i.e., the following operation is executed:

            \begin{vquote}
              $NET.AddRel$($\iota_0$, $\iota_1$, \{$BEF$, $MET$, $OVR$\})
            \end{vquote}

            \noindent
            This operation will yield the network shown in Figure
            \ref{figu-tempo-ntwk5}. Note that because every arc in the network
            contains all relations, the effects of the $NET.AddRel$() operation
            are limited to one arc.

            \begin{figure}[tbhp]
              \begin{center}
                \includegraphics{net-05}
                \caption{Network after $NET.AddRel$($\iota_0$, $\iota_1$, \{$BEF$, $MET$, $OVR$\})}
                \label{figu-tempo-ntwk5}
              \end{center}
            \end{figure}

            \noindent
            Now, if the relation set \{$starts$, $finishes$\} is added to the
            arc between interval $\iota_1$ and interval $\iota_2$:

            \begin{vquote}
              $NET.AddRel$($\iota_1$, $\iota_2$, \{$STA$, $FIN$\})
            \end{vquote}

            \noindent
            The algorithm will also compute the relation set $rs_2$ between
            interval $\iota_0$ and interval $\iota_2$ by using the relation set
            $rs_0$ between intervals $\iota_0$ and interval $\iota_1$, and
            relation set $rs_1$ between intervals $\iota_1$ and interval
            $\iota_2$ to complete the transitivity. In other words, the
            algorithm computes the following:

            \begin{vquote}
              $rs_2$ = $Trans_2$($rs_0$, $rs_1$)

              $rs_2$ = $Trans_2$(\{$BEF$, $MET$, $OVR$\}, \{$STA$, $FIN$\})
            \end{vquote}

            \noindent
            By referring to the transitivity table in Table
            \ref{tabl-tempo-ttabl}, we note the following:

            \begin{vquote}
              $Trans_1$($BEF$, $STA$) = \{$BEF$\}

              $Trans_1$($BEF$, $FIN$) = \{$BEF$, $OVR$, $MET$, $DUR$, $STA$\}

              $Trans_1$($MET$, $STA$) = \{$MET$\}

              $Trans_1$($MET$, $FIN$) = \{$DUR$, $STA$, $OVR$\}

              $Trans_1$($OVR$, $STA$) = \{$OVR$\}

              $Trans_1$($OVR$, $FIN$) = \{$DUR$, $STA$, $OVR$\}
            \end{vquote}

            \noindent
            Therefore, as $Trans_2$() takes the union of all the relation sets
            returned by calls to $Trans_1$(), we have:

            \begin{vquote}
              $rs_2$ = \{$BEF$, $OVR$, $MET$, $DUR$, $STA$\}
            \end{vquote}

            \noindent
            Finally, because $rs_2$ is a subset of $NET.Get$($\iota_0$,
            $\iota_2$), the algorithm replaces the arc between $\iota_0$ and
            $\iota_2$ with $rs_2$, as shown in Figure \ref{figu-tempo-ntwk6}.

            \begin{figure}[tbhp]
              \begin{center}
                \includegraphics{net-06}
                \caption{Network after $NET.AddRel$($\iota_1$, $\iota_2$, \{$STA$, $FIN$\})}
                \label{figu-tempo-ntwk6}
              \end{center}
            \end{figure}
          \end{vexample}

    \section{Extensions to Allen's Interval Algebra}
      \label{sect-tempo-exten}

      In an authorisation system, an agent that enforces an authorisation
      policy must be able to match the policy's entities to objects observable
      by the agent, e.g. a subject in the policy is mapped to a user that logs
      in, or an object in the policy is mapped to a certain file in the
      filesystem. Similarly, an agent must also be able to map time intervals
      in a policy to events that are observable by the agent. For example,
      the interval {\em logged\_on} in the policy may be mapped to the time
      between a certain user logs in and out of the system.

      In certain situations, however, it is convenient to map intervals in the
      policy to a particular time scale, such as the agent's real time clock.
      These situations might arise when certain authorisations need to be
      granted or revoked at a certain time, instead of being triggered by
      observable events. To map policy intervals to real time, it is necessary
      to define them in terms of points in real time.

      In the previous section, we have shown that Allen's algebra defines
      temporal intervals as the primitive, where each interval is defined not
      by time points, but by their relationships with other intervals. In this
      section, we will attempt to show the extensions to the interval algebra
      to allow it to express intervals in terms of time points.

      \subsection{Time Points Revisited}
        \label{subs-tempo-tprev}

        By allowing time point definitions to be expressed in the algebra, we
        must formally define time points.

        Disregarding the physical effects of gravitation and velocity on time,
        we make the assumption that time is linear, absolute and universal.
        That is, time always flows in one direction: from past to future; that
        the passage of time as seen by one system is the same for any other
        system; and that all systems define time against a universal frame of
        reference. For simplicity, we further assume that time is not a
        continuous line, but is instead made up of discrete time points.

        As this definition goes against the more intuitive notion of continuous
        time lines, one might see the problem of events "falling through" the
        gaps between the discrete time points in the non-continuous time line.

        To go around this problem, we allow the time point granularity to be
        chosen arbitrarily. Ideally, for a specific application, one would
        choose a granularity that is at least as small as the smallest interval
        in that application. In practice, however, such choices are limited by
        implementing system's clock and other hardware and software latencies.

        In the light bulb and sunrise example in the previous section, if we
        choose a granularity of 1 second, then the switching on of a light bulb
        is an event that occurs at a specific time point. A granularity of 1
        second, however, means that a sunrise is not an event but an interval,
        given the fact that in most parts of the world, the sun takes a few
        minutes to rise above the horizon. However, if we choose a granularity
        of 1 hour (and we do not live in the polar regions), a sunrise becomes
        an event that occurs at a single point in our chosen time scale. We can
        therefore argue that given a specific time granularity, some events can
        be treated as instantaneously occurring at a specific time point.

        Regardless of the granularity chosen, the domain of time points is the
        set of positive integers ${\mathbb Z}^{+}$.

      \subsection{Defining Intervals in Terms of Time Points}
        \label{subs-tempo-inttp}

        \begin{vdefinition}
          \label{defn-tempo-intvl}
          A {\bf well-defined interval} $\iota$ is an interval whose end points
          $\iota^{-}$ $\in$ ${\mathbb Z}^{+}$ and $\iota^{+}$ $\in$
          ${\mathbb Z}^{+}$ are defined, where $\iota^{-}$ $<$ $\iota^{+}$. A
          {\bf regular interval} is an interval whose end points are not known.
        \end{vdefinition}

        Under this definition, we can conclude that for any two well-defined
        intervals there is exactly one interval relation that holds between
        them. Algorithm \ref{algo-tempo-compu} shows a function that calculates
        this relation given the end points of two well-defined intervals.

        By using the $Compute$() function in Algorithm \ref{algo-tempo-compu},
        we can now define a network operator, $NET.Bind$($\iota$, $\iota^-$,
        $\iota^+$), that assigns the end points $\iota^-$ and $\iota^+$ to the
        existing interval $\iota$ in the network. By allowing such end points
        to be defined for any interval, thereby making them well-defined
        intervals, we are also allowing the possibility of introducing new
        relations with this interval. Furthermore, any new relations gathered
        by comparing the end points of well-defined intervals are subject to
        the same propagation algorithms shown in the previous section.
        Algorithm \ref{algo-tempo-ntbin} shows how the $NET.Bind$() operator
        achieves this.

        \begin{valgorithm}{Compute()}{algo-tempo-compu}
FUNCTION \(Compute\)(\(\iota\sb{0}\sp{-}\), \(\iota\sb{0}\sp{+}\), \(\iota\sb{1}\sp{-}\), \(\iota\sb{1}\sp{+}\))
  IF \(\iota\sb{0}\sp{-}\) == \(\iota\sb{1}\sp{-}\) THEN
    IF \(\iota\sb{0}\sp{+}\) == \(\iota\sb{1}\sp{+}\) THEN
      RETURN \{\(equals\}\)
    ELSE IF \(\iota\sb{0}\sp{+}\) < \(\iota\sb{1}\sp{+}\) THEN
      RETURN \{\(starts\}\)
    ELSE
      RETURN \{\(started by\}\)
    ENDIF
  ELSE IF \(\iota\sb{0}\sp{-}\) < \(\iota\sb{1}\sp{-}\) THEN
    IF \(\iota\sb{0}\sp{+}\) == \(\iota\sb{1}\sp{+}\) THEN
      RETURN \{\(finished by\}\)
    ELSE IF \(\iota\sb{0}\sp{+}\) < \(\iota\sb{1}\sp{+}\) THEN
      IF \(\iota\sb{0}\sp{+}\) == \(\iota\sb{1}\sp{-}\) THEN
        RETURN \{\(meets\}\)
      ELSE IF \(\iota\sb{0}\sp{+}\) < \(\iota\sb{1}\sp{-}\) THEN
        RETURN \{\(before\}\)
      ELSE
        RETURN \{\(overlaps\}\)
      ENDIF
    ELSE
      RETURN \{\(contains\}\)
    ENDIF
  ELSE
    IF \(\iota\sb{0}\sp{+}\) == \(\iota\sb{1}\sp{+}\) THEN
      RETURN \{\(finishes\}\)
    ELSE IF \(\iota\sb{0}\sp{+}\) < \(\iota\sb{1}\sp{+}\) THEN
      RETURN \{\(during\}\)
    ELSE
      IF \(\iota\sb{0}\sp{-}\) == \(\iota\sb{1}\sp{+}\) THEN
        RETURN \{\(met by\}\)
      ELSE IF \(\iota\sb{0}\sp{-}\) < \(\iota\sb{1}\sp{+}\) THEN
        RETURN \{\(overlapped by\}\)
      ELSE
        RETURN \{\(after\}\)
      ENDIF
    ENDIF
  ENDIF
ENDFUNCTION
        \end{valgorithm}

        \begin{valgorithm}{Net.Bind()}{algo-tempo-ntbin}
FUNCTION \(NET.Bind\)(\(\iota\), \(\iota\sp{-}\), \(\iota\sp{+}\))
  FOR each interval \(\iota'\) \(\in\) \(NET\) DO
    IF \(\iota'\) != \(\iota\) THEN
      IF \(\iota'\) is well-defined THEN
        \(rs\) = \(Compute\)(\(\iota\sp{-}\), \(\iota\sp{+}\), \(\iota'\sp{-}\), \(\iota'\sp{+}\))
        \(NET.AddRel\)(\(\iota\), \(\iota'\), \(rs\))
      ENDIF
    ENDIF
  ENDDO
ENDFUNCTION
        \end{valgorithm}

    \section{Formalisation}
       \label{sect-tempo-fmstn}

      In this section, we attempt to formalise a new language, ${\cal L^T}$,
      with the same expressive power as language ${\cal L}$ to represent
      authorisation policies, but with extensions to also express temporal
      constraints. Like language ${\cal L}$, language ${\cal L^T}$ is also a
      first-order logic language. As such, any language ${\cal L^T}$ policy
      can be translated into a normal logic program to derive answer sets,
      from which queries can be evaluated. Section \ref{sect-langs-bnflt}
      contains the full BNF specification of language ${\cal L^T}$.

      \subsection{Syntax}
        \label{subs-tempo-syntx}

        \subsubsection{Components of Language ${\cal L^T}$}

          \begin{itemize}

            \item
              {\bf Identifiers}

                In language ${\cal L^T}$, there are 4 general types of
                identifiers:

                \begin{enumerate}
                  \item
                    {\em Entity Identifiers.}
                    As with language ${\cal L}$, language ${\cal L^T}$
                    includes six disjoint entity sorts: subject, access
                    rights, objects, subject groups, access right groups and
                    object groups. The syntax for each entity type is a single
                    lower case alpha character followed by zero or more
                    alphanumeric or underscore characters:

                    \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
                    \end{vverbatim}

                  \item
                    {\em Interval Identifiers.}
                    The main difference between language ${\cal L}$ and
                    language ${\cal L^T}$ is that in addition to the six
                    entity sorts, language ${\cal L^T}$ also includes an
                    additional time interval sort. As it occupies a different
                    name space from the other sorts, interval identifiers share
                    the same syntax.

                  \item
                    {\em Policy Update Identifiers.}
                    These identifiers are used as labels to name policy
                    updates. They occupy a different name space from other
                    identifiers and hence share the same syntax as entity and
                    interval identifiers.

                  \item
                    {\em Variable Identifiers.}
                    In language ${\cal L}$, variable identifiers are used to
                    represent entity identifiers. In contrast, language
                    ${\cal L^T}$ variable identifiers are used to represent
                    both entity and interval identifiers. The list below shows
                    the syntax of the different types of variable identifiers:

                    \begin{enumerate}
                      \item
                        Subject Variables

                        \begin{vverbatim}
  S[SG][a-zA-Z0-9\_]
                        \end{vverbatim}

                      \item
                        Access Right Variables

                        \begin{vverbatim}
  A[SG][a-zA-Z0-9\_]
                        \end{vverbatim}

                      \item
                        Object Variables

                        \begin{vverbatim}
  O[SG][a-zA-Z0-9\_]
                        \end{vverbatim}

                      \item
                        Interval Variables

                        \begin{vverbatim}
  I[a-zA-Z0-9\_]
                        \end{vverbatim}

                    \end{enumerate}
                \end{enumerate}

            \item
              {\bf Authorisation Atoms, Facts and Expressions}

              Authorisation atoms of language ${\cal L^T}$ are similar to the
              to the atoms of language ${\cal L}$, except each atom includes
              an interval parameter that indicates the time at which that atom
              holds. As with language ${\cal L}$, there are three types of
              atoms:

              \begin{enumerate}
                \item
                  {\em Holds Atom.} The syntax below shows an atom that states
                  that subject $sub$-$id$ holds the access right $acc$-$id$ for
                  object $obj$-$id$ at time interval $int$-$id$.

                  \begin{vverbatim}
  holds(<sub-id>,
        <acc-id>,
        <obj-id>,
        <int-id>)
                  \end{vverbatim}

                \item
                  {\em Member Atom.} The syntax shown below is that of an atom
                  that states that the single entity $single$-$id$ is a member
                  of the group entity $group$-$id$ for the duration specified
                  by interval $int$-$id$.

                  \begin{vverbatim}
  memb(<single-id>, <group-id>, <int-id>)
                  \end{vverbatim}

                \item
                  {\em Subset Atom.} Below is the syntax of an atom that states
                  that the group entity $group$-$id$-$0$ is a subset of the
                  group entity $group$-$id-$-$1$ at time interval $int$-$id$.

                  \begin{vverbatim}
  subst(<group-id-0>, <group-id-1>, <int-id>)
                  \end{vverbatim}
              \end{enumerate}

              Like language ${\cal L}$, language ${\cal L^T}$ facts state
              that relationship represented by the corresponding atom its
              negation (as indicated by the "!" character prefix) holds.

              An expression is either a fact or a conjunction of facts
              separated by the comma "," character. An atom, fact or expression
              composed entirely of entity and interval identifiers (no
              variables) are called ground atoms, facts or expressions,
              respectively.

            \item
              {\bf Interval Atoms and Expressions}

              Noting the fact that the inverse relation between any intervals
              $i_0$ and $i_1$ is equal to the relation between intervals
              $i_1$ and $i_0$, for the sake of brevity, language ${\cal L^T}$
              defines only 7 out of the 13 interval relations in the algebra.
              These relations, together with two interval identifiers make up
              the language's interval atoms:

              \begin{vverbatim}
  <rel-id>(<int-id-0>, <int-id-1>)
              \end{vverbatim}

              where $rel$-$id$ indicates the relation between interval
              $int$-$id$-$0$ and interval $int$-$id$-$1$, and is one of the
              following: $equals$, $before$, $during$, $overlaps$, $meets$,
              $starts$ or $finishes$.

              An interval expression in language ${\cal L^T}$ is a group
              of interval atoms separated by the comma "," character. As the
              interval algebra allows disjunctions, the meaning of the comma
              within an interval expression may be conjunctive or disjunctive.
              If an interval expression contains two atoms that differ only by
              their relation (meaning the interval pairs are the same), then
              the comma between these atoms indicates a logical {\em or}.
              Commas between other interval atoms indicate a logical {\em and}.
              For example, the following interval expression is interpreted as
              "interval $i_0$ is before or after interval $i_1$ and interval
              $i_2$ is during interval $i_0$":

              \begin{vverbatim}
  before(i0, i1), before(i1, i0), during(i2, i0)
              \end{vverbatim}

              Like their authorisation counterparts, interval atoms and
              expressions that do not have variable identifiers are called
              ground interval atoms and expressions.

          \end{itemize}

        \subsubsection{Identifier Declarations}

          In language ${\cal L^T}$, both entity and interval identifiers must
          be declared before they are used anywhere in the program. The syntax
          for declaring entity identifiers in language ${\cal L^T}$ is the same
          as the syntax in language ${\cal L}$:

          \begin{vverbatim}
  entity sub|acc|obj[-grp] <ent-id>[, ...];
          \end{vverbatim}

          Interval identifiers may be declared with or without end points. Note
          that once intervals are assigned end points, they are bound to those
          end points for the lifetime of the program. End points, if declared
          with an interval identifier, must be a positive integer as indicated
          in the following syntax:

          \begin{vverbatim}
  interval <int-id> [\(\backslash\)[ep0, ep1\(\backslash\)]][, ... ];
          \end{vverbatim}

          \noindent
          where $ep_0$ $\in$ ${\mathbb Z}^+$, $ep_1$ $\in$ ${\mathbb Z}^+$ and
          $ep_0$ $<$ $ep_1$.

        \subsubsection{Initial Fact Declarations}

          Like language ${\cal L}$, language ${\cal L^T}$ allows the
          declaration of initial state facts. Ground facts declared in this
          manner hold until a policy update causes them to be otherwise. Syntax
          is as follows:

          \begin{vverbatim}
  initially <gnd-auth-exp>;
          \end{vverbatim}

        \subsubsection{Interval Constraint Declarations}

          Relations between intervals are expressed in language ${\cal L^T}$
          through interval constraints. Interval relations defined by interval
          constraints hold for the entire lifetime of the program. Such
          relations in the form of a ground interval expression may be declared
          in the following manner:

          \begin{vverbatim}
  relation <gnd-int-exp>;
          \end{vverbatim}

          The example below declares an interval constraint that states that
          interval $i_0$ is $before$ or $starts$ interval $i_1$, interval $i_1$
          is $during$ or $meets$ interval $i_2$, and interval $i_2$ $meets$
          interval $i_3$:

          \begin{vverbatim}
  relation
    before(i0, i1),
    starts(i0, i1),
    during(i1, i2),
    meets(i1, i2),
    meets(i2, i3);
          \end{vverbatim}

        \subsubsection{Authorisation Constraint Declarations}

          Like the constraint declarations in language ${\cal L}$,
          authorisation constraint declarations in language ${\cal L^T}$ are
          used to define logical rules that always holds, even after a policy
          update is applied. The difference, as shown by the syntax below, is
          the addition of the {\em where} clause.

          \begin{vverbatim}
  always <auth-exp-0>
    [implied by <auth-exp-1>]
    [with absence <auth-exp-2>]
    [where <int-exp>];
          \end{vverbatim}

          The meaning of the statement is essentially the same as its language
          ${\cal L}$ counterpart: expression $auth$-$exp$-$0$ holds if
          expression $auth$-$exp$-$1$ holds and there is no evidence that
          expression $auth$-$exp$-$2$ holds. Any variables occurring in
          any of these expressions are grounded to all defined entities and
          interval identifiers.

          The {\em where} clause is used to define an interval expression
          $int$-$exp$ which is used to place a restriction on the interval
          identifiers used to ground interval variables occurring in the
          authorisation expressions. Only those sets of interval identifiers
          that satisfy the expression $int$-$exp$ is used to replace the
          set of interval variables in the authorisation expressions. As the
          {\em where} clause is used in the grounding of variables, it is
          important to note that it does not make sense to have a ground
          interval expression in the {\em where} clause. Furthermore, not only
          does the expression $int$-$exp$ need to be non-ground, but every atom
          in this expression must also be non-ground.

          For example, given the following authorisation constraint
          declaration:

          \begin{vverbatim}
  always holds(SS, a, o, I0)
    implied by memb(SS, SG0, I1)
    with absence !memb(SS, SG1, I1)
    where starts(I0, I1);
          \end{vverbatim}

          \noindent
          Assuming that \{$ss_0$, $ss_1$\} is the set of single subjects,
          \{$sg_0$, $sg_1$\} is the set of group subjects and \{$i_0$, $i_1$,
          $i_2$\} is the set of intervals defined, with interval $i_0$ $during$
          interval $i_1$ and interval $i_1$ $start$ing interval $i_2$, the
          statement is equivalent to the following statements:

          \begin{vverbatim}
  always holds(ss0, a, o, i1)
    implied by memb(ss0, sg0, i2)
    with absence !memb(ss0, sg1, i2);

  always holds(ss1, a, o, i1)
    implied by memb(ss1, sg0, i2)
    with absence !memb(ss1, sg1, i2);

  always holds(ss0, a, o, i1)
    implied by memb(ss0, sg1, i2)
    with absence !memb(ss0, sg0, i2);

  always holds(ss1, a, o, i1)
    implied by memb(ss1, sg1, i2)
    with absence !memb(ss1, sg0, i2);
          \end{vverbatim}

          Although the entity variables $SS$, $SG_0$ and $SG_1$ are grounded
          to every entity that matches their respective types, the interval
          variables $I_0$ and $I_1$ are restricted to the intervals $i_1$ and
          $i_2$, respectively, because they are the only interval pair that
          satisfies the restriction placed by the {\em where} clause.

        \subsubsection{Policy Update Declarations}

          Like the authorisation constraint definition, policy update
          definitions of language ${\cal L^T}$ are similar to those of language
          ${\cal L}$, but with the extra {\em where} clause to limit the
          interval identifiers that are used to ground interval variables that
          may occur in authorisation expressions.

          The syntax below describes the declaration of a policy update
          $update$-$id$ which, when applied, causes the expression
          $auth$-$exp$-$0$ to hold if the expression $auth$-$exp$-$1$ already
          holds.

          \begin{vverbatim}
  <update-id>([<ent-var-0>[, ...]])
    causes <auth-exp-0>
    [if <auth-exp-1>]
    [where <int-exp>];
          \end{vverbatim}

          When a policy update is applied, entity identifiers are supplied for
          each entity variable $ent$-$var$-$i$. These entity identifiers are
          used to ground any matching entity variables that may occur in either
          authorisation expressions $auth$-$exp$-$0$ or $auth$-$exp$-$1$.
          Entity variables occurring in these expressions that do not match
          the variables in the variable list $ent$-$var$-$n$ are replaced by
          all defined entity identifiers that match the variable types.
          Interval variables occurring in the authorisation expressions are
          grounded to sets of interval identifiers that satisfy the interval
          expression $int$-$exp$.

        \subsubsection{Policy Update Directives}

          The policy update directives in language ${\cal L^T}$, like those
          in language ${\cal L}$, are used to manipulate the policy update
          sequence list.

          The three directives below are for adding a policy update into the
          update sequence list, removing an update from the update sequence
          list, and showing the contents of the update sequence list,
          respectively.

          \begin{vverbatim}
  seq add <upd-id>([<id-0>[, ...]]);
  seq del <n>;
  seq list;
          \end{vverbatim}

          The directive is used to apply policy updates one at a time in the
          order in which they appear in the update sequence list.

          \begin{vverbatim}
  compute;
          \end{vverbatim}

        \subsubsection{Query Directives}

          A ground query expression may be given to the system for evaluation.
          The syntax is as follows:

          \begin{vverbatim}
  query <gnd-auth-exp>;
          \end{vverbatim}

          Queries are evaluated against the policy base state derived from the
          application of policy updates in the update sequence list. The system
          response for each query directive either {\em true}, {\em false} or
          {\em unknown}.

        \begin{vexample}
          \label{exam-tempo-syntx}
          The example code below shows a full language ${\cal L^T}$ policy
          description. In this policy, three intervals are defined:
          $work\_hours$, $morning\_hours$ and $afternoon\_hours$, where
          $worh\_hours$ starts at 9:00 AM and ends at 5:00 PM. Furthermore,
          the interval constraint in the policy states that $morning\_hours$
          either {\em starts} or is {\em during} $work\_hours$,
          $afternoon\_hours$ either {\em finishes} or is {\em during}
          $work\_hours$, and $morning\_hours$ is {\em before}
          $afternoon\_hours$.

          The authorisation constraint states that for all defined intervals
          $I0$, if $grp1$ holds the $read$ access right to $file$ at interval
          $I0$, and there is no evidence that $grp3$ does not hold the $write$
          access right to $file$ at interval $I0$, then $grp1$ holds the
          $write$ access right to $file$ at interval $I0$.

          The policy update $delete\_read$ definition states that when applied,
          the update will cause some subject group $SG0$ to lose the $read$
          access right to some object $OS0$ at all intervals $I0$ that either
          {\em starts} or is {\em during} the interval $work\_hours$.

          \begin{vverbatim}
  /* entity declarations */

  entity sub alice;
  entity sub-grp grp1, grp2, grp3;
  entity acc read, write;
  entity obj file;

  /* interval declarations */

  interval work\_hours [0900, 1700];
  interval morning\_hours;
  interval afternoon\_hours;

  /* initial fact statement */

  initially
    memb(alice, grp2, work\_hours),
    subst(grp2, grp1, morning\_hours),
    holds(grp1, read, file, work\_hours);

  /* interval constraints */

  relation
    during(morning\_hours, work\_hours),
    starts(morning\_hours, work\_hours);

  relation
    during(afternoon\_hours, work\_hours),
    finishes(afternoon\_hours, work\_hours);

  relation
    before(morning\_hours, afternoon\_hours);

  /* authorisation constraint */

  always holds(grp1, write, file, I0)
    implied by
      holds(grp1, read, file, I0)
    with absence
      !holds(grp3, write, file, I0);

  /* policy update declaration */

  delete\_read(SG0, OS0)
    causes
      !holds(SG0, read, OS0, I0)
    where
      starts(work\_hours, I0),
      during(work\_hours, I0);

  /* add delete\_read to policy update sequence list */

  seq add delete\_read(grp1, file);

  compute;

  /* queries */

  query holds(grp1, write, file, morning\_hours);
  query holds(grp1, read, file, morning\_hours);
  query holds(alice, write, file, morning\_hours);
  query holds(alice, read, file, morning\_hours);
          \end{vverbatim}
        \end{vexample}

      \subsection{Semantics}
        \label{subs-tempo-seman}

        The domain description ${\cal D_{L^T}}$ of language ${\cal L^T}$ is
        a finite set of intervals with end points, initial state facts,
        temporal constraint rules, authorisation constraint rules, policy
        update definitions and an ordered set $\psi$ of policy update
        references.

        Like language ${\cal L}$, the semantics of language ${\cal L^T}$ is
        best described by its translation into an extended logic program,
        language ${\cal L^{T^*}}$. Formally, given a domain description
        ${\cal D_{L^T}}$ of language ${\cal L^T}$, the translation is denoted
        by $Trans$(${\cal D_{L^T}}$).

        The main difference between language ${\cal L^T}$ and language
        ${\cal L^{T^*}}$ is that each atom of the latter also specifies the
        policy update state in which it holds. Another difference between the
        two languages is that the temporal constraints of language ${\cal L^T}$
        is not directly expressed in language ${\cal L^{T^*}}$. Instead, the
        interval algebra discussed at the beginning of this chapter is used by
        the translation process to generate the appropriate authorisation rules
        with respect to the given temporal constraints.

        Before the translation process can be shown, we must first provide
        a formal definition of language ${\cal L^{T^*}}$.

        \subsubsection{Language ${\cal L^{T^*}}$}

          As hinted above, language ${\cal L^{T^*}}$ is an extended logic
          program which is composed of facts and rules that expresses an
          authorisation policy. The following are the components of the
          language:

          \begin{itemize}
            \item
              {\bf Entities}

              Like language ${\cal L^*}$, language ${\cal L^{T^*}}$ defines
              a set ${\cal E}$ that contains all the defined subject, access
              right and object (both singles and groups) entities. In addition
              to this set, we also define all its subsets: single subject
              ${\cal E}_{ss}$, single access right ${\cal E}_{as}$, single
              object ${\cal E}_{os}$, group subject ${\cal E}_{sg}$, group
              access right ${\cal E}_{ag}$, group object ${\cal E}_{og}$,
              single and group subjects ${\cal E}_{s}$, single and group access
              rights ${\cal E}_{a}$, and single and group objects
              ${\cal E}_{o}$.

            \item
              {\bf Intervals}

              Language ${\cal L^{T^*}}$ defines a set ${\cal I}$ that contains
              all the defined time intervals from ${\cal D_{L^T}}$.

            \item
              {\bf Atoms}

              A language ${\cal L^{T^*}}$ atom is a binding of a set of
              entities, a temporal interval and a state. The set
              ${\cal A}^\sigma$ contains all the atoms of state $\sigma$.
              The sets ${\cal A}^{\sigma}_{h}$, ${\cal A}^{\sigma}_{m}$ and
              ${\cal A}^{\sigma}_{h}$ denotes all $holds$, $member$ and
              $subset$ atoms of state $\sigma$, respectively, where
              ${\cal A}^\sigma$ = ${\cal A}^{\sigma}_{h}$ $\cup$
              ${\cal A}^{\sigma}_{m}$ $\cup$ ${\cal A}^{\sigma}_{s}$. The
              definitions of these subsets are shown below. To distinguish
              between the atoms of the two languages, atoms of language
              ${\cal L^{T^*}}$ are written with the hat character.

              \begin{vquote}
                ${\cal A}^{\sigma}_{h}$ =
                  $\{\hat{holds}$($s$, $a$, $o$, $\iota$, $\sigma$) $\mid$
                  $s$ $\in$ ${\cal E}_{s}$,
                  $a$ $\in$ ${\cal E}_{a}$,
                  $o$ $\in$ ${\cal E}_{o}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{m}$ =
                  ${\cal A}^{\sigma}_{ms}$ $\cup$
                  ${\cal A}^{\sigma}_{ma}$ $\cup$
                  ${\cal A}^{\sigma}_{mo}$

                ${\cal A}^{\sigma}_{s}$ =
                  ${\cal A}^{\sigma}_{ss}$ $\cup$
                  ${\cal A}^{\sigma}_{sa}$ $\cup$
                  ${\cal A}^{\sigma}_{so}$

                ${\cal A}^{\sigma}_{ms}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{ss}$,
                  $g$ $\in$ ${\cal E}_{sg}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{ma}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{as}$,
                  $g$ $\in$ ${\cal E}_{ag}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{mo}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{os}$,
                  $g$ $\in$ ${\cal E}_{og}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{ss}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{sg}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{sa}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{ag}$,
                  $\iota$ $\in$ ${\cal I}\}$

                ${\cal A}^{\sigma}_{so}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{og}$,
                  $\iota$ $\in$ ${\cal I}\}$
              \end{vquote}

            \item
              {\bf Facts}

              The definition below states that a fact $\hat{\rho}^\sigma$ is a
              logical statement that asserts that an atom $\hat{\alpha}$ either
              holds or does not hold at a given state $\sigma$.

              \begin{vquote}
                $\hat{\rho}^{\sigma}$ =
                  $[\lnot]$$\hat{\alpha}$

                where
                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$
              \end{vquote}

            \item
              {\bf Expressions}

              A language ${\cal L^{T^*}}$ expression is a conjunction of
              facts separated by the comma character. The expression below
              asserts that where $0$ $\leq$ $i$ $\leq$ $n$, each fact
              $\hat{\rho}_i$ holds:

              \begin{vquote}
                $\hat{\rho}_0$,
                $\hat{\rho}_1$,
                $\ldots$,
                $\hat{\rho}_n$,
              \end{vquote}

          \end{itemize}

        \subsubsection{Translating Language ${\cal L^T}$ to Language ${\cal L^{T^*}}$}

          Unlike the translation of language ${\cal L}$ to language
          ${\cal L^*}$, not all statements of language ${\cal L^T}$ is
          translated to language ${\cal L^{T^*}}$. In particular, as language
          ${\cal L^{T^*}}$ does not express relationships between temporal
          intervals, all language ${\cal L^T}$ statements that denote these
          relationships are not directly translated. Through the use of Allen's
          interval algebra, the authorisation rules that result from the
          consequences of these temporal relations are generated instead.

          To describe the details of the translation $Trans$(${\cal D_{L^T}}$),
          we first define some translation functions similar to those defined
          in Section \ref{subs-langl-langl} and Section \ref{subs-langl-trans}.

          \begin{itemize}

            \item
              The $Res$($u$, $\sigma$) function takes as input a policy update
              $u$ $\in$ $\psi$ and a policy state $\sigma$, and returns the
              policy state that results from applying the update $u$ upon
              state $\sigma$.

            \item
              The $CopyAtom$($\hat{\alpha}$, $\sigma$) function takes as input
              an atom $\hat{\alpha}$ of language ${\cal L^{T^*}}$ and some
              state $\sigma$, then returns an atom with the same type and with
              the same entities and interval as atom $\hat{\alpha}$, but with
              state $\sigma$ instead of the original state specified by
              $\hat{\alpha}$.

            \item
              The $TransAtom$($\alpha$, $\sigma$) function takes as input an
              atom $\alpha$ of language ${\cal L^T}$ and some state $\sigma$,
              then returns an equivalent atom of language ${\cal L^{T^*}}$
              with the same entities and interval specified by $\alpha$.

            \item
              The $TransFact$($\rho$, $\sigma$) function is similar to the
              $TransAtom$ function, but instead of translating an atom, it
              takes a language ${\cal L^T}$ fact $\rho$ and some state $\sigma$
              then returns the equivalent language ${\cal L}^{T^*}$ fact.
          \end{itemize}

          With these functions defined, we can now outline the translation
          process:

          \paragraph
            {\bf Initialising the Temporal Interval Relation Network.}

            The first step in the process is to initialise the interval
            relation network with all the temporal intervals and all the
            given end points defined in language ${\cal L^T}$. Recall that
            there are two ways a temporal interval may be declared in
            language ${\cal L^T}$:

            \begin{vverbatim}
  interval \(\iota\);
  interval \(\iota\) [\(ep\sb{0}\), \(ep\sb{1}\)];
            \end{vverbatim}

            \noindent
            For both forms, the interval $\iota$ is added to the interval
            network. However, the second form requires an additional step
            to register the end points:

            \begin{vquote}
              $NET.Bind$($\iota$, $ep_0$, $ep_1$)
            \end{vquote}

          \paragraph
            {\bf Populating the Temporal Interval Relation Network.}

            The next step is to encode all temporal constraints in
            language ${\cal L^T}$ as interval relations in the interval
            relation network. Temporal constraints are declared in language
            ${\cal L^T}$ in the following way:

            \begin{vverbatim}
  relation \(\alpha\sb{0}\), \(\ldots\), \(\alpha\sb{n}\);
            \end{vverbatim}

            Note that each interval atom ${\alpha}_i$ above is in the form
            $r_i$(${\iota}0_i$, ${\iota}1_i$), where $r_i$ $\in$ \{$equals$,
            $before$, $\ldots$\}, ${\iota}0_i$, ${\iota}1_i$ $\in$
            ${\cal I}$ and $0$ $\leq$ $i$ $\leq$ $n$. We further note that
            under this notation, it is possible to encounter a situation
            where two different interval atoms ${\alpha}_i$ and ${\alpha}_j$
            can both contain the same pair of intervals:

            \begin{vquote}
              ${\alpha}_i$ $=$ $r_i$(${\iota}0_i$, ${\iota}1_i$)

              ${\alpha}_j$ $=$ $r_j$(${\iota}0_j$, ${\iota}1_j$)

              where

              \hspace{1em}
              $i$ $\neq$ $j$,

              \hspace{1em}
              $r_i$ $\neq$ $r_j$,

              \hspace{1em}
              ${\iota}0_i$ $=$ ${\iota}0_j$,

              \hspace{1em}
              ${\iota}1_i$ $=$ ${\iota}1_j$
            \end{vquote}

            According to the syntax definition of interval atoms in the
            previous section, in any given interval expression, all interval
            atom pairs that satisfies the above condition are to be treated
            as disjunctions in that expression, while those that do not are
            to be treated as conjunctions.

            For simplicity, we introduce a normalised notation for interval
            expressions where each interval atom in the expression contains a
            unique pair of intervals and a set of relations that hold between
            those intervals. Formally, a normalised interval expression is
            in the following form:

            \begin{vquote}
              ${\alpha}_0$, $\ldots$, ${\alpha}_n$
            \end{vquote}

            \noindent
            where each interval atom ${\alpha}_i$ ($0$ $\leq$ $i$ $\leq$ $n$)
            in the form:

            \begin{vquote}
              ${\alpha}_i$ =
                (${\iota}0_i$, ${\iota}1_i$, \{$r0_i$, $\ldots$, $rx_i$\})
            \end{vquote}

            \noindent
            satisfies the following condition:

            \begin{vquote}
              $\lnot$$\exists$${\alpha}_j$,

              where

              \hspace{1em}
              ${\alpha}_j$ =
                (${\iota}0_j$, ${\iota}1_j$, \{$r0_j$, $\ldots$, $ry_j$\})

              \hspace{1em}
              $0$ $\leq$ $j$ $\leq$ $n$,

              \hspace{1em}
              $i$ $\neq$ $j$

              such that

              \hspace{1em}
              ${\iota}0_i$ $=$ ${\iota}0_j$,

              \hspace{1em}
              ${\iota}1_i$ $=$ ${\iota}1_j$
            \end{vquote}

            Now, we define a function $NormaliseExp$($\epsilon$) that takes
            a language ${\cal L^T}$ interval expression $\epsilon$ as
            input and returns the normalised equivalent of that expression in
            the form shown above. Formally, we have:

            \begin{vquote}
              ${\epsilon}'$ $=$ $NormaliseExp$($\epsilon$)
            \end{vquote}

            \noindent
            For each
            (${\iota}0_i$, ${\iota}1_i$, \{$r0_i$, $\ldots$, $rx_i$\})
            $\in$ ${\epsilon}'$,
            where $0$ $\leq$ $i$ $<$ $|{\epsilon}'|$, the following
            conditions are satisfied:

            \begin{enumerate}
              \item
                For each $r_j$ $\in$ \{$r0_i$, $\ldots$, $rx_i$\}, where $0$
                $\leq$ $j$ $\leq$ $i$, there exists an
                $r_j$(${\iota}0_i$, ${\iota}1_i$) $\in$ $\epsilon$

              \item
                For each
                (${\iota}0_j$, ${\iota}1_j$, \{$r0_j$, $\ldots$, $ry_j$\})
                $\in$ ${\epsilon}'$, where $0$ $\leq$ $j$ $<$
                $|{\epsilon}'|$ and $i$ $\neq$ $j$,
                (
                  ${\iota}0_i$ $\neq$ ${\iota}0_j$ $\lor$
                  ${\iota}1_i$ $\neq$ ${\iota}1_j$
                )
            \end{enumerate}

            With the $NormaliseExp$() function defined, we can now populate the
            interval relation network with relations expressed in language
            ${\cal L^T}$ interval constraint statements. The steps involved
            to achieve this is as follows. For each interval constraint
            statement in language ${\cal L^T}$:

            \begin{vverbatim}
  relation \(\alpha\sb{0}\), \(\ldots\), \(\alpha\sb{n}\);
            \end{vverbatim}

            \noindent
            By using the $NormaliseExp$() function, we obtain the normalised
            expression $\epsilon$:

            \begin{vquote}
              $\epsilon$ $=$
                $NormaliseExp$(\{${\alpha}_0$, $\ldots$, ${\alpha}_n$\})
            \end{vquote}

            \noindent
            Finally, to register the interval constraint to the interval
            relation network, we make a call to the following operator
            for each (${\iota}0_i$, ${\iota}1_i$, $rs_i$) $\in$
            $\epsilon$, where $0$ $\leq$ $i$ $<$ $|\epsilon|$:

            \begin{vverbatim}
  \(NET.AddRel\)(\({\iota}0\sb{i}\), \({\iota}1\sb{i}\), \(rs\sb{i}\))
            \end{vverbatim}

          \paragraph
            {\bf Variable Grounding.}

            As language ${\cal L^{T^*}}$ does not allow variables, all
	    language ${\cal L^T}$ expressions containing entity or interval
            variables must be grounded in the translation process. Although
            the task of grounding entity variables is a relatively
            straightforward procedure, grounding interval variables involves
            additional steps due to the {\em where} clause of the language.
            After generating the tuples to replace the variables, each of
            these tuples must also be checked to ensure that they satisfy
            any given temporal constraints.

            Before we can describe the grounding process in greater detail,
            we first define the following three functions:

            \begin{itemize}
              \item
                $Type$($ev$)

                The $Type$($ev$) function returns the type of the given
                entity or variable $ev$: $interval$, $single$-$subject$,
                $group$-$subject$, $single$-$access$-$right$, etc.

              \item
                $Var$($\epsilon$)

                Given a non-ground language ${\cal L^T}$ authorisation or
                interval expression $\epsilon$, this function returns
                a set of unique variables that occurs in $\epsilon$. If
                $\epsilon$ is ground, the function returns $\emptyset$.

              \item
                $Replace$($\epsilon$, $V$, $t$)

                The function takes the following as input: a non-ground
                language ${\cal L^T}$ authorisation or interval expression
                $\epsilon$, a set of variables $V$ that occur in
                $\epsilon$, and a tuple $t$ containing entities and
                intervals that correspond to the variables in $V$ ($|V|$ $=$
                $|t|$ and $\forall$$i$, $0$ $\leq$ $i$ $<$ $|V|$,
                $Type$($V_i$) $=$ $Type$($t_i$)). The function returns
                $\epsilon$ with all variable occurences replaced with the
                corresponding entities or intervals from $t$. If
                $\epsilon$ is a ground expression, $\epsilon$ is
                returned.
            \end{itemize}

            With these functions defined, we can now generalise the process
            of grounding both entity and interval variables. Given a set $V$
            of unique entity and interval variables, the function below
            returns a set of all possible $|V|$-tuples that can be used to
            replace the variables in $V$:

            \begin{vquote}
              $GenTuples_1$($V$) $=$
              $R_0$ $\times$ $\ldots$ $\times$ $R_{|V|-1}$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\forall$ $i$, $0$ $\leq$ $i$ $<$ $|V|$,

              \hspace{1em}
              $R_i$ $=$
              \begin{math}
                \begin{cases}
                  \mbox{${\cal E}_s$, if $Type$($V_i$) $=$ {\em subject}} \\
                  \mbox{${\cal E}_a$, if $Type$($V_i$) $=$ {\em access right}} \\
                  \vdots \\
                  \mbox{${\cal I}$, if $Type$($V_i$) $=$ {\em interval}}
                \end{cases}
              \end{math}
            \end{vquote}

            A variation of this function, shown below, generates tuples
            with respect to a given temporal constraint. Given a language
            ${\cal L^T}$ {\em where} clause with an interval expression
            $\epsilon$ and a set $V$ of variables that occur in
            $\epsilon$, the following function returns a set of
            $|V|$-tuples, where each tuple satisfies the condition given
            in $\epsilon$:

            \begin{vquote}
              $GenTuples_2$($\epsilon$, $V$)
              $=$ \{$t_0$, $\ldots$, $t_{|V|-1}$\}
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\forall$ $i$, $0$ $\leq$ $i$ $<$ $|V|$,
              $t_i$ $\in$ $GenTuples_1$($V$),

              \hspace{1em}
              $\epsilon'$ $=$
              $NormaliseExp$($Replace$($\epsilon$, $V$, $t_i$)),

              \hspace{1em}
              $\forall$ (${\iota}_0$, ${\iota}_1$, $rs$) $\in$
              $\epsilon'$,
              $NET.Get$(${\iota}_0$, ${\iota}_1$) $\subseteq$ $rs$
            \end{vquote}

          \paragraph
            {\bf Initial Fact Rules.}

            The initial fact rules are obtained directly from initial fact
            declaration statements of language ${\cal L^T}$:

            \begin{vverbatim}
  initially \(\rho\sb{0}\), \(\ldots\), \(\rho\sb{n}\);
            \end{vverbatim}

            \noindent
            Each initial fact declaration statement of language ${\cal L^T}$
            in the form above corresponds to the following language
            ${\cal L^{T^*}}$ rules:

            \begin{vquote}
              $\hat{\rho_i}$ $\leftarrow$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\hat{\rho_i}$ $=$ $TransFact$($\rho_i$, $S_0$),

              \hspace{1em}
              $0$ $\leq$ $i$ $\leq$ $n$
            \end{vquote}

          \paragraph
            {\bf Authorisation Constraint Rules.}

            An authorisation constraint statement in language ${\cal L^T}$
            is in the form:

            \begin{vverbatim}
  always \(\rho\sb{0\sb{0}}\), \(\ldots\), \(\rho\sb{0\sb{n\sb{0}}}\)
    implied by \(\rho\sb{1\sb{0}}\), \(\ldots\), \(\rho\sb{1\sb{n\sb{1}}}\)
    with absence \(\rho\sb{2\sb{0}}\), \(\ldots\), \(\rho\sb{2\sb{n\sb{2}}}\)
    where \(r\sb{0}\), \(\ldots\), \(r\sb{n\sb{3}}\);
            \end{vverbatim}

            The first step is to gather all the entity and interval
            variables that occur in all the expressions above into a set $V$:

            \begin{vquote}
              $V$ $=$
              $Var$(($\rho_{0_0}$, $\ldots$, $\rho_{0_{n_0}}$)) $\cup$
              $Var$(($\rho_{1_0}$, $\ldots$, $\rho_{1_{n_1}}$)) $\cup$
              $Var$(($\rho_{2_0}$, $\ldots$, $\rho_{2_{n_2}}$))
            \end{vquote}

            \noindent
            Using the set $V$, we generate a set of tuples $T$ that satisfies
            the temporal constraint specified by the {\em where} clause:

            \begin{vquote}
              $T$ $=$ $GenTuples_2$(($r_0$, $\ldots$, $r_{n_3}$), $V$)
            \end{vquote}

            \noindent
            Finally, the language ${\cal L^{T^*}}$ equivalent of the
            authorisation constraint rule is the following rules:

            \begin{vquote}
              $\forall$ ($t$, $\sigma$),
            \end{vquote}

            \begin{vquote}
              $\hat{\rho}^{\sigma}_{0_0}$ $\leftarrow$
              $\hat{\rho}^{\sigma}_{1_0}$, \ldots, $\hat{\rho}^{\sigma}_{1_{n_1}}$,
              $not$ $\hat{\rho}^{\sigma}_{2_0}$, \ldots, $not$ $\hat{\rho}^{\sigma}_{2_{n_2}}$

              $\vdots$

              $\hat{\rho}^{\sigma}_{0_{n_0}}$ $\leftarrow$
              $\hat{\rho}^{\sigma}_{1_0}$, \ldots, $\hat{\rho}^{\sigma}_{1_{n_1}}$,
              $not$ $\hat{\rho}^{\sigma}_{2_0}$, \ldots, $not$ $\hat{\rho}^{\sigma}_{2_{n_2}}$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\hat{\rho}^{\sigma}_{0_i}$ =
              $TransFact$($Replace$($\rho_{0_i}$, $V$, $t$), $\sigma$),
              $0$ $\leq$ $i$ $\leq$ $n_0$,

              \hspace{1em}
              $\hat{\rho}^{\sigma}_{1_j}$ =
              $TransFact$($Replace$($\rho_{1_j}$, $V$, $t$), $\sigma$),
              $0$ $\leq$ $j$ $\leq$ $n_1$,

              \hspace{1em}
              $\hat{\rho}^{\sigma}_{2_k}$ =
              $TransFact$($Replace$($\rho_{1_k}$, $V$, $t$), $\sigma$),
              $0$ $\leq$ $k$ $\leq$ $n_2$,

              \hspace{1em}
              $t$ $\in$ $T$,

              \hspace{1em}
              $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
            \end{vquote}

          \paragraph
            {\bf Policy Update Rules.}

            Obviously, only language ${\cal L^T}$ policy update statements
            that are applied to the policy are actually translated to
            language ${\cal L^{T^*}}$ rules. The translation process for
            these rules are again similar to that of language ${\cal L^*}$,
            except this time, the variable grounding is subject to the
            constraints specified by the {\em where} clause. A language
            ${\cal L^T}$ policy update statement is shown below:

            \begin{vverbatim}
  \(u\) causes \(\rho\sb{0\sb{0}}\), \(\ldots\), \(\rho\sb{0\sb{n\sb{0}}}\)
    if \(\rho\sb{1\sb{0}}\), \(\ldots\), \(\rho\sb{1\sb{n\sb{1}}}\)
    where \(r\sb{0}\), \(\ldots\), \(r\sb{n\sb{2}}\);
            \end{vverbatim}

            \noindent
            Like the authorisation constraint rules, the first step in the
            translation process is to generate a set $V$ of entity and
            interval variables that occur in all the expressions:

            \begin{vquote}
              $V$ $=$
              $Var$($\rho_{0_0}$, $\ldots$, $\rho_{0_{n_0}}$) $\cup$
              $Var$($\rho_{1_0}$, $\ldots$, $\rho_{1_{n_1}}$)
            \end{vquote}

            \noindent
            With the variable set $V$ and a {\em where} clause expression
            ($r_0$, $\ldots$, $r_{n_2}$), a set of tuples $T$ can be
            generated such that each tuple $t$ $\in$ $T$ satisfies the
            {\em where} clause constraint:

            \begin{vquote}
              $T$ $=$
              $GenTuples_2$(($r_0$, $\ldots$, $r_{n_2}$), $V$)
            \end{vquote}

            \noindent
            By using the entities and intervals in each tuple in set $T$
            to ground all the variables, we can now define the policy
            update rules in language ${\cal L^{T^*}}$:

            \begin{vquote}
              $\forall$ $t$,
            \end{vquote}

            \begin{vquote}
              $\hat{\rho}_{0_0}$ $\leftarrow$
              $\hat{\rho}_{1_0}$, $\ldots$, $\hat{\rho}_{1_{n_1}}$

              $\vdots$

              $\hat{\rho}_{0_{n_0}}$ $\leftarrow$
              $\hat{\rho}_{1_0}$, $\ldots$, $\hat{\rho}_{1_{n_1}}$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\hat{\rho}_{0_i}$ $=$
              $TransFact$($Replace$($\rho_{0_i}$, $V$, $t$), $Res$($u$, $\sigma$)),
              $0$ $\leq$ $i$ $\leq$ $n_0$,

              \hspace{1em}
              $\hat{\rho}_{1_j}$ $=$
              $TransFact$($Replace$($\rho_{1_j}$, $V$, $t$), $\sigma$),
              $0$ $\leq$ $j$ $\leq$ $n_1$,

              \hspace{1em}
              $t$ $\in$ $T$,

              \hspace{1em}
              $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
            \end{vquote}

          \paragraph
            {\bf Inheritance Rules.}

              As with language ${\cal L^*}$, a set of language
              ${\cal L^{T^*}}$ rules are needed to express the inheritance
              properties of members and subsets. While these rules are
              similar to their respective language ${\cal L^*}$ counterparts,
              the definitions are slightly different due to the
              representation of temporal intervals.

              \begin{enumerate}
                \item
                  Subject Group Member Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($ss$, $sg$, $a$, $o$, $\iota$ $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($sg$, $a$, $o$, $\iota$, $\sigma$),
                    $\hat{memb}$($ss$, $sg$, $\iota$, $\sigma$),

                    \hspace{1em}
                    $not$ $\lnot\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($sg$, $a$, $o$, $\iota$, $\sigma$),
                    $\hat{memb}$($ss$, $sg$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $ss$ $\in$ ${\cal E}_{ss}$,

                    \hspace{1em}
                    $sg$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Access Right Group Member Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $as$, $ag$, $o$, $\iota$ $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $ag$, $o$, $\iota$, $\sigma$),
                    $\hat{memb}$($as$, $ag$, $\iota$, $\sigma$),

                    \hspace{1em}
                    $not$ $\lnot\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $ag$, $o$, $\iota$, $\sigma$),
                    $\hat{memb}$($as$, $ag$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $as$ $\in$ ${\cal E}_{as}$,

                    \hspace{1em}
                    $ag$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Object Group Member Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $a$, $os$, $og$, $\iota$ $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $a$, $og$, $\iota$, $\sigma$),
                    $\hat{memb}$($os$, $og$, $\iota$, $\sigma$),

                    \hspace{1em}
                    $not$ $\lnot\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $a$, $og$, $\iota$, $\sigma$),
                    $\hat{memb}$($os$, $og$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $os$ $\in$ ${\cal E}_{os}$,

                    \hspace{1em}
                    $og$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Subject Group Subset Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($sg_0$, $sg_1$, $a$, $o$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($sg_0$, $a$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$),
                    $\hat{subst}$($sg_0$, $sg_1$, $\iota$, $\sigma$),

                    \hspace{1em}
                    $not$ $\lnot\hat{holds}$($sg_0$, $a$, $o$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($sg_0$, $a$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$),
                    $\hat{subst}$($sg_0$, $sg_1$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $sg_0$, $sg_1$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $sg_0$ $\neq$ $sg_1$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                \end{vquote}

                \item
                  Access Right Group Subset Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $ag_0$, $ag_1$, $o$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $ag_0$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$),
                    $\hat{subst}$($ag_0$, $ag_1$, $\iota$, $\sigma$),

                    \hspace{1em}
                    $not$ $\lnot$ $\hat{holds}$($s$, $ag_0$, $o$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $ag_0$, $o$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$),
                    $\hat{subst}$($ag_0$, $ag_1$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $ag_0$, $ag_1$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $o$ $\in$ ${\cal E}_{o}$,

                    \hspace{1em}
                    $ag_0$ $\neq$ $ag_1$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  Object Group Subset Inheritance Rules

                  \begin{vquote}
                    $\forall$ ($s$, $a$, $og_0$, $og_1$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{holds}$($s$, $a$, $og_0$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$),
                    $\hat{subst}$($og_0$, $og_1$, $\iota$, $\sigma$),

                    \hspace{1em}
                    $not$ $\lnot\hat{holds}$($s$, $a$, $og_0$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    $\lnot\hat{holds}$($s$, $a$, $og_0$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\lnot\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$),
                    $\hat{subst}$($og_0$, $og_1$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_{s}$,

                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_{a}$,

                    \hspace{1em}
                    $og_0$, $og_1$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $og_0$ $\neq$ $og_1$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}
              \end{enumerate}

          \paragraph
            {\bf Transitivity Rules.}

            Like their language ${\cal L^*}$ counterparts, these rules ensure
            that for any three distinct groups $g_0$, $g_1$ and $g_2$, if
            $g_0$ is a subset of $g_1$ and $g_1$ is a subset of $g_2$, then
            $g_0$ is also a subset of $g_2$.

            \begin{enumerate}
              \item
                Subject Group Transitivity Rules

                \begin{vquote}
                  $\forall$ ($sg_{0}$, $sg_{1}$, $sg_{2}$, $\iota$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{subst}$($sg_{0}$, $sg_{2}$, $\iota$, $\sigma$)
                  $\leftarrow$

                  \hspace{1em}
                  $\hat{subst}$($sg_{0}$, $sg_{1}$, $\iota$, $\sigma$),
                  $\hat{subst}$($sg_{1}$, $sg_{2}$, $\iota$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $sg_{0}$, $sg_{1}$, $sg_{2}$ $\in$ ${\cal E}_{sg}$,

                  \hspace{1em}
                  $sg_{0}$ $\neq$ $sg_{1}$ $\neq$ $sg_{2}$,

                  \hspace{1em}
                  $\iota$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                \end{vquote}

              \item
                Access Right Group Transitivity Rules

                \begin{vquote}
                  $\forall$ ($ag_{0}$, $ag_{1}$, $ag_{2}$, $\iota$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{subst}$($ag_{0}$, $ag_{2}$, $\iota$, $\sigma$)
                  $\leftarrow$

                  \hspace{1em}
                  $\hat{subst}$($ag_{0}$, $ag_{1}$, $\iota$, $\sigma$),
                  $\hat{subst}$($ag_{1}$, $ag_{2}$, $\iota$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $ag_{0}$, $ag_{1}$, $ag_{2}$ $\in$ ${\cal E}_{ag}$,

                  \hspace{1em}
                  $ag_{0}$ $\neq$ $ag_{1}$ $\neq$ $ag_{2}$,

                  \hspace{1em}
                  $\iota$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                \end{vquote}
              \item
                Object Group Transitivity Rules

                \begin{vquote}
                  $\forall$ ($og_{0}$, $og_{1}$, $og_{2}$, $\iota$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{subst}$($og_{0}$, $og_{2}$, $\iota$, $\sigma$)
                  $\leftarrow$

                  \hspace{1em}
                  $\hat{subst}$($og_{0}$, $og_{1}$, $\iota$, $\sigma$),
                  $\hat{subst}$($og_{1}$, $og_{2}$, $\iota$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $og_{0}$, $og_{1}$, $og_{2}$ $\in$ ${\cal E}_{og}$,

                  \hspace{1em}
                  $og_{0}$ $\neq$ $og_{1}$ $\neq$ $og_{2}$,

                  \hspace{1em}
                  $\iota$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                \end{vquote}
            \end{enumerate}

          \paragraph
            {\bf Inertial Rules.}

            The same rules of inertia expressed in language ${\cal L^*}$
            applies to language ${\cal L^{T^*}}$: every fact $\hat{\rho}$
            that holds in state $\sigma$ must also hold in state
            $Res$($u$, $\sigma$) after policy update $u$ is applied,
            provided that update $u$ does not cause the fact
            $\lnot\hat{\rho}$ to hold.

            \begin{vquote}
              $\forall$ ($\hat{\alpha}$,$u$),
            \end{vquote}

            \begin{vquote}
              $\hat{\alpha}'$
              $\leftarrow$
              $\hat{\alpha}$,
              $not$ $\lnot$ $\hat{\alpha}'$
            \end{vquote}

            \begin{vquote}
              $\lnot$ $\hat{\alpha}'$
              $\leftarrow$ $\lnot$
              $\hat{\alpha}$,
              $not$ $\hat{\alpha}'$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$,

              \hspace{1em}
              $u$ $\in$ $\psi$,

              \hspace{1em}
              $\hat{\alpha}'$ = $CopyAtom$($\hat{\alpha}$, $Res$($u$, $\sigma$))
            \end{vquote}

          \paragraph
            {\bf Reflexivity Rules.}

            These rules ensure that the reflexive property of sets are
            preserved: every set is a subset of itself.

            \begin{vquote}
              $\forall$ ($g$, $\iota$, $\sigma$),
            \end{vquote}

            \begin{vquote}
              $\hat{subst}$($g$, $g$, $\iota$, $\sigma$) $\leftarrow$
            \end{vquote}

            \begin{vquote}
              where

              \hspace{1em}
              $g$ $\in$ (${\cal E}_{sg}$ $\cup$ ${\cal E}_{ag}$ $\cup$ ${\cal E}_{og}$),

              \hspace{1em}
              $\iota$ $\in$ ${\cal I}$,

              \hspace{1em}
              $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
            \end{vquote}

          \paragraph
            {\bf Temporal Rules.}

            The temporal rules are based on the fact that if a fact
            $\hat{\rho}$ holds at interval $\iota$, then the same fact
            $\hat{\rho}$ must also hold at all intervals $\iota'$ where
            the relation between intervals $\iota$ and $\iota'$ is
            {\em Equals}, {\em During}, {\em Starts} or {\em Finishes}.

            \begin{enumerate}
              \item
                Holds Temporal Rules

                \begin{vquote}
                  $\forall$($s$, $a$, $o$, $\iota_0$, $\iota_1$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{holds}$($s$, $a$, $o$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\hat{holds}$($s$, $a$, $o$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  $\lnot$ $\hat{holds}$($s$, $a$, $o$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\lnot$ $\hat{holds}$($s$, $a$, $o$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $s$ $\in$ ${\cal E}_s$,

                  \hspace{1em}
                  $a$ $\in$ ${\cal E}_a$,

                  \hspace{1em}
                  $0$ $\in$ ${\cal E}_o$,

                  \hspace{1em}
                  $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                  \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                  \hspace{1em}
                  $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                \end{vquote}

              \item
                Membership Temporal Rules

                \begin{vquote}
                  $\forall$($ss$, $sg$, $\iota_0$, $\iota_1$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{memb}$($ss$, $sg$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\hat{memb}$($ss$, $sg$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  $\lnot$ $\hat{memb}$($ss$, $sg$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\lnot$ $\hat{memb}$($ss$, $sg$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $ss$ $\in$ ${\cal E}_{ss}$,

                  \hspace{1em}
                  $sg$ $\in$ ${\cal E}_{sg}$,

                  \hspace{1em}
                  $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                  \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                  \hspace{1em}
                  $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                \end{vquote}

                \vspace{0.5em}

                \begin{vquote}
                  $\forall$($as$, $ag$, $\iota_0$, $\iota_1$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{memb}$($as$, $ag$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\hat{memb}$($as$, $ag$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  $\lnot$ $\hat{memb}$($as$, $ag$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\lnot$ $\hat{memb}$($as$, $ag$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $as$ $\in$ ${\cal E}_{as}$,

                  \hspace{1em}
                  $ag$ $\in$ ${\cal E}_{ag}$,

                  \hspace{1em}
                  $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                  \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                  \hspace{1em}
                  $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                \end{vquote}

                \vspace{0.5em}

                \begin{vquote}
                  $\forall$($os$, $og$, $\iota_0$, $\iota_1$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{memb}$($os$, $og$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\hat{memb}$($os$, $og$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  $\lnot$ $\hat{memb}$($os$, $og$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\lnot$ $\hat{memb}$($os$, $og$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $os$ $\in$ ${\cal E}_{os}$,

                  \hspace{1em}
                  $og$ $\in$ ${\cal E}_{og}$,

                  \hspace{1em}
                  $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                  \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                  \hspace{1em}
                  $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                \end{vquote}

              \item
                Subset Temporal Rules

                \begin{vquote}
                  $\forall$($sg_0$, $sg_1$, $\iota_0$, $\iota_1$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{subst}$($sg_0$, $sg_1$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\hat{subst}$($sg_0$, $sg_1$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  $\lnot$ $\hat{subst}$($sg_0$, $sg_1$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\lnot$ $\hat{subst}$($sg_0$, $sg_1$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $sg_0$, $sg_1$ $\in$ ${\cal E}_{sg}$,

                  \hspace{1em}
                  $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                  \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                  \hspace{1em}
                  $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                \end{vquote}

                \vspace{0.5em}

                \begin{vquote}
                  $\forall$($ag_0$, $ag_1$, $\iota_0$, $\iota_1$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{subst}$($ag_0$, $ag_1$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\hat{subst}$($ag_0$, $ag_1$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  $\lnot$ $\hat{subst}$($ag_0$, $ag_1$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\lnot$ $\hat{subst}$($ag_0$, $ag_1$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $ag_0$, $ag_1$ $\in$ ${\cal E}_{ag}$,

                  \hspace{1em}
                  $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                  \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                  \hspace{1em}
                  $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                \end{vquote}

                \vspace{0.5em}

                \begin{vquote}
                  $\forall$($og_0$, $og_1$, $\iota_0$, $\iota_1$, $\sigma$),
                \end{vquote}

                \begin{vquote}
                  $\hat{subst}$($og_0$, $og_1$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\hat{subst}$($og_0$, $og_1$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  $\lnot$ $\hat{subst}$($og_0$, $og_1$, $\iota_1$, $\sigma$)
                  $\leftarrow$
                  $\lnot$ $\hat{subst}$($og_0$, $og_1$, $\iota_0$, $\sigma$)
                \end{vquote}

                \begin{vquote}
                  where

                  \hspace{1em}
                  $og_0$, $og_1$ $\in$ ${\cal E}_{og}$,

                  \hspace{1em}
                  $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,

                  \hspace{1em}
                  $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                  \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},

                  \hspace{1em}
                  $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                \end{vquote}

            \end{enumerate}

        \begin{vexample}
          \label{exam-tempo-seman}
          The following rules show the language ${\cal L^{T^*}}$ translation
          of the language ${\cal L^T}$ code listing shown in Example
          \ref{exam-tempo-syntx}.

          \begin{enumerate}
            \item
              Initial Fact Rules

              \begin{vquote}
  $\hat{memb}$($alice$, $grp_2$, $work\_hours$, $S_0$) $\leftarrow$

  $\hat{subst}$($grp_2$, $grp_1$, $morning\_hours$, $S_0$) $\leftarrow$

  $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$
              \end{vquote}

            \item
              Authorisation Constraint Rules

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $afternoon\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_1$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Policy Update Rules

              \begin{vquote}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_1$) $\leftarrow$

                $\hat{holds}$($grp_1$, $read$, $file$, $morning\_hours$, $S_1$) $\leftarrow$

                $\hat{holds}$($grp_1$, $read$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$
              \end{vquote}

            \item
              Inheritance Rules

              \begin{vquote}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_2$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_2$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_2$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_2$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_1$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($alice$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($alice$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($alice$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Transitivity Rules

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_3$, $work\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),

                \hspace{1em}
                $\hat{subst}$($grp_2$, $grp_3$, $work\_hours$, $S_0$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_1$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$),

                \hspace{1em}
                $\hat{subst}$($grp_2$, $grp_1$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Inertial Rules

              \begin{vquote}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_1$)
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_0$),

                \hspace{1em}
                $not$ $\lnot$ $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_1$)
              \end{vquote}

            \item
              Reflexivity Rules

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_1$, $work\_hours$, $S_0$) $\leftarrow$
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$
              \end{vquote}

            \item
              Temporal Rules

              \begin{vquote}
                $\hat{holds}$($alice$, $read$, $file$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($alice$, $read$, $file$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{holds}$($grp_3$, $write$, $file$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_1$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{memb}$($alice$, $grp_1$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{memb}$($alice$, $grp_1$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{memb}$($alice$, $grp_3$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{memb}$($alice$, $grp_3$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{memb}$($alice$, $grp_3$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_1$, $grp_2$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{subst}$($grp_1$, $grp_2$, $morning\_hours$, $S_0$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{subst}$($grp_1$, $grp_2$, $work\_hours$, $S_0$),
              \end{vquote}

              \begin{vquote}
                \hspace{1em}
                $\vdots$
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($grp_3$, $grp_2$, $afternoon\_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\hat{subst}$($grp_3$, $grp_2$, $work\_hours$, $S_1$),
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{subst}$($grp_3$, $grp_2$, $afternoon_hours$, $S_1$) $\leftarrow$

                \hspace{1em}
                $\lnot$ $\hat{subst}$($grp_3$, $grp_2$, $work\_hours$, $S_1$),
              \end{vquote}
          \end{enumerate}
        \end{vexample}

    \section{Discussions}
      \label{sect-tempo-discu}

      The previous section has shown how a language ${\cal L^T}$ program can
      be translated into a extended logic program language ${\cal L^{T^*}}$.
      Since language ${\cal L^{T^*}}$ is semantically similar to language
      ${\cal L^*}$, the same methods shown in Section \ref{subs-langl-trans} is
      used to translate language ${\cal L^{T^*}}$ into a normal logic program
      for query evaluation. However, one outstanding issue remains for language
      ${\cal L^T}$: domain consistency.

      A language ${\cal L^T}$ domain description ${\cal D}_{\cal L^T}$ without
      any variable occurrences (and therefore without any {\em where} clauses)
      may be represented as the following statements:

      \begin{vverbatim}
  initially \(\rho\sb{0\sb{0}}\), \(\ldots\), \(\rho\sb{0\sb{n\sb{0}}}\), \(!\)\(\rho\sb{1\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{1\sb{n\sb{1}}}\);

  relation \(r\sb{0\sb{0}}\), \(\ldots\), \(r\sb{0\sb{m}}\);

  always \(\rho\sb{2\sb{0}}\), \(\ldots\), \(\rho\sb{2\sb{n\sb{2}}}\), \(!\)\(\rho\sb{3\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{3\sb{n\sb{3}}}\)
    implied by \(\rho\sb{4\sb{0}}\), \(\ldots\), \(\rho\sb{4\sb{n\sb{4}}}\), \(!\)\(\rho\sb{5\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{5\sb{n\sb{5}}}\)
    with absence \(\rho\sb{6\sb{0}}\), \(\ldots\), \(\rho\sb{6\sb{n\sb{6}}}\), \(!\)\(\rho\sb{7\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{7\sb{n\sb{7}}}\);

  update \(u\)()
    causes \(\rho\sb{8\sb{0}}\), \(\ldots\), \(\rho\sb{8\sb{n\sb{8}}}\), \(!\)\(\rho\sb{9\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{9\sb{n\sb{9}}}\)
    if \(\rho\sb{10\sb{0}}\), \(\ldots\), \(\rho\sb{10\sb{n\sb{10}}}\), \(!\)\(\rho\sb{11\sb{0}}\), \(\ldots\), \(!\)\(\rho\sb{11\sb{n\sb{11}}}\);
      \end{vverbatim}

      Note that if we disregard the {\em relation} statement and the fact
      that language ${\cal L^T}$ atoms also specify time intervals, language
      ${\cal L^T}$ statements consisting only of ground expressions as above
      are identical to the language ${\cal L}$ statements shown in Section
      \ref{sect-langl-consi}. As a consequence, Theorem \ref{theo-langl-consi}
      can be used to define ${\cal D_{L^T}}$ consistency:

      \begin{vdefinition}
        \label{defn-tempo-cons1}
        A domain description ${\cal D_{L^T}}$ is {\bf consistent} if:

        \begin{enumerate}
          \item
            \label{defn-tempo-cons1-1}
            ${\cal D_{L^T}}$ is {\bf normal}, using the same language
            ${\cal L}$ definition in Definition \ref{defn-langl-norml}; and

          \item
            \label{defn-tempo-cons1-2}
            The temporal interval relations defined in ${\cal D_{L^T}}$
            produces a {\bf consistent interval network}.
        \end{enumerate}
      \end{vdefinition}

      Assuming that we already have a normal domain description, we focus on
      the second condition. Below, we define network consistency:

      \begin{vdefinition}
        \label{defn-tempo-cons2}
        Given a temporal interval network $N$, with nodes $n_0$,
        $\ldots$ $n_n$ and arcs $a_0$, $\ldots$, $a_m$. An {\bf instance} of
        interval network $N$ is a subnetwork with nodes $n_0$, $\ldots$, $n_n$,
        with each arc $a_{i}'$ representing a single relation from the
        corresponding arc in $N$ ($a_{i}'$ $\in$ $a_i$, $0$ $\leq$ $i$ $\leq$
        $m$). A {\bf consistent instance} of interval network $N$ is an
        instance of $N$ such that for any three nodes, the three relations
        represented by these nodes satisfy the transitivity rules shown in
        Table \ref{tabl-tempo-ttabl}. A {\bf consistent interval network} is a
        network with at least one consistent instance.
      \end{vdefinition}

      Any given language ${\cal L^T}$ domain description can fail to satisfy
      Condition \ref{defn-tempo-cons1-2} in Definition \ref{defn-tempo-cons1}
      above in different ways. In fact, Valdez-Perez \cite{VAL} generalised
      these conditions where an interval network is inconsistent\footnotemark.
      \footnotetext{Valdez-Perez uses the term {\em unsatisfiable}.}
      One such condition arises in language ${\cal L^T}$ when two or more
      conflicting interval constraint statements exist. This conflict occurs
      when the consequence of an interval constraint is implicitly or explicitly
      excluded by another interval constraint. For example, the following two
      interval constraint statements are in conflict with each other because
      the second defines a relation that has been explicitly excluded by the
      first.

      \begin{vverbatim}
  relation during(i0, i1), before(i0, i1);
  relation equals(i0, i1);
      \end{vverbatim}

      Note that this type of domain inconsistency is detected by the
      $NET.AddRel$() algorithm. Unfortunately, the second type of inconsistency
      is not. To illustrate this type of inconsistency, we use Allen's example
      in \cite{ALE}, shown in Figure \ref{figu-tempo-ntwk7}.

      \begin{figure}[tbhp]
        \begin{center}
          \includegraphics{net-07}
          \caption{Inconsistent Network}
          \label{figu-tempo-ntwk7}
        \end{center}
      \end{figure}

      The network shown in Figure \ref{figu-tempo-ntwk7} is in fact
      inconsistent, as none of its 32 instances are consistent. To see this, we
      note that although the $NET.AddRel$() algorithm accepts the relation
      shown between the arcs $i_1$ and $i_2$, we cannot assign the relation
      {\em finishes} or {\em finished by} alone.

      In fact, as Allen points out in \cite{ALE}, the $NET.AddRel$() algorithm
      can only guarantee consistency within any three nodes of the network
      ({\em 3-consistency}). Unfortunately, Vilain et. al. \cite{VIL} points
      out that algorithms that can ensure full network consistency, i.e.
      {\em k-consistency} \cite{FRE}, are in fact, intractable. Nevertheless,
      total consistency can be easily checked by employing a simple
      backtracking algorithm. Furthermore, several methods for full network
      consistency checking, like those in \cite{LAD,VAN2} already exist. In
      this work, we make the assumption that 3-consistency is sufficient for
      our authorisation system as we have observed that this covers all
      scenarios that we have examined.

      In this chapter, we have introduced an algebra for expressing time
      interval relations and an authorisation language that employs this
      algebra to express temporal constraints. In the next chapter, we shall
      describe in detail the implementation of an authorisation system whose
      policies are expressed in this language.

  \chapter{Implementation Issues}
    \label{chap-impln}

    This chapter focuses on two issues: (1) the implementation of
    {\em PolicyUpdater} version 2, which includes support for temporal
    constraints; and (2) an in-depth discussion of implementation issues not
    previously covered in the other chapters.

    The source code and other technical information of all the versions of
    the {\em PolicyUpdater} core system, {\em vlad}, is available in the
    project website:

    \begin{vquote}
      {\tt\scriptsize http://www.scm.uws.edu.au/\~{}jcrescin/projects/policyupdater/index.html}
    \end{vquote}

    The PolicyUpdater software package makes use of a temporal reasoner engine
    to evaluate temporal interval relations under the rules of the interval
    algebra discussed in Chapter \ref{chap-tempo}. The source code and other
    implementation details of a full library implementation of the temporal
    reasoner engine, {\em tribe}, can be found in the following website:

    \begin{vquote}
      {\tt\scriptsize http://www.scm.uws.edu.au/\~{}jcrescin/projects/tribe/index.html}
    \end{vquote}

    \section{System Structure}
      \label{sect-impln-sysst}

      \begin{figure}[tbhp]
        \begin{center}
          \includegraphics{sys-04}
          \caption{System Flowchart}
          \label{figu-impln-flwch}
        \end{center}
      \end{figure}

      Figure \ref{figu-impln-flwch} shows the internal processes of the system.
      The overall process of the system is similar to that of the previous
      version:

      An access control policy, written in language ${\cal L^T}$ syntax, is
      translated into a normal logic program, which in turn is fed to
      {\em SModels} to generate answer sets. From these answer sets, the system
      can evaluate authorisation queries.

      What makes {\em PolicyUpdater 2} different from its predecessor is that
      it uses a temporal reasoner to generate a normal logic program. The
      system gathers all temporal intervals and relations from the policy and
      makes use of the temporal reasoner to derive new interval relations not
      explicitly stated in the policy.

      Another difference is the variable grounding process. With
      {\em PolicyUpdater 1}, variables are resolved just before they are stored
      in the policy base. This is possible because in {\em PolicyUpdater 1},
      the only variables that occur in the policy are resolved to all entities
      defined that are of the same type. However, in {\em PolicyUpdater 2},
      the intervals used to ground interval variables are subject to some
      restrictions defined by {\em where} clauses in policy statements. As a
      result, the variable grounding process of {\em PolicyUpdater 2} needs
      some interaction with the temporal reasoner engine.

      The internal mechanisms of both the temporal reasoner engine and the
      policy base engine shall be discussed in detail in the following
      sections. However, before we do so, we first formalise a list structure
      first introduced in Section \ref{subs-polup-dstru} as the implementation
      of both engines makes use of this structure.

      \begin{vdefinition}
        \label{defn-impln-lists}
        A list object $LIST$ is defined as a linked-list implementation with
        the following operators:

        \begin{enumerate}
          \item
            $LIST$.$Init$() initialises or re-initialises $LIST$. Any items
            in the list is removed after this operator is called.

          \item
            $LIST$.$Length$() returns the number of items stored in $LIST$.
            The shorthand notation $|LIST|$ is equivalent to $LIST$.$Length$().

          \item
            $LIST$.$Find$($item$) returns {\em true} if $item$ is stored in
            $LIST$, {\em false} otherwise.

          \item
            $LIST$.$Index$($item$) returns the ordinal index of $item$ with
            respect to $LIST$.

          \item
            $LIST$.$Add$($item$) attaches $item$ to the end of $LIST$.

          \item
            $LIST$.$Del$($index$) removes the $index$'th item from $LIST$.

          \item
            $LIST$.$Get$($index$) returns the $index$'th item in $LIST$. The
            shorthand notation $LIST$[$index$] is equivalent to
            $LIST$.$Get$($index$).

          \item
            $LIST$.$Append$($list$) attaches the items in $list$ at the end of
            $LIST$.
        \end{enumerate}
      \end{vdefinition}

    \section{Temporal Reasoner}
      \label{sect-impln-treas}

      The primary purpose of the temporal reasoner engine is to maintain a
      complete network of temporal intervals and their relations to each
      other, as discussed in Chapter \ref{chap-tempo}, such that: (1) the
      effects of adding a new relation are propagated to the entire network;
      and (2) the relation between any two intervals can be looked up at any
      given time. This section focuses on the methods used in the
      implementation of this reasoner engine.

      \subsection{Network Structure}
        \label{subs-impln-struc}

        Conceptually, a temporal interval relation network may be represented
        as a table whose rows and columns both represent all the intervals
        in the network. As shown in Table \ref{tabl-impln-concp}, all the
        possible relations that exist between intervals $\iota_i$ and
        $\iota_j$, as stored in the network, are contained in the relation set
        $RS_{ij}$ from cell ($i$, $j$).

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|c|c|c|c|c|}
              \cline{1-3}
              \cline{5-5}
              & $\iota_0$ & $\iota_1$ & $\ldots$ & $\iota_n$ \\
              \cline{1-3}
              \cline{5-5}
              $\iota_0$ & $RS_{00}$ & $RS_{01}$ & & $RS_{0n}$ \\
              \cline{1-3}
              \cline{5-5}
              $\iota_1$ & $RS_{10}$ & $RS_{11}$ & & $RS_{1n}$ \\
              \cline{1-3}
              \cline{5-5}
              \multicolumn{4}{l}{$\vdots$} & \multicolumn{1}{l}{$\vdots$} \\
              \cline{1-3}
              \cline{5-5}
              $\iota_n$ & $RS_{n0}$ & $RS_{n1}$ & $\ldots$ & $RS_{nn}$ \\
              \cline{1-3}
              \cline{5-5}
            \end{tabular}
          \end{center}
          \caption{Conceptual Representation of an Interval Network}
          \label{tabl-impln-concp}
        \end{table}

        As we shall see, using this representation as a basis for
        implementation is not a good idea, as it contains redundant information
        and will incur a high maintenance overhead. First, we note that due
        to the reflexive property of intervals, all the cells in the diagonal
        of this representation is defined as follows:

        \begin{vquote}
          $\forall$ $i$,

          $RS_{ii}$ $=$ {$EQL$}

          where

          \hspace{1em}
          $0$ $\leq$ $i$ $\leq$ $n$
        \end{vquote}

        As the reflexive property applies to all intervals, there is no need to
        store such relations in the network. Another instance of redundancy in
        this representation is made evident by the following property:

        \begin{vquote}
          $\forall$ ($i$, $j$),

          $RS_{ij}$ $=$ $RS^{-1}_{ji}$

          where

          \hspace{1em}
          $0$ $\leq$ $i$ $\leq$ $n$

          \hspace{1em}
          $0$ $\leq$ $j$ $\leq$ $n$

          \hspace{1em}
          $RS^{-1}$ is the inverse set of $RS$
        \end{vquote}

        The property above states that a relation set between two intervals
        $\iota_0$ and $\iota_1$ can be derived by calculating the inverse of
        the relation set between $\iota_1$ and $\iota_0$. As a consequence,
        only one relation set between any two intervals needs to be stored
        as its inverse can be calculated from this relation set if required.
        Note that due to this property, half of the cells in Table
        \ref{tabl-impln-concp} are redundant. The information stored above the
        diagonal is the inverse of those stored below.

        \subsubsection{Binary Representation of Relation Sets}

          Obviously, relation sets can be conceptually represented as a list of
          relations. However, from an implementation point of view, maintaining
          a list of relations for every relation set can incur a lot of
          overhead as the cost of adding and removing relations from such a
          list can be computationally expensive. To avoid this problem, we
          employ a more efficient way of representing these sets in our
          implementation. Each relation set is represented as a bit
          vector\footnotemark.

          \footnotetext{A similar method is used in \cite{VAN2, VIL}.}

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|c|c|c|c|}
                \hline
                {\bf Relation} & {\bf Symbol} & {\bf Value} & {\bf Bit Value} \\
                \hline
                Equals        & EQL &    1 &  0 \\
                \hline
                Before        & BEF &    2 &  1 \\
                \hline
                During        & DUR &    4 &  2 \\
                \hline
                Overlaps      & OVR &    8 &  3 \\
                \hline
                Meets         & MET &   16 &  4 \\
                \hline
                Starts        & STA &   32 &  5 \\
                \hline
                Finishes      & FIN &   64 &  6 \\
                \hline
                After         & BEI &  128 &  7 \\
                \hline
                Contains      & DUI &  256 &  8 \\
                \hline
                Overlapped By & OVI &  512 &  9 \\
                \hline
                Met By        & MEI & 1024 & 10 \\
                \hline
                Started By    & STI & 2048 & 11 \\
                \hline
                Finished By   & FII & 4096 & 12 \\
                \hline
              \end{tabular}
            \end{center}
            \caption{Temporal Relation Value Assignment}
            \label{tabl-impln-valas}
          \end{table}

          To illustrate this representation, we first assign a base-2 value
          for each basic relation as shown in Table \ref{tabl-impln-valas}.
          With these value assignments, any relation set composed of any
          combination of these basic relations can be represented as an integer
          which is the sum of the relations that it contains. For example,
          under this system the relation set \{$BEF$, $DUR$, $STA$, $STI$\} can
          be represented as $2086$.

          Implemented as a bit vector, three important relation set operators
          can be easily defined by using bitwise operators:

          \begin{itemize}
            \item
              The {\em Union} between two relation sets is calculated by
              performing a {\em bitwise and} operation between the two sets.

              \begin{vquote}
                $RS_0$ $\cup$ $RS_1$ $=$ $RS_0$ $|$ $RS_1$
              \end{vquote}

            \item
              The {\em Intersection} between two relation sets is simply the
              opposite of the union operation: a {\em bitwise or} operation
              between the two sets.

              \begin{vquote}
                $RS_0$ $\cap$ $RS_1$ $=$ $RS_0$ $\&$ $RS_1$
              \end{vquote}

            \item
              The {\em Inverse} of a relation set can be calculated by
              replacing each relation bit, as defined by Table
              \ref{tabl-impln-valas}, by its inverse relation bit. This
              is achieved by a series of bit masking and shifting operations:

              \begin{vquote}
                $RS^{-1}$ $=$
                  (($RS$ $\&$ $8064$) $>>$ $6$) $|$
                  (($RS$ $\&$ $126$)  $<<$ $6$) $|$
                  ($RS$ $\&$ $1$)
              \end{vquote}
          \end{itemize}

        \subsubsection{Network Data Structure}

          The temporal interval network is implemented as a list of all
          intervals, each with a relation list where information about its
          relation with other intervals are stored (see Figure
          \ref{figu-impln-nws01}). Table \ref{tabl-impln-nwdsr} shows the
          structure of each node in the network list, while Table
          \ref{tabl-impln-rldsr} shows the structure of each relation list
          node in each network list node.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-struct-01}
              \caption{Network Structure as a List of Relation Lists}
              \label{figu-impln-nws01}
            \end{center}
          \end{figure}

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|l|l|l|}
                \hline
                {\bf Field} & {\bf Type} & {\bf Description} \\
                \hline
                $int$       & String     & Interval ID \\
                \hline
                $ep_0$      & Integer    & Starting End Point \\
                \hline
                $ep_1$      & Integer    & Finishing End Point \\
                \hline
                $rlist$     & RelList    & Relation List \\
                \hline
              \end{tabular}
            \end{center}
            \caption{Network Node Data Structure}
            \label{tabl-impln-nwdsr}
          \end{table}

          \begin{table}[tbhp]
            \begin{center}
              \begin{tabular}[t]{|l|l|l|}
                \hline
                {\bf Field} & {\bf Type} & {\bf Description} \\
                \hline
                $int$ & String & Interval ID \\
                \hline
                $rs$      & Integer & Relation Set \\
                \hline
              \end{tabular}
            \end{center}
            \caption{Relation List Node Data Structure}
            \label{tabl-impln-rldsr}
          \end{table}

          For example, the network shown in Figure \ref{figu-impln-nws02}
          contains only the relations $before$($\iota_0$, $\iota_1$) and
          $during$($\iota_0$, $\iota_1$). This network, $NET$, is stored in the
          following manner:

          \begin{vquote}
            $NET$[$0$].$int$ $=$ $\iota_0$

            $NET$[$0$].$rlist$[$0$].$int$ $=$ $\iota_1$

            $NET$[$0$].$rlist$[$0$].$rs$ $=$ $6$

            $NET$[$1$].$int$ $=$ $\iota_1$

            $NET$[$1$].$rlist$ $=$ $\emptyset$
          \end{vquote}

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-struct-02}
              \caption{Network Structure Containing $before$($\iota_0$, $\iota_1$) and $during$($\iota_0$, $\iota_1$)}
              \label{figu-impln-nws02}
            \end{center}
          \end{figure}

          Note that in the previous example, the relations between intervals
          $\iota_0$ and $\iota_1$ are stored in the relation list of interval
          $\iota_0$, but the inverse relations, those between intervals
          $\iota_1$ and $\iota_0$, are not stored in the relation list of
          $\iota_1$. This is done for efficiency, as inverse relations can be
          calculated by the inverse operator for any stored relations.

          However, this method raises the question of how we decide which
          interval node is used to store a given relation. In the previous
          example, we arbitrarily chose to store the relation in interval
          $\iota_0$'s relation list, however, as shown in Figure
          \ref{figu-impln-nws03}, we could just as easily have chosen to store
          the relation in interval $\iota_1$'s relation list:

          \begin{vquote}
            $NET$[$0$].$int$ $=$ $\iota_0$

            $NET$[$0$].$rlist$ $=$ $\emptyset$

            $NET$[$1$].$int$ $=$ $\iota_1$

            $NET$[$1$].$rlist$[$0$].$int$ $=$ $\iota_0$

            $NET$[$1$].$rlist$[$0$].$rs$ $=$ $384$
          \end{vquote}

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-struct-03}
              \caption{Equivalent Representation of $before$($\iota_0$, $\iota_1$) and $during$($\iota_0$, $\iota_1$)}
              \label{figu-impln-nws03}
            \end{center}
          \end{figure}

          To resolve this issue, we adopt a simple rule to determine where a
          given relation is to be stored in the network. Given a pair of
          intervals $\iota_0$ and $\iota_1$, and a relation set $rs$, this
          relation is stored in the node whose interval ID occurs first when
          sorted alphabetically. For example, if $\iota_0$ is $morning$ and
          $\iota_1$ is $evening$, then the relation $rs$ would be stored
          in the node containing $\iota_1$, since $evening$ is alphabetically
          before $morning$. To enforce this rule, we use the function shown
          in Algorithm \ref{algo-impln-norml} before adding a relation to the
          network.

          \begin{valgorithm}{NormaliseRel()}{algo-impln-norml}
FUNCTION \(NormaliseRel\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  IF \(\iota\sb{0}\) \(\leq\) \(\iota\sb{1}\) THEN
    RETURN (\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  ELSE
    RETURN (\(\iota\sb{1}\), \(\iota\sb{0}\), \(rs\sp{-1}\))
  ENDIF
ENDFUNCTION
          \end{valgorithm}

          Another issue to be considered arises from the network's completeness
          property from Definition \ref{defn-tempo-netwk}, i.e. every node in
          the network must be connected to every other node. As mentioned in
          Section \ref{subs-tempo-infer}, this property is maintained even
          between nodes containing intervals with no defined relations by
          assigning the default arc, which represents a relation set containing
          all 13 relations. Now, considering that the network is implemented
          as a list of intervals, each with its own list of relations with
          other intervals, it is easy to see that storing these default
          relations will incur a lot of overhead. When a new interval is added
          to the network, a relation list containing all the other intervals
          must also be added, and each node in this relation list contains the
          default relation.

          Figure \ref{figu-impln-nws04} shows how such implementation might
          represent a network with 3 intervals and the relations {\em starts}
          or {\em finishes} between intervals $\iota_0$ and $\iota_1$. Note
          that although only the relation between intervals $\iota_0$ and
          $\iota_1$ is given, the default relation is still stored between
          intervals $\iota_0$ and $\iota_2$ and between intervals $\iota_1$ and
          $\iota_2$.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-struct-04}
              \caption{Network Structure with Default Relations Stored}
              \label{figu-impln-nws04}
            \end{center}
          \end{figure}

          This issue is easily resolved by simply not storing default
          relations. In other words, an interval that is not in the relation
          list of another interval is assumed to have the default relation with
          that interval. By adopting this technique, we can be certain that the
          network implementation will only store the minimum information
          required, and yet the relations between any two intervals can be
          derived. Figure \ref{figu-impln-nws05} shows how the network in
          the above example is stored by using this method.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-struct-05}
              \caption{Network Structure with Default Relations Omitted}
              \label{figu-impln-nws05}
            \end{center}
          \end{figure}

      \subsection{Network Operators}
        \label{subs-impln-netop}

        The following defines the full operator set allowed for the interval
        network. This definition supersedes the basic operators shown in
        Definition \ref{defn-tempo-netop}.

        \begin{vdefinition}
          \label{defn-impln-netop}
          A temporal interval relation network $NET$ implements the following
          operators:

          \begin{enumerate}
            \item
              The $NET.Init$() operator initialises or re-initialises the
              network.

            \item
              The $NET.AddInt$($\iota$) operator causes the given interval
              identifier $\iota$ to be added to the network.

            \item
              The $NET$.$AddRel$($\iota_0$, $\iota_1$, $rs$) operator adds the
              relation set $rs$ to the network as the set of possible
              relations between intervals $\iota_0$ and $\iota_1$, and
              propagates the effects of this relation to the entire network.

            \item
              The $NET$.$Bind$($\iota$, $ep_0$, $ep_1$) operator registers the
              points $ep_0$ and $ep_1$ as the end points of interval $\iota$,
              then calculates the relation of this interval with other
              intervals based on their end points.

            \item
              The $NET$.$Get$($\iota_0$, $\iota_1$) operator returns the
              relation set between the intervals $\iota_0$ and $\iota_1$.
          \end{enumerate}
        \end{vdefinition}

        We note that the network operators shown in Definition
        \ref{defn-impln-netop} do not include the $NET.Replace$() operator.
        This is due to the fact that this is an internal operator used only by
        the $NET.AddRel$() operator. Nevertheless, the details of how this
        operator replaces the network relation between the two given intervals
        by the given relation set is shown in Algorithm \ref{algo-impln-ntrep}.

        \begin{valgorithm}{NET.Replace()}{algo-impln-ntrep}
FUNCTION \(NET\).\(Replace\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  (\(\iota\sb{0}'\), \(\iota\sb{1}'\), \(rs\)) = \(NormaliseRel\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  \(index\sb{0}\) = \(NET\).\(Index\)(\(\iota\sb{0}'\))
  IF \(NET\)[\(index\sb{0}\)].\(rlist\).\(Find\)(\(\iota\sb{1}'\)) THEN
    \(index\sb{1}\) = \(NET\)[\(index\sb{0}\)].\(rlist\).\(Index\)(\(\iota\sb{1}'\))
    \(NET\)[\(index\sb{0}\)].\(rlist\)[\(index\sb{1}\)].\(rs\) = \(rs'\)
  ELSE
    \(rlnode\).\(int\) = \(\iota\sb{1}'\)
    \(rlnode\).\(rs\) = \(rs'\)
    \(NET\)[\(index\sb{0}\)].\(rlist\).\(Add\)(\(rlnode\))
  ENDIF
ENDFUNCTION
        \end{valgorithm}

        The $NET$.$Init$() operator is a simple routine that initialises the
        network when called for the first time, and otherwise deletes all the
        nodes in the network, including all relation list nodes within these
        network nodes.

        Algorithm \ref{algo-impln-ntadi} shows the $NET$.$AddInt$($\iota$)
        operator. It works by firstly checking whether a network node with the
        interval $\iota$ is already defined. If not, a new network node is
        allocated and appended to the end of the network list. Since the $NET$
        structure is implemented as a list, the $LIST$.$Add$() can be used to
        add nodes.

        \begin{valgorithm}{NET.AddInt()}{algo-impln-ntadi}
FUNCTION \(NET\).\(AddInt\)(\(\iota\))
  IF \(\iota\) is not in \(NET\) THEN
    \(nnode\).\(int\) = \(\iota\)
    \(nnode\).\(rlist\) = \(\emptyset\)
    \(NET\).\(Add\)(\(nnode\))
  ENDIF
ENDFUNCTION
        \end{valgorithm}

        The $NET$.$AddRel$() operator shown in Algorithm \ref{algo-tempo-ntadr}
        illustrates the relation propagation algorithm based solely on Allen's
        $ToAdd$() function in \cite{ALE}. Algorithm \ref{algo-impln-ntadr}
        shows a simplified algorithm without the using a queue structure. This
        is made possible by the fact that the order in which relations are
        propagated makes no difference in the resulting network \cite{MAC,VAN1}.
        While the algorithm that uses a queue structure performs breadth-first
        propagation, the recursive algorithm below performs depth-first
        propagation.

        \begin{valgorithm}{NET.AddRel()}{algo-impln-ntadr}
FUNCTION \(NET\).\(AddRel\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
  IF \(rs\) \(\subset\) \(NET\).\(Get\)(\(\iota\sb{0}\), \(\iota\sb{1}\)) THEN
    \(NET\).\(Replace\)(\(\iota\sb{0}\), \(\iota\sb{1}\), \(rs\))
    FOR each interval \(\iota'\) \(\in\) \(NET\) DO
      IF \(\iota'\) != \(\iota\sb{0}\) AND \(\iota'\) != \(\iota\sb{1}\) THEN
        \(rs'\) =  \(NET.Get\)(\(\iota'\), \(\iota\sb{0}\))
        IF NOT \(Skip\)(\(rs'\), \(rs\)) THEN
          \(NET\).\(AddRel\)(\(\iota'\), \(\iota\sb{1}\), \(NET.Get\)(\(\iota'\), \(\iota\sb{1}\)) \(\cap\) \(Trans\sb{2}\)(\(rs'\), \(rs\)))
        ENDIF
      ENDIF
    ENDDO
    FOR each interval \(\iota'\) \(\in\) \(NET\) DO
      IF \(\iota'\) != \(\iota\sb{0}\) AND \(\iota'\) != \(\iota\sb{1}\) THEN
        \(rs'\) =  \(NET.Get\)(\(\iota\sb{1}\), \(\iota'\))
        IF NOT \(Skip\)(\(rs\), \(rs'\)) THEN
          \(NET\).\(AddRel\)(\(\iota\sb{0}\), \(\iota'\), \(NET.Get\)(\(\iota\sb{0}\), \(\iota'\)) \(\cap\) \(Trans\sb{2}\)(\(rs\), \(rs'\)))
        ENDIF
      ENDIF
    ENDDO
  ENDIF
ENDFUNCTION
          \end{valgorithm}

        Algorithm \ref{algo-impln-ntadr} also takes advantage of Van Beek and
        Manchak's observation that certain relation set combinations will not
        yield new information \cite{VAN2}. These combinations are summarised in
        the $Skip$() function shown in Algorithm \ref{algo-impln-skipp}.

        \begin{valgorithm}{Skip()}{algo-impln-skipp}
FUNCTION \(Skip\)(\(rs\sb{0}\), \(rs\sb{1}\))
  IF (\(rs\sb{0}\) == \{\(ALL\)\}) OR
     (\(rs\sb{1}\) == \{\(ALL\)\}) OR
     (\(BEF\) \(\in\) \(rs\sb{0}\) AND \(BEI\) \(\in\) \(rs\sb{1}\)) OR
     (\(BEI\) \(\in\) \(rs\sb{0}\) AND \(BEF\) \(\in\) \(rs\sb{1}\)) OR
     (\(DUR\) \(\in\) \(rs\sb{0}\) AND \(DUI\) \(\in\) \(rs\sb{1}\)) THEN
    RETURN TRUE
  ENDIF
  RETURN FALSE
ENDFUNCTION
        \end{valgorithm}

        Finally, as the details of the $NET$.$Bind$() operator is already shown
        in Algorithm \ref{algo-tempo-ntbin}, we show the $NET$.$Get$() operator
        in Algorithm \ref{algo-impln-ntget}.

        \begin{valgorithm}{NET.Get()}{algo-impln-ntget}
FUNCTION \(NET\).\(Get\)(\(\iota\sb{0}\), \(\iota\sb{1}\))
  IF \(\iota\sb{0}\) \(\leq\) \(\iota\sb{1}\) THEN
    \(index\) = \(NET\).\(Index\)(\(\iota\sb{0}\))
    IF \(NET\)[\(index\)].\(rlist\).\(Find\)(\(\iota\sb{1}\)) THEN
      RETURN \(NET\)[\(index\)].\(rlist\)[\(NET\)[\(index\)].\(rlist\).\(Index\)(\(\iota\sb{1}\))].\(rs\)
    ELSE
      RETURN \(ALL\)
    ENDIF
  ELSE
    \(index\) = \(NET\).\(Index\)(\(\iota\sb{1}\))
    IF \(NET\)[\(index\)].\(rlist\).\(Find\)(\(\iota\sb{0}\)) THEN
      RETURN \(NET\)[\(index\)].\(rlist\)[\(NET\)[\(index\)].\(rlist\).\(Index\)(\(\iota\sb{0}\))].\(rs\)\(\sp{-1}\)
    ELSE
      RETURN \(ALL\)
    ENDIF
  ENDIF
ENDFUNCTION
        \end{valgorithm}

    \section{Policy Base Engine}
      \label{sect-impln-polba}

      The focus of this section is the internal mechanisms of the policy base
      and other implementation issues. In essence, the policy base is the
      core authorisation engine of the PolicyUpdater system. While Chapter
      \ref{chap-polup} gave a general overview of the system data structures
      and processes, here we shall attempt to provide a more detailed
      formalisation of these internal mechanisms, and to show how the policy
      base makes use of the temporal reasoner engine.

      \subsection{Data Structures}
        \label{subs-impln-dstru}

        The policy base is composed of different data structures on which
        its operators are performed. Table \ref{tabl-impln-polba} summarises
        these structures. These structures are used by the policy base to
        store the different components of the policy prior to the normal logic
        program translation. Note that because of the similarities of
        PolicyUpdater version 1 and version 2, some of the more fundamental
        structures have already been defined in Section \ref{subs-polup-dstru}.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              {\bf Field} & {\bf Type}               & {\bf Description} \\
              \hline
              $symtab$    & Symbol Table             & List of Entity and Interval Identifiers \\
              \hline
              $inittab$   & Expression               & List of Initial Facts \\
              \hline
              $consttab$  & Constraints Table        & List of Constraints \\
              \hline
              $updatetab$ & Update Declaration Table & List of Policy Update Declarations \\
              \hline
              $seqtab$    & Update Sequence Table    & List of Policy Update Declarations \\
              \hline
              $netwk$     & Relation Network         & Interval Relation Network \\
              \hline
            \end{tabular}
          \end{center}
          \caption{Policy Base Structure}
          \label{tabl-impln-polba}
        \end{table}

        The symbol table $PB$.$symtab$, whose structure is shown in Table
        \ref{tabl-impln-sytab}, is used by the policy base to store
        identifiers. The main difference of this symbol table to that of
        version 1 (shown in Table \ref{tabl-polup-sytab}) is that it also
        stores interval identifiers. However, the general structure remains
        the same: each field is a list containing all defined entities and
        intervals of a specific type.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              {\bf Field} & {\bf Type} & {\bf Description} \\
              \hline
              $ss$  & String List & Single Subject \\
              \hline
              $sg$  & String List & Group Subject \\
              \hline
              $as$  & String List & Single Access Right \\
              \hline
              $ag$  & String List & Group Access Right \\
              \hline
              $os$  & String List & Single Object \\
              \hline
              $og$  & String List & Group Object \\
              \hline
              $s$   & String List & $ss$ $+$ $sg$ \\
              \hline
              $a$   & String List & $as$ $+$ $ag$ \\
              \hline
              $o$   & String List & $os$ $+$ $og$ \\
              \hline
              $int$ & String List & Interval \\
              \hline
            \end{tabular}
          \end{center}
          \caption{Extended Symbol Table}
          \label{tabl-impln-sytab}
        \end{table}

        The initial facts table $PB$.$inittab$ is a list of all facts declared
        in the language ${\cal L^T}$ {\em initially} statement. Recall from
        Section \ref{subs-polup-dstru} that the fact structure is composed
        of an atom, a type specifier $type$ $\in$ \{$h$, $m$, $s$\} and a
        truth indicator $truth$ $\in$ \{$true$, $false$\}. Table
        \ref{tabl-impln-atdsr} shows the data structure used to store atoms.
        Note that the atom structure is extended to include interval
        identifiers for each atom type.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|l|}
              \hline
              \textbf{Atom}             & \textbf{Field} & \textbf{Type}             & \textbf{Description} \\
              \hline
              {\multirow{3}{*}{holds}}  & $sub$          & String                    & Subject Entity \\
              \cline{2-4}
                                        & $acc$          & String                    & Access Right Entity \\
              \cline{2-4}
                                        & $obj$          & String                    & Object Entity \\
              \cline{2-4}
                                        & $int$          & String                    & Interval \\
              \hline
              {\multirow{4}{*}{member}} & $elt$          & String                    & Single Entity \\
              \cline{2-4}
                                        & $grp$          & String                    & Group Entity \\
              \cline{2-4}
                                        & $int$          & String                    & Interval \\
              \cline{2-4}
                                        & $type$         & \{$sub$$|$$acc$$|$$obj$\} & Type Specifier \\
              \hline
              {\multirow{4}{*}{subset}} & $grp_0$        & String                    & Subgroup Entity \\
              \cline{2-4}
                                        & $grp_1$        & String                    & Supergroup Entity \\
              \cline{2-4}
                                        & $int$          & String                    & Interval \\
              \cline{2-4}
                                        & $type$         & \{$sub$$|$$acc$$|$$obj$\} & Type Specifier \\
              \hline
            \end{tabular}
          \end{center}
          \caption{Extended Atom Data Structure}
          \label{tabl-impln-atdsr}
        \end{table}

        The constraints table $PB$.$consttab$ is used to store authorisation
        constraints. The table is implemented as a list where each item is
        composed of the following fields: three authorisation expressions
        (the consequent, and the positive and negative premises) and an
        interval relation expression. Table \ref{tabl-impln-cntab} shows the
        structure of each node of this list.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              \textbf{Field} & \textbf{Type}          & \textbf{Description} \\
              \hline
              $exp$          & Expression Type        & Consequent \\
              \hline
              $pcn$          & Expression Type        & Positive Premise \\
              \hline
              $ncn$          & Expression Type        & Negative Premise \\
              \hline
              $rexp$         & Interval Relation List & {\em where} Clause \\
              \hline
            \end{tabular}
          \end{center}
          \caption{Constraints Table Node}
          \label{tabl-impln-cntab}
        \end{table}

        The interval relation list used by the constraints table is a list
        whose nodes are composed of two intervals and a relation set. The
        details of this structure is shown in Table \ref{tabl-impln-irlst}.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              \textbf{Field} & \textbf{Type}          & \textbf{Description} \\
              \hline
              $int_0$        & String                 & Interval \\
              \hline
              $int_1$        & String                 & Interval \\
              \hline
              $rs$           & Integer                & Relation Set \\
              \hline
            \end{tabular}
          \end{center}
          \caption{Interval Relation List Node}
          \label{tabl-impln-irlst}
        \end{table}

        Table \ref{tabl-impln-pdtab} shows the structure of each entry in the
        policy update declarations table $PB$.$updatetab$. This table is used
        by the policy base to store all policy update declarations. On the
        other hand, the policy update sequence $PB$.$seqtab$ is a list whose
        node structure is the same as those already shown in Table
        \ref{tabl-polup-pstab}.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|}
              \hline
              \textbf{Field} & \textbf{Type}          & \textbf{Description} \\
              \hline
              $name$         & String                 & Update Identifier \\
              \hline
              $vlist$        & Ordered String List    & Variables \\
              \hline
              $pre$          & Expression Type        & Precondition \\
              \hline
              $pst$          & Expression Type        & Postcondition \\
              \hline
              $rexp$         & Interval Relation List & {\em where} Clause \\
              \hline
            \end{tabular}
          \end{center}
          \caption{Policy Update Declarations Table Node}
          \label{tabl-impln-pdtab}
        \end{table}

        Lastly, the relation network field $PB$.$netwk$ is an instance of the
        interval relation network object described in Definition
        \ref{defn-impln-netop}.

      \subsection{Encoding Atoms}
        \label{subs-impln-encod}

        Recall that the $Encode$() function first introduced in Section
        \ref{subs-polup-norlp} takes as input an atom $\alpha$, a state
        $\sigma$ and a boolean term $\tau$ to indicate whether the fact is
        classically negated or not, and returns a positive integer $i$
        unique to these parameters:

        \begin{vquote}
          $i$ $=$ $Encode$($\alpha$, $\sigma$, $\tau$)
        \end{vquote}

        For example, given the fact $holds$($alice$, $exec$, $file$,
        $today$) which holds at state $S_0$ may be assigned the integer
        $0$ by the $Encode$ function. Similarly, the negation of the fact
        may be assigned the integer $1$, and so on:

        \begin{vquote}
          $0$ $=$ $Encode$($holds$($alice$, $exec$, $file$, $today$), $S_0$, $true$)

          $1$ $=$ $Encode$($holds$($alice$, $exec$, $file$, $today$), $S_0$, $false$)

          $2$ $=$ $Encode$($holds$($alice$, $exec$, $file$, $today$), $S_1$, $true$)

          $3$ $=$ $Encode$($holds$($alice$, $exec$, $file$, $today$), $S_1$, $false$)
        \end{vquote}

        Obviously, a consistent mapping between these integers and these
        facts are needed, and a systematic representation of facts is
        required to achieve and maintain this consistent mapping. Table
        \ref{tabl-impln-ftabl} shows a conceptual systematic arrangement of
        facts using the symbol table $\theta$ shown in Table
        \ref{tabl-impln-sytab}.

        \begin{table}[tbhp]
          \begin{center}
            \begin{tabular}[t]{|l|l|l|l|l|l|}
              \hline
              % head
              \multicolumn{2}{|l|}{\textbf{}} &
              \textbf{Entity 1} &
              \textbf{Entity 2} &
              \textbf{Entity 3} &
              \textbf{Interval} \\
              \hline
              % holds line 1
              \multicolumn{2}{|c|}{
                \multirow{3}{*}{
                  \begin{sideways}
                    \textbf{Holds}
                  \end{sideways}
                }
              } &
              $\theta$.$s$[$0$] &
              $\theta$.$a$[$0$] &
              $\theta$.$o$[$0$] &
              $\theta$.$int$[$0$] \\
              % holds line 2
              \multicolumn{2}{|c|}{} &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots \\
              % holds line 3
              \multicolumn{2}{|c|}{} &
              $\theta$.$s$[$|\theta$.$s|$-$1$] &
              $\theta$.$a$[$|\theta$.$a|$-$1$] &
              $\theta$.$o$[$|\theta$.$o|$-$1$] &
              $\theta$.$int$[$|\theta$.$int|$-$1$] \\
              \hline
              % sub memb line 1
              \multirow{3}{*}{
                \begin{sideways}
                  \textbf{Sub}
                \end{sideways}
              } &
              \multirow{9}{*}{
                \begin{sideways}
                  \textbf{Member}
                \end{sideways}
              } &
              $\theta$.$ss$[$0$] &
              $\theta$.$sg$[$0$] &
              &
              $\theta$.$int$[$0$] \\
              % sub memb line 2
              &
              &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              &
              \hspace{1em}\vdots \\
              % sub memb line 3
              &
              &
              $\theta$.$ss$[$|\theta$.$ss|$-$1$] &
              $\theta$.$sg$[$|\theta$.$sg|$-$1$] &
              &
              $\theta$.$int$[$|\theta$.$int|$-$1$] \\
              \cline{1-1}\cline{3-6}
              % acc memb line 1
              \multirow{3}{*}{
                \begin{sideways}
                  \textbf{Acc}
                \end{sideways}
              } &
              &
              $\theta$.$as$[$0$] &
              $\theta$.$ag$[$0$] &
              &
              $\theta$.$int$[$0$] \\
              % acc memb line 2
              &
              &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              &
              \hspace{1em}\vdots \\
              % acc memb line 3
              &
              &
              $\theta$.$as$[$|\theta$.$as|$-$1$] &
              $\theta$.$ag$[$|\theta$.$ag|$-$1$] &
              &
              $\theta$.$int$[$|\theta$.$int|$-$1$] \\
              \cline{1-1}\cline{3-6}
              % obj memb line 1
              \multirow{3}{*}{
                \begin{sideways}
                  \textbf{Obj}
                \end{sideways}
              } &
              &
              $\theta$.$os$[$0$] &
              $\theta$.$og$[$0$] &
              &
              $\theta$.$int$[$0$] \\
              % obj memb line 2
              &
              &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              &
              \hspace{1em}\vdots \\
              % obj memb line 3
              &
              &
              $\theta$.$os$[$|\theta$.$os|$-$1$] &
              $\theta$.$og$[$|\theta$.$og|$-$1$] &
              &
              $\theta$.$int$[$|\theta$.$int|$-$1$] \\
              \hline
              % sub subst line 1
              \multirow{3}{*}{
                \begin{sideways}
                  \textbf{Sub}
                \end{sideways}
              } &
              \multirow{9}{*}{
                \begin{sideways}
                  \textbf{Subset}
                \end{sideways}
              } &
              $\theta$.$sg$[$0$] &
              $\theta$.$sg$[$0$] &
              &
              $\theta$.$int$[$0$] \\
              % sub subst line 2
              &
              &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              &
              \hspace{1em}\vdots \\
              % sub subst line 3
              &
              &
              $\theta$.$sg$[$|\theta$.$sg|$-$1$] &
              $\theta$.$sg$[$|\theta$.$sg|$-$1$] &
              &
              $\theta$.$int$[$|\theta$.$int|$-$1$] \\
              \cline{1-1}\cline{3-6}
              % acc subst line 1
              \multirow{3}{*}{
                \begin{sideways}
                  \textbf{Acc}
                \end{sideways}
              } &
              &
              $\theta$.$ag$[$0$] &
              $\theta$.$ag$[$0$] &
              &
              $\theta$.$int$[$0$] \\
              % acc subst line 2
              &
              &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              &
              \hspace{1em}\vdots \\
              % acc subst line 3
              &
              &
              $\theta$.$ag$[$|\theta$.$ag|$-$1$] &
              $\theta$.$ag$[$|\theta$.$ag|$-$1$] &
              &
              $\theta$.$int$[$|\theta$.$int|$-$1$] \\
              \cline{1-1}\cline{3-6}
              % obj subst line 1
              \multirow{3}{*}{
                \begin{sideways}
                  \textbf{Obj}
                \end{sideways}
              } &
              &
              $\theta$.$og$[$0$] &
              $\theta$.$og$[$0$] &
              &
              $\theta$.$int$[$0$] \\
              % obj subst line 2
              &
              &
              \hspace{1em}\vdots &
              \hspace{1em}\vdots &
              &
              \hspace{1em}\vdots \\
              % obj subst line 3
              &
              &
              $\theta$.$og$[$|\theta$.$og|$-$1$] &
              $\theta$.$og$[$|\theta$.$og|$-$1$] &
              &
              $\theta$.$int$[$|\theta$.$int|$-$1$] \\
              \hline
            \end{tabular}
          \end{center}
          \caption{Conceptual Arrangement of Facts}
          \label{tabl-impln-ftabl}
        \end{table}

        Table \ref{tabl-impln-ftabl} shows all the possible combinations of
        all entity and interval identifiers defined in the symbol table to
        form all possible facts in one state. Note that the order in which
        the facts are enumerated may be used as an index for each fact. For
        example, using the last single access right
        $\theta$.$as$[$|$$\theta$.$as$$|$-$1$], the last group access
        right $\theta$.$ag$[$|$$\theta$.$ag$$|$-$1$] and the last interval
        $\theta$.$int$[$|$$\theta$.$int$$|$-$1$] from the symbol table,
        we form the following fact:

        \begin{vquote}
          $memb$($\theta$.$as$[$|$$\theta$.$as$$|$-$1$],
            $\theta$.$ag$[$|$$\theta$.$ag$$|$-$1$],
            $\theta$.$int$[$|$$\theta$.$int$$|$-$1$])
        \end{vquote}

        \noindent
        The index of the fact above can be derived by considering the
        enumerated order of this fact from Table \ref{tabl-impln-ftabl},
        and the fixed order of the symbol table $\theta$:

        \begin{vquote}
          (
            $|$$\theta$.$s$$|$ $\times$
            $|$$\theta$.$a$$|$ $\times$
            $|$$\theta$.$o$$|$ $\times$
            $|$$\theta$.$int$$|$
          ) $+$

          (
            $|$$\theta$.$ss$$|$ $\times$
            $|$$\theta$.$sg$$|$ $\times$
            $|$$\theta$.$int$$|$
          ) $+$

          (
            $|$$\theta$.$as$$|$ $\times$
            $|$$\theta$.$ag$$|$ $\times$
            $|$$\theta$.$int$$|$
          ) $-$ $1$
        \end{vquote}

        Note that in Table \ref{tabl-impln-ftabl}, the indices of positive
        member facts are offset by the total number of positive holds
        facts ($|$$\theta$.$s$$|$ $\times$ $|$$\theta$.$a$$|$ $\times$
        $|$$\theta$.$o$$|$ $\times$ $|$$\theta$.$int$$|$) and the indices of
        positive access right member facts are offset by the total number of
        positive holds facts plus the total number of positive subject
        member facts ($|$$\theta$.$s$$|$ $\times$ $|$$\theta$.$a$$|$ $\times$
        $|$$\theta$.$o$$|$ $\times$ $|$$\theta$.$int$$|$ $+$
        $|$$\theta$.$ss$$|$ $\times$ $|$$\theta$.$sg$$|$ $\times$
        $|$$\theta$.$int$$|$). For notational simplicity, we define the
        following totals of atoms:

        \begin{vquote}
          $Tot_A$ $=$ $Tot_H$ $+$ $Tot_M$ $+$ $Tot_S$
        \end{vquote}

        \begin{vquote}
          $Tot_H$ $=$
            $|$$\theta$.$s$$|$ $\times$
            $|$$\theta$.$a$$|$ $\times$
            $|$$\theta$.$o$$|$ $\times$
            $|$$\theta$.$int$$|$
        \end{vquote}

        \begin{vquote}
          $Tot_M$ $=$

            \hspace{1em}
            (
              $|$$\theta$.$ss$$|$ $\times$
              $|$$\theta$.$sg$$|$ $\times$
              $|$$\theta$.$int$$|$
            ) $+$

            \hspace{1em}
            (
              $|$$\theta$.$as$$|$ $\times$
              $|$$\theta$.$ag$$|$ $\times$
              $|$$\theta$.$int$$|$
            ) $+$

            \hspace{1em}
            (
              $|$$\theta$.$os$$|$ $\times$
              $|$$\theta$.$og$$|$ $\times$
              $|$$\theta$.$int$$|$
            )
        \end{vquote}

        \begin{vquote}
          $Tot_S$ $=$

            \hspace{1em}
            (
              $|$$\theta$.$sg$$|$ $\times$
              $|$$\theta$.$sg$$|$ $\times$
              $|$$\theta$.$int$$|$
            ) $+$

            \hspace{1em}
            (
              $|$$\theta$.$ag$$|$ $\times$
              $|$$\theta$.$ag$$|$ $\times$
              $|$$\theta$.$int$$|$
            ) $+$

            \hspace{1em}
            (
              $|$$\theta$.$og$$|$ $\times$
              $|$$\theta$.$og$$|$ $\times$
              $|$$\theta$.$int$$|$
            )
        \end{vquote}

        With the totals above defined, the offsetting procedure can be
        extended to find the indices of both positive and negative facts. The
        index of a negative fact is offset by $Tot_A$, the total number of
        positive facts. For example, given the first negative subject subset
        fact:

        \begin{vquote}
          $\lnot$$subst$($\theta$.$sg$[$0$], $\theta$.$sg$[$0$], $\theta$.$int$[$0$])
        \end{vquote}

        \noindent
        The index of the above fact is:

        \begin{vquote}
          $Tot_A$ $+$ $Tot_H$ $+$ $Tot_M$
        \end{vquote}

        So far, we have seen that this technique is effective in encoding
        positive and negative facts in one state only. However, this
        procedure can be further extended to assign indices to facts in
        different states. First, we assume that the integers $0$ to
        ($2$ $\times$ $Tot_A$) - $1$ maps to positive and negative facts of
        state $S_0$. We can then assign integers ($2$ $\times$ $Tot_A$) to
        ($4$ $\times$ $Tot_A$) - $1$ to the positive and negative facts of
        state $S_1$. In general, facts of state $\sigma$ are offset by the
        facts of state $\sigma$ - $1$.

        Algorithm \ref{algo-impln-encod} shows the implementation of the
        $Encode$() function using this technique. The first thing the
        that the function does is to calculate the offset of the atom
        $\alpha$ based on the given state $\sigma$ and the truth
        indicator $\tau$. The function then takes the ordinal index of each
        entity and interval in the atom from the symbol table $\theta$.
        Depending on the atom type, the $Encode$() then uses one of
        $Offset\_Holds$(), $Offset\_Memb$() or $Offset\_Subst$() with the
        indices to calculate the appropriate offsets.

        \begin{valgorithm}{Encode()}{algo-impln-encod}
FUNCTION \(Encode\)(\(\alpha\), \(\sigma\), \(\tau\))
  \(offset\) = \(\sigma\) \(\cdot\) \(Tot\sb{A}\) \(\cdot\) \(2\)
  IF \(\tau\) == \(false\) THEN
    \(offset\) = \(offset\) \(+\) \(Tot\sb{A}\)
  ENDIF
  CASE \(\alpha\).\(type\) OF
    \(holds\) :
      \(s\) = \(\theta\sb{s}\).\(index\_of\)(\(\alpha\).\(holds\).\(sub\))
      \(a\) = \(\theta\sb{a}\).\(index\_of\)(\(\alpha\).\(holds\).\(acc\))
      \(o\) = \(\theta\sb{o}\).\(index\_of\)(\(\alpha\).\(holds\).\(obj\))
      \(i\) = \(\theta\sb{int}\).\(index\_of\)(\(\alpha\).\(holds\).\(int\))
      RETURN \(offset\) \(+\) \(Offset\_Holds\)(\(s\), \(a\), \(o\), \(i\))
    \(member\) :
      CASE \(\alpha\).\(memb\).\(type\) OF
        \(sub\) :
          \(e\) = \(\theta\sb{ss}\).\(index\_of\)(\(\alpha\).\(memb\).\(elt\))
          \(g\) = \(\theta\sb{sg}\).\(index\_of\)(\(\alpha\).\(memb\).\(grp\))
        \(acc\) :
          \(e\) = \(\theta\sb{as}\).\(index\_of\)(\(\alpha\).\(memb\).\(elt\))
          \(g\) = \(\theta\sb{ag}\).\(index\_of\)(\(\alpha\).\(memb\).\(grp\))
        \(obj\) :
          \(e\) = \(\theta\sb{os}\).\(index\_of\)(\(\alpha\).\(memb\).\(elt\))
          \(g\) = \(\theta\sb{og}\).\(index\_of\)(\(\alpha\).\(memb\).\(grp\))
      ENDCASE
      \(i\) = \(\theta\sb{int}\).\(index\_of\)(\(\alpha\).\(memb\).\(int\))
      RETURN \(offset\) \(+\) \(Offset\_Memb\)(\(e\), \(g\), \(i\), \(\alpha\).\(memb\).\(type\))
    \(subset\) :
      CASE \(\alpha\).\(subst\).\(type\) OF
        \(sub\) :
          \(g\sb{0}\) = \(\theta\sb{sg}\).\(index\_of\)(\(\alpha\).\(subst\).\(grp\sb{0}\))
          \(g\sb{1}\) = \(\theta\sb{sg}\).\(index\_of\)(\(\alpha\).\(subst\).\(grp\sb{1}\))
        \(acc\) :
          \(g\sb{0}\) = \(\theta\sb{ag}\).\(index\_of\)(\(\alpha\).\(subst\).\(grp\sb{0}\))
          \(g\sb{1}\) = \(\theta\sb{ag}\).\(index\_of\)(\(\alpha\).\(subst\).\(grp\sb{1}\))
        \(obj\) :
          \(g\sb{0}\) = \(\theta\sb{ag}\).\(index\_of\)(\(\alpha\).\(subst\).\(grp\sb{0}\))
          \(g\sb{1}\) = \(\theta\sb{ag}\).\(index\_of\)(\(\alpha\).\(subst\).\(grp\sb{1}\))
      ENDCASE
      \(i\) = \(\theta\sb{int}\).\(index\_of\)(\(\alpha\).\(subst\).\(int\))
      RETURN \(offset\) \(+\) \(Offset\_Subst\)(\(g\sb{0}\), \(g\sb{1}\), \(i\), \(\alpha\).\(subst\).\(type\))
  ENDCASE
ENDFUNCTION
        \end{valgorithm}

        The $Offset\_Holds$() function shown in Algorithm
        \ref{algo-impln-offho} calculates the offset for atoms of type holds by
        using the given indices of its elements. As discussed above, the
        subject offset of a holds atom is obtained by multiplying the actual
        subject index $sub$ by the total number of access rights by the total
        number of objects by the total number of intervals defined in the
        symbol table. Similarly, the access right offset is calculated by
        multiplying the actual access right index $acc$ by the remaining
        elements: the total number of objects and the total number of
        intervals. The offsets for objects and intervals are calculated in the
        same manner. Finally, the sum of these offsets is the offset for the
        holds atom, which is returned by this function.

        \begin{valgorithm}{Offset\_Holds()}{algo-impln-offho}
FUNCTION \(Offset_Holds\)(\(sub\), \(acc\), \(obj\), \(int\))
  RETURN
    (\(sub\) \(\cdot\) (\(|\)\(\theta\).\(as\)\(|\) \(+\) \(|\)\(\theta\).\(ag\)\(|\)) \(\cdot\) (\(|\)\(\theta\).\(os\)\(|\) \(+\) \(|\)\(\theta\).\(og\)\(|\)) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
    (\(acc\) \(\cdot\) (\(|\)\(\theta\).\(os\)\(|\) \(+\) \(|\)\(\theta\).\(og\)\(|\)) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
    (\(obj\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
    \(int\)
ENDFUNCTION
        \end{valgorithm}

        The calculation of the offset for member atoms as shown in Algorithm
         \ref{algo-impln-offme} uses a similar method, except each type
        (subject, access right and object) is handled in a different way.
        Firstly, the access right index is offset by the total number of
        subject member atoms ($|$$\theta$.$ss$$|$ $\cdot$ $|$$\theta$.$sg$$|$
        $\cdot$ $|$$\theta$.$int$). The index for member atoms of type object
        are similarly offset by the total number of subject and access right
        member atoms ($|$$\theta$.$ss$$|$ $\cdot$ $|$$\theta$.$sg$$|$
        $\cdot$ $|$$\theta$.$int$$|$ $+$ $|$$\theta$.$as$$|$ $\cdot$
        $|$$\theta$.$ag$$|$ $\cdot$ $|$$\theta$.$int$). Furthermore, the
        index of all atoms of type member is offset by the total number of
        holds atoms ($Tot_H$).

        \begin{valgorithm}{Offset\_Memb()}{algo-impln-offme}
FUNCTION \(Offset_Memb\)(\(elt\), \(grp\), \(int\), \(type\))
  CASE \(type\) OF
    \(sub\) :
      \(offset\) =
        (\(elt\) \(\cdot\) \(|\)\(\theta\).\(sg\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        \(int\)
    \(acc\) :
      \(offset\) =
        (\(|\)\(\theta\).\(ss\)\(|\) \(\cdot\) \(|\)\(\theta\).\(sg\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(elt\) \(\cdot\) \(|\)\(\theta\).\(ag\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        \(int\)
    \(obj\) :
      \(offset\) =
        (\(|\)\(\theta\).\(ss\)\(|\) \(\cdot\) \(|\)\(\theta\).\(sg\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(|\)\(\theta\).\(as\)\(|\) \(\cdot\) \(|\)\(\theta\).\(ag\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(elt\) \(\cdot\) \(|\)\(\theta\).\(og\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        \(int\)
  ENDCASE

  RETURN \(Tot\sb{H}\) \(+\) \(offset\)
ENDFUNCTION
        \end{valgorithm}

        Algorithm \ref{algo-impln-offsu} shows how the $Offset\_Subst$()
        function calculates the offset for subset atoms. The method is
        similar to that used by the $Offset\_Memb$() function, except the
        final index is offset by the total number of holds and member atoms.

        \begin{valgorithm}{Offset\_Subst()}{algo-impln-offsu}
FUNCTION \(Off_Subst\)(\(grp\sb{0}\), \(grp\sb{1}\), \(int\), \(type\))
  CASE \(type\) OF
    \(sub\) :
      \(offset\) =
        (\(grp\sb{0}\) \(\cdot\) \(|\)\(\theta\).\(sg\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\sb{1}\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        \(int\)
    \(acc\) :
      \(offset\) =
        (\(|\)\(\theta\).\(sg\)\(|\sp{2}\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\sb{0}\) \(\cdot\) \(|\)\(\theta\).\(ag\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\sb{1}\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        \(int\)
    \(obj\) :
      \(offset\) \(=\)
        (\(|\)\(\theta\).\(sg\)\(|\sp{2}\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(|\)\(\theta\).\(ag\)\(|\sp{2}\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\sb{0}\) \(\cdot\) \(|\)\(\theta\).\(og\)\(|\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        (\(grp\sb{1}\) \(\cdot\) \(|\)\(\theta\).\(int\)\(|\)) \(+\)
        \(int\)
  ENDCASE

  RETURN \(Tot\sb{H}\) \(+\) \(Tot\sb{M}\) \(+\) \(offset\)
ENDFUNCTION
        \end{valgorithm}

      \subsection{Populating the Policy Base}
        \label{subs-impln-poppb}

        Now, we describe the process of storing the different components of the
        policy into the policy base structures shown in Section
        \ref{subs-impln-dstru}. In this section, this process is broken up into
        several policy base operators that the policy parser can call as it
        parses a language ${\cal L^T}$ policy.

        \subsubsection{Registering Entities and Intervals}

          Before the policy base can be made to perform any task, it must first
          be made aware of all entities and intervals defined in the policy.
          The operators $PB$.$AddEntity$(), $PB$.$AddInterval$() and
          $PB$.$AddIntervalEP$() are called by the parser as it goes through
          the entity and interval declarations of the policy.

          The $PB$.$AddEntity$($id$, $type$) function shown in Algorithm
          \ref{algo-impln-adent} registers the identifier $id$ of type $type$
          to the appropriate list in the symbol table.

          \begin{valgorithm}{PB.AddEntity()}{algo-impln-adent}
FUNCTION \(PB\).\(AddEntity\)(\(id\), \(type\))
  CASE \(type\) OF
    \(sub\)-\(sin\) :
      \(PB\).\(symtab\).\(ss\).\(Add\)(\(id\))
    \(sub\)-\(grp\) :
      \(PB\).\(symtab\).\(sg\).\(Add\)(\(id\))
    \(acc\)-\(sin\) :
      \(PB\).\(symtab\).\(as\).\(Add\)(\(id\))
    \(acc\)-\(grp\) :
      \(PB\).\(symtab\).\(ag\).\(Add\)(\(id\))
    \(obj\)-\(sin\) :
      \(PB\).\(symtab\).\(os\).\(Add\)(\(id\))
    \(obj\)-\(grp\) :
      \(PB\).\(symtab\).\(og\).\(Add\)(\(id\))
  ENDCASE
ENDFUNCTION
          \end{valgorithm}

          Algorithm \ref{algo-impln-adint} shows the $PB$.$AddInterval$($id$)
          operator which registers the interval identifier $id$ to the
          interval list in the symbol table and the interval network object.
          If the parser encounters a declaration of a well-defined interval,
          it makes a call to the $PB$.$AddIntervalEP$() function (Algorithm
          \ref{algo-impln-adine}) instead. This function registers the interval
          identifier to both the symbol table and the network object, then
          binds the interval with the given end points in the network object.

          \begin{valgorithm}{PB.AddInterval()}{algo-impln-adint}
FUNCTION \(PB\).\(AddInterval\)(\(id\))
  \(PB\).\(symtab\).\(int\).\(Add\)(\(id\));
  \(PB\).\(netwk\).\(AddInt\)(\(id\));
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{PB.AddIntervalEP()}{algo-impln-adine}
FUNCTION \(PB\).\(AddIntervalEP\)(\(id\), \(ep\sb{0}\), \(ep\sb{1}\))
  \(PB\).\(AddInterval\)(\(id\))
  \(PB\).\(netwk\).\(Bind\)(\(id\), \(ep\sb{0}\), \(ep\sb{1}\))
ENDFUNCTION
          \end{valgorithm}

        \subsubsection{Adding Temporal Interval Constraints}

          When the parser encounters a temporal constraint, the
          $PB$.$AddRelation$() operator shown in Algorithm
          \ref{algo-impln-adrel} is called. The operator normalises the given
          interval expression first before passing it on to the network object
          one relation at a time. Note that as shown in Algorithm
          \ref{algo-impln-ntadr}, the effects of each added relation is
          propagated to the entire network.

          \begin{valgorithm}{PB.AddRelation()}{algo-impln-adrel}
FUNCTION \(PB\).\(AddRelation\)(\(rexp\))
  \(rlist\) = \(NormaliseExp\)(\(rexp\))
  FOR \(i\) = \(0\) TO (\(|rlist|\) - \(1\)) DO
    \(PB\).\(netwk\).\(AddRel\)(\(rlist\)[\(i\)].\(int\sb{0}\), \(rlist\)[\(i\)].\(int\sb{1}\), \(rlist\)[\(i\)].\(rs\))
  ENDDO
ENDFUNCTION
          \end{valgorithm}

        \subsubsection{Adding Authorisation Statements}

          Algorithms \ref{algo-impln-adini}, \ref{algo-impln-adcon} and
          \ref{algo-impln-adupd} are called by the parser to register initial
          state rules, authorisation constraint rules and policy update
          declarations, respectively. While the $PB$.$AddInitially$() operator
          simply adds the initial expression to the initial facts table
          one fact at a time, the $PB$.$AddConstraint$() and $PB$.$AddUpdate$()
          operators add their entries directly into the appropriate table
          in the policy base.

          \begin{valgorithm}{PB.AddInitially()}{algo-impln-adini}
FUNCTION \(PB\).\(AddInitially\)(\(exp\))
  FOR \(i\) = \(0\) TO (\(|exp|\) - \(1\)) DO
    \(PB\).\(inittab\).\(Add\)(\(exp\)[\(i\)])
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{PB.AddConstraint()}{algo-impln-adcon}
FUNCTION \(PB\).\(AddConstraint\)(\(exp\sb{0}\), \(exp\sb{1}\), \(exp\sb{2}\), \(rexp\))
  \(cnode\) = (\(exp\sb{0}\), \(exp\sb{1}\), \(exp\sb{2}\), \(NormaliseExp\)(\(rexp\)))
  \(PB\).\(consttab\).\(Add\)(\(cnode\))
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{PB.AddUpdate()}{algo-impln-adupd}
FUNCTION \(PB\).\(AddUpdate\)(\(u\), \(exp\sb{0}\), \(exp\sb{1}\), \(rexp\))
  \(unode\) = (\(u\), \(exp\sb{0}\), \(exp\sb{1}\), \(NormaliseExp\)(\(rexp\)))
  \(PB\).\(updatetab\).\(Add\)(\(unode\))
ENDFUNCTION
          \end{valgorithm}

        \subsubsection{Policy Update Sequence Manipulation}

          Algorithms \ref{algo-impln-adseq}, \ref{algo-impln-deseq} and
          \ref{algo-impln-lsseq} are the policy base operators that correspond
          to the {\em seq add}, {\em seq del} and {\em seq list} language
          ${\cal L^T}$ statements, respectively.

          \begin{valgorithm}{PB.AddSequence()}{algo-impln-adseq}
FUNCTION \(PB\).\(AddSequence\)(\(u\), \(ilist\))
  \(snode\) = (\(u\), \(ilist\))
  \(PB\).\(seqtab\).\(Add\)(\(snode\))
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{PB.DelSequence()}{algo-impln-deseq}
FUNCTION \(PB\).\(DelSequence\)(\(index\))
  \(PB\).\(seqtab\).\(Del\)(\(index\))
ENDFUNCTION
          \end{valgorithm}

          \begin{valgorithm}{PB.ListSequence()}{algo-impln-lsseq}
FUNCTION \(PB\).\(ListSequence\)(\(\))
  RETURN \(PB\).\(seqtab\)
ENDFUNCTION
          \end{valgorithm}

      \subsection{Calculating the Answer Set}

        Once the policy update sequence table has been populated by the
        sequence manipulation operators described above, the policy base must
        be made to generate answer sets based on the stored policies and
        updates. The answer sets must be generated prior to any query
        evaluation requests. This process, of course, is triggered by the
        parser when it encounters the {\em compute} statement in the language
        ${\cal L^T}$ policy.

        The $GenNLP$() function in Algorithm \ref{algo-polup-genlp} and the
        rest of the functions in Section \ref{subs-polup-norlp} illustrates
        how a language ${\cal L}$ domain is translated into a normal logic
        program and from answer sets derived from that normal logic program,
        how queries are evaluated. This section focuses on extending these
        methods to generate answer sets from language ${\cal L^T}$ domains, as
        well as showing how these techniques are applied to the policy base
        structures.

        Firstly, we need to formally define a stable models object capable
        of generating answer sets from normal logic programs. Definition
        \ref{defn-impln-smobj} formalises a suitable object based on the
        interface provided by the {\em SModels} system in \cite{NIE,SIM2}.

        \begin{vdefinition}
          \label{defn-impln-smobj}

          An SModels object $SM$ is a stable models implementation with
          support for the following operations:

          \begin{enumerate}
            \item
              $SM$.$Init$() initialises the object. Any previous operations are
              reset.

            \item
              $SM$.$RuleBegin$() marks the beginning of a rule.

            \item
              $SM$.$RuleHead$($\alpha$) registers the atom $\alpha$ as the
              head of the rule.

            \item
              $SM$.$RuleBody$($\alpha$, $\tau$) registers the atom $\alpha$,
              whose negation-as-failure value is $\tau$, as a body of the
              current rule.

            \item
              $SM$.$RuleEnd$() marks the ending of the current rule.

            \item
              $SM$.$GetAnswerSets$() returns a list of answer sets.
          \end{enumerate}
        \end{vdefinition}

        With the stable model object defined, we can now define the policy
        base operation that generates an answer set based on the policy
        stored. Algorithm \ref{algo-impln-genas} shows the policy base
        operation that extends the original $GenNLP$() function to
        generate an answer set.

        \begin{valgorithm}{PB.GenAnswerSets()}{algo-impln-genas}
FUNCTION \(PB\).\(GenAnswerSets\)()
  \(SM\).\(Init\)()
  \(TransInitStateRules\)(\(PB\).\(inittab\), \(SM\))
  \(TransConstRules\)(\(PB\).\(consttab\), \(PB\).\(symtab\), \(PB\).\(seqtab\),
    \(PB\).\(netwk\), \(SM\))
  \(TransUpdateRules\)(\(PB\).\(updatetab\), \(PB\).\(symtab\), \(PB\).\(seqtab\),
    \(PB\).\(netwk\), \(SM\))
  \(GenInherRules\)(\(PB\).\(symtab\), \(PB\).\(seqtab\), \(SM\))
  \(GenTransRules\)(\(PB\).\(symtab\), \(PB\).\(seqtab\), \(SM\))
  \(GenInertRules\)(\(PB\).\(symtab\), \(PB\).\(seqtab\), \(SM\))
  \(GenRefleRules\)(\(PB\).\(symtab\), \(PB\).\(seqtab\), \(SM\))
  \(GenTempoRules\)(\(PB\).\(symtab\), \(PB\).\(seqtab\), \(PB\).\(netwk\), \(SM\))
  \(GenConsiRules\)(\(PB\).\(symtab\), \(PB\).\(seqtab\), \(SM\))
  RETURN \(SM\).\(GetAnswerSets\)()
ENDFUNCTION
        \end{valgorithm}

        Note that most of the functions called by \(PB\).\(GenAnswerSets\)()
        are similar to the functions defined in Section
        \ref{subs-polup-norlp}. These functions require only little
        modifications to generate a normal logic program from a language
        ${\cal L^T}$ domain. In fact, the only major difference is
        that the new functions must support the language ${\cal L^T}$ atoms
        that include an additional temporal interval parameter. This means
        that most of the rule-generating functions are extended simply by
        the addition of an extra interval loop, which passes intervals to the
        new $Encode$() function discussed in Section \ref{subs-impln-encod}.

        \subsubsection{Generating Temporal Rules}

          Recall that Section \ref{subs-tempo-seman} has shown that translating
          a language ${\cal L^T}$ domain to a normal logic program requires the
          generation of temporal relation rules. The semantics of the language
          tells us that the purpose of these rules is to assert that an atom
          that holds in a particular time interval $\iota$ must also hold in
          every other interval $\iota'$ that is "within" $\iota$, that is,
          $\iota'$ is {\em equal}, is {\em during}, {\em starts} or
          {\em finishes} $\iota$. Algorithm \ref{algo-impln-gente} shows the
          $GenTempoRules$() function which generates these rules.

          \begin{valgorithm}{GenTempoRules()}{algo-impln-gente}
FUNCTION \(GenTempoRules\)(\(\theta\), \(\psi\), \(NET\), \(SM\))
  \(GenHldsTempoRules\)(\(\theta\), \(\psi\), \(NET\), \(SM\))
  \(GenMembTempoRules\)(\(\theta\), \(\psi\), \(NET\), \(SM\))
  \(GenSubsTempoRules\)(\(\theta\), \(\psi\), \(NET\), \(SM\))
ENDFUNCTION
          \end{valgorithm}

          The $GenHldsTempoRules$() function shown in Algorithm
          \ref{algo-impln-ghdtr}, as the name implies, generates the temporal
          rules for {\em holds} atoms. The first loop goes through every policy
          update state while the next 3 loops goes through all defined
          entities. The fifth and sixth loop goes through all possible pairs
          of intervals defined in the symbol table.

          Inside these loops, the relation between the interval pair is
          retrieved from the interval network structure. The if-statement
          ensures that one interval is "within" the other. The number $101$ is
          the sum of the values of the relations {\em equals}, {\em during},
          {\em starts} and {\em finishes} as defined in Table
          \ref{tabl-impln-valas}. Thus, if the relation between the pair of
          intervals is a subset of the relation set \{{\em equal},
          {\em during}, {\em starts}, {\em finishes}\}, the holds temporal
          rules are generated. A similar method is used for the other two
          functions $GenMembTempoRules$() and $GenSubsTempoRules$().

          \begin{valgorithm}{GenHldsTempoRules()}{algo-impln-ghdtr}
FUNCTION \(GenHldsTempoRules\)(\(\theta\), \(\psi\), \(NET\), \(SM\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\)\(\theta\).\(s\)\(|\) - \(1\)) DO
      FOR \(k\) = \(0\) TO (\(|\)\(\theta\).\(a\)\(|\) - \(1\)) DO
        FOR \(l\) = \(0\) TO (\(|\)\(\theta\).\(o\)\(|\) - \(1\)) DO
          FOR \(m\) = \(0\) TO (\(|\)\(\theta\).\(int\)\(|\) - \(1\)) DO
            FOR \(n\) = \(0\) TO (\(|\)\(\theta\).\(int\)\(|\) - \(1\)) DO
              \(rs\) = \(NET\).\(get\)(\(m\), \(n\))
              IF (\(rs\) | \(101\)) == \(101\) THEN
                \(\alpha\sb{0}\) = \{\(\theta\).\(s\)[\(j\)], \(\theta\).\(a\)[\(k\)], \(\theta\).\(o\)[\(l\)], \(\theta\).\(int\)[\(n\)]\}
                \(\alpha\sb{1}\) = \{\(\theta\).\(s\)[\(j\)], \(\theta\).\(a\)[\(k\)], \(\theta\).\(o\)[\(l\)], \(\theta\).\(int\)[\(m\)]\}
                \(SM\).\(RuleBegin\)()
                \(SM\).\(RuleHead\)(\(Encode\)(\(\alpha\sb{0}\), \(i\), \(true\)))
                \(SM\).\(RuleBody\)(\(Encode\)(\(\alpha\sb{1}\), \(i\), \(true\)), \(true\))
                \(SM\).\(RuleEnd\)()
                \(SM\).\(RuleBegin\)()
                \(SM\).\(RuleHead\)(\(Encode\)(\(\alpha\sb{0}\), \(i\), \(false\)))
                \(SM\).\(RuleBody\)(\(Encode\)(\(\alpha\sb{1}\), \(i\), \(false\)), \(true\))
                \(SM\).\(RuleEnd\)()
              ENDIF
          ENDDO
        ENDDO
      ENDDO
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

        \subsubsection{Translating Constraint and Policy Update Rules}

          The language ${\cal L}$ versions of the $TransConstRules$() and
          $TransUpdateRules$() functions defined in Algorithm
          \ref{algo-polup-tconr} and Algorithm \ref{algo-polup-tupdr} assume
          that expressions are already grounded. In this section, we extend
          these functions to handle the interval relations of language
          ${\cal L^T}$ as well as ground variables.

          First, we define the following functions to be used to ground the
          variables:

          \begin{itemize}
            \item
              $GetVList$($exp$) returns a list of variable identifiers
              that occur in the given expression $exp$.

            \item
              $GenTupleList$($vlist$) returns a list of tuples, given a list of
              variables $vlist$. Each tuple in the returned list contains
              entities and intervals of the same type as the corresponding
              variable in $vlist$.

            \item
              $CheckTuple$($tuple$, $rlist$, $NET$) returns {\em true} if the
              intervals in $tuple$ satisfy the interval relations specified in
              $rlist$.

            \item
              $Replace$($vlist$, $tuple$, $exp$). Given a list of
              variables $vlist$, a list of entities and intervals $tuple$ and
              an expression $exp$, the function returns the expression
              $\epsilon$ with all variables in $vlist$ replaced by
              corresponding entities and intervals from $tuple$.
          \end{itemize}

          The $TransConstRules$() function shown in Algorithm
          \ref{algo-impln-traco} starts by creating a list of variables
          $vlist$ that occurs in the constraint expressions. With this list,
          a list of tuples $tlist$ is generated by the use of the
          $GenTupleList$() function. As the algorithm goes through each tuple
          in $tlist$, it checks whether the intervals in the current tuple
          satisfies the temporal constraints associated with the current
          constraint rule. If the tuple is valid, the algorithm then uses
          this to ground all the variables in the expressions. Once grounded,
          the expressions are passed to the $SM$ object to construct the
          normal logic program rule.

          \begin{valgorithm}{TransConstRules()}{algo-impln-traco}
FUNCTION \(TransConstRules\)(\(\omega\), \(\theta\), \(\psi\), \(NET\), \(SM\))
  FOR \(i\) = \(0\) TO (\(|\omega|\) - \(1\)) DO
    \(vlist\).\(Init\)()
    \(vlist\).\(Append\)(\(GetVList\)(\(\omega\)[\(i\)].\(exp\))
    \(vlist\).\(Append\)(\(GetVList\)(\(\omega\)[\(i\)].\(pcn\))
    \(vlist\).\(Append\)(\(GetVList\)(\(\omega\)[\(i\)].\(ncn\))
    \(tlist\) = \(GenTupleList\)(\(\theta\), \(vlist\))
    \(rlist\) = \(NormaliseExp\)(\(\omega\)[\(i\)].\(rexp\))
    FOR \(j\) = \(0\) TO (\(|tlist|\) - \(1\)) DO
      IF \(CheckTuple\)(\(tlist\)[\(j\)], \(rlist\), \(NET\)) THEN
        \(\epsilon\sb{0}\) = \(Replace\)(\(vlist\), \(tlist\)[\(j\)], \(\omega\)[\(i\)].\(exp\))
        \(\epsilon\sb{1}\) = \(Replace\)(\(vlist\), \(tlist\)[\(j\)], \(\omega\)[\(i\)].\(pcn\))
        \(\epsilon\sb{2}\) = \(Replace\)(\(vlist\), \(tlist\)[\(j\)], \(\omega\)[\(i\)].\(ncn\))
        FOR \(k\) = \(0\) TO (\(|\theta|\) - \(1\)) DO
          FOR \(l\) = \(0\) TO (\(|\epsilon\sb{0}|\) - \(1\)) DO
            \(SM\).\(RuleBegin\)()
            \(\alpha\) = \(Encode\)(\(\epsilon\sb{0}\)[\(l\)].\(atom\), \(k\), \(\epsilon\sb{0}\)[\(l\)].\(truth\))
            \(SM\).\(RuleHead\)(\(\alpha\))
            FOR \(m\) = \(0\) TO (\(|\epsilon\sb{1}|\) - \(1\)) DO
              \(\alpha\) = \(Encode\)(\(\epsilon\sb{1}\)[\(m\)].\(atom\), \(k\), \(\epsilon\sb{1}\)[\(m\)].\(truth\))
              \(SM\).\(RuleBody\)(\(\alpha\), \(true\))
            ENDDO
            FOR \(n\) = \(0\) TO (\(|\epsilon\sb{2}|\) - \(1\)) DO
              \(\alpha\) = \(Encode\)(\(\epsilon\sb{2}\)[\(n\)].\(atom\), \(k\), \(\epsilon\sb{2}\)[\(n\)].\(truth\))
              \(SM\).\(RuleBody\)(\(\alpha\), \(false\))
            ENDDO
            \(SM\).\(RuleEnd\)()
          ENDDO
        ENDDO
      ENDIF
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

          A similar method is used by the $TransUpdateRules$() function
          shown in Algorithm \ref{algo-impln-traup}.

          \begin{valgorithm}{TransUpdateRules()}{algo-impln-traup}
FUNCTION \(TransUpdateRules\)(\(\omega\), \(\theta\), \(\psi\), \(NET\), \(SM\))
  FOR \(i\) = \(0\) TO (\(|\psi|\) - \(1\)) DO
    FOR \(j\) = \(0\) TO (\(|\omega|\) - \(1\)) DO
      IF \(\psi\)[\(i\)].\(name\) == \(\omega\)[\(j\)].\(name\) THEN
        \(upd\) = \(GndUpdate\)(\(\omega\)[\(j\)], \(\psi\)[\(i\)].\(ilist\))
        \(vlist\).\(Init\)()
        \(vlist\).\(Append\)(\(GetVList\)(\(upd\).\(pre\))
        \(vlist\).\(Append\)(\(GetVList\)(\(upd\).\(pst\))
        \(tlist\) = \(GenTupleList\)(\(\theta\), \(vlist\))
        \(rlist\) = \(NormaliseExp\)(\(\omega\)[\(j\)].\(rexp\))
        FOR \(k\) = \(0\) TO (\(|tlist|\) - \(1\)) DO
          IF \(CheckTuple\)(\(tlist\)[\(k\)], \(rlist\), \(NET\)) THEN
            \(\epsilon\sb{0}\) = \(Replace\)(\(vlist\), \(tlist\)[\(k\)], \(upd\).\(pre\))
            \(\epsilon\sb{1}\) = \(Replace\)(\(vlist\), \(tlist\)[\(k\)], \(upd\).\(pst\))
            FOR \(l\) = \(0\) TO (\(|\)\(\epsilon\sb{1}\)\(|\) - \(1\)) DO
              \(\alpha\) = \(Encode\)(\(\epsilon\sb{1}\)[\(l\)].\(atom\), \(i\) + \(1\), \(\epsilon\sb{1}\)[\(l\)].\(truth\))
              \(SM\).\(RuleBegin\)()
              \(SM\).\(RuleHead\)(\(\alpha\))
              FOR \(m\) = \(0\) TO (\(|\)\(\epsilon\sb{0}\)\(|\) - \(1\)) DO
                \(\alpha\) = \(Encode\)(\(\epsilon\sb{0}\)[\(l\)].\(atom\), \(i\), \(\epsilon\sb{0}\)[\(l\)].\(truth\))
                \(SM\).\(RuleBody\)(\(\alpha\), \(true\))
              ENDDO
              \(SM\).\(RuleEnd\)()
            ENDDO
          ENDIF
        ENDDO
      ENDIF
    ENDDO
  ENDDO
ENDFUNCTION
          \end{valgorithm}

      \subsection{Evaluating Query Expressions}
        \label{subs-impln-evalu}

        Once the answer sets have been generated, the policy base can accept
        query evaluation requests through the $PB$.$EvaluateExp$($exp$)
        operator. The operator works by checking the presence of queried facts
        or their negations in every answer sets generated. Algorithm
        \ref{algo-impln-evale} shows how a given expression $exp$ can be
        evaluated against a list of answer sets $\Lambda$, as returned by
        the $PB$.$GenAnswerSets$() operator.

        \begin{valgorithm}{PB.EvaluateExp()}{algo-impln-evale}
FUNCTION \(PB\).\(EvaluateExp\)(\(exp\), \(\Lambda\))
  \(result\) = \(true\)
  FOR \(i\) = \(0\) TO (\(|exp|\) - \(1\)) DO
    \(rv\) = \(EvaluateFact\)(\(exp\)[\(i\)], \(|\)\(PB\).\(seqtab\)\(|\), \(\Lambda\))
    IF \(rv\) == \(false\) THEN
      RETURN \(false\)
    ELSE IF \(rv\) == \(unknown\) THEN
      \(result\) = \(unknown\)
    ENDIF
  ENDDO
  RETURN \(result\)
ENDFUNCTION
        \end{valgorithm}

        The $PB$.$EvaluateExp$() operator evaluates each fact from the given
        query expression by calling the function $EvaluateFact$() shown in
        Algorithm \ref{algo-impln-evalf} which evaluates a single fact $\rho$
        in state $\sigma$, against a list of answer sets $\Lambda$.

        \begin{valgorithm}{EvaluateFact()}{algo-impln-evalf}
FUNCTION \(EvaluateFact\)(\(\rho\), \(\sigma\), \(\Lambda\))
  IF \(IsFactIn\)(\(Encode\)(\(\rho\).\(atom\), \(\sigma\), \(\rho\).\(truth\)), \(\Lambda\)) THEN
    RETURN \(true\)
  ELSE IF \(IsFactIn\)(\(Encode\)(\(\rho\).\(atom\), \(\sigma\), NOT \(\rho\).\(truth\)), \(\Lambda\)) THEN
    RETURN \(false\)
  ENDIF
  RETURN \(unknown\)
ENDFUNCTION
        \end{valgorithm}

        The function $IsFactIn$() simply returns a boolean value to
        indicate whether or not the given fact index $index$, as returned
        by the $Encode$() function, is present in every answer set in
        $\Lambda$.

        \begin{valgorithm}{IsFactIn()}{algo-impln-isinf}
FUNCTION \(IsFactIn\)(\(index\), \(\Lambda\))
  FOR \(i\) = \(0\) TO (\(|\Lambda|\) - \(1\)) DO
    IF NOT \(\Lambda\)[\(i\)].\(Find\)(\(index\)) THEN
      RETURN \(false\)
    ENDIF
  ENDDO
  RETURN \(true\)
ENDFUNCTION
        \end{valgorithm}

    \section{Discussions}

      In this chapter, we have shown the algorithms and data structures that
      make up the extended PolicyUpdater authorisation system. The
      specification of the system is described as a hierarchy of objects, with
      a list of all relevant properties and methods, presented from an
      implementation point of view. The chapter also includes a detailed
      description of a temporal reasoner engine implementation that is used by
      the system to maintain a temporal interval relation network for
      evaluating temporal constraints.

      The algorithms and data structures shown in this chapter were designed
      as a compromise between efficiency and simplicity. Although certain
      algorithms described in this chapter can be optimised for speed or size,
      these optimisations would introduce another level of complexity that fall
      beyond the scope of this thesis.

  \chapter{Conclusion}
    \label{chap-concl}

    Authorisation or access control is an important part of information
    security systems. Although several access control approaches and models
    have been proposed and used over the years, very few maintain a good
    balance between flexibility, expressiveness and implementation. That is,
    those access control systems with simple implementations often lack the
    ability to express complex authorisation rules or the flexibility required
    for policy updates. On the other hand, those models that can handle policy
    updates, conditional rules or temporal constraints often lack the details
    necessary for full system implementation.

    In this thesis, we have presented the full implementation details of two
    authorisation systems: PolicyUpdater and PolicyUpdater 2.

    The PolicyUpdater system is an authorisation system that uses a first-order
    logic language, language ${\cal L}$, to represent the authorisation policy
    or policy base. A language ${\cal L}$ atom, composed of a subject, an
    access right and an object, is used to construct authorisation facts and
    rules, which in turn defines the policy base. Through the use of this
    language, the PolicyUpdater system is capable of expressing and evaluating
    both positive and negative authorisations from policies with conditional
    logic rules. The two key features of this language, and therefore the
    system, is its ability to express default authorisations in conditional
    rules and conditional policy update rules which can be applied in sequence.

    We have also shown from the semantics of language ${\cal L}$ that from a 
    given policy expressed in this language and a sequence of policy updates,
    an extended logic program can be generated, which in turn can be translated
    into a normal logic program. In our implementation, we have shown that
    through these translations and the stable model semantics, a set of answer
    sets can be generated from any consistent language ${\cal L}$ policy. The
    PolicyUpdater system uses these answer sets to evaluate authorisation
    queries.

    In Chapter \ref{chap-polup}, we have outlined the data structures and
    algorithms that make up the PolicyUpdater system. The performance analysis
    of the system shows that, given a realistic input size of policies and
    queries, our implementation performs reasonably well in terms of
    computation speed. In the case study, we have shown a simple application
    in which the PolicyUpdater system is used as an authorisation system for a
    web server.

    The extended version of the system, PolicyUpdater 2, addressed the issue of
    expressing temporal constraints in the authorisation policy. This is made
    possible by the integration of the well-established temporal interval
    algebra into a logic-based authorisation language, language ${\cal L^T}$.
    This non-trivial extension of language ${\cal L}$ redefines the
    authorisation atom to include a time interval within which the
    authorisation is valid. More importantly, the interval algebra gives the
    language the ability to express relations between the time intervals
    themselves, thereby permitting the expression of rules that contain these
    interval relations. For example, language ${\cal LT}$ allows rules such as
    "If $Alice$ is allowed to $read$ file $f$ at interval $i_0$, then $Bob$
    should be allowed to $read$ file $f$ at interval $i_1$, where $i_1$ is
    during $i_0$". As with language ${\cal L}$, we have shown how language
    ${\cal L^T}$ policies can be translated into normal logic programs for
    evaluation using the stable model semantics.

    Like the first version, the full implementation details of the extended
    version of PolicyUpdater was shown in Chapter \ref{chap-impln}, including
    the implementation of a separate temporal interval relation reasoning
    engine. The chapter also includes the details of the integration of this
    engine with the rest of the authorisation system.

    To the best of our knowledge, PolicyUpdater is the first fully implemented
    logic-based authorisation system that is capable of expressing default
    authorisation rules and has support for dynamic and conditional policy
    updates. Similarly, we believe that PolicyUpdater2 is the first
    logic-based authorisation system with the same capabilities as version 1,
    and with the ability to support temporal constraints expressed in the
    interval relation algebra.

    As for future work, there are several possible directions worth pursuing.
    On the theoretical side, we note that the PolicyUpdater system handles
    conflicts in authorisation rules by giving negative authorisations a higher
    precedence over positive ones. Although our tests shows that this
    conservative discipline is sufficently safe for most applications, other
    applications or environments may require a more fine-tuned conflict
    resolution strategy. One such strategy might be to incorporate the
    expression of prioritised authorisation rules into the authorisation
    language. This way, a conflict is resolved by giving a higher precedence to
    rules with higher priorities.

    Another possible future work is to extend the system to allow disjunctive
    information to be used in authorisation rules.

    On the implementation side, we note that testing a temporal interval
    relation network for consistency is an intractable problem. Although our
    tests with small networks have shown negligible effects on computation
    time, the effects will be a problem for networks with thousands of interval
    relations. One possible future work is to replace the system's support for
    the full interval algebra with one of its tractable sub-algebras
    \cite{KRO} while maintaining equivalent, or near equivalent expressive
    power.

  \appendix

  \chapter{Language Specification}
    \label{chap-langs}

    \section{Language ${\cal L}$ in Backus-Naur Form}
      \label{sect-langs-bnfll}

      \begin{vverbatim}
<start>                  : <program>

<program>                : <head> <body> <tail>

<head>                   : <nil>

<body>                   : <entity-section>
                           <initial-section>
                           <constraint-section>
                           <update-section>
                           <directive-section>

<tail>                   : <nil>

<entity-section>         : <nil> |
                           <entity-stmt-list>

<initial-section>        : <nil> |
                           <inital-stmt-list>

<constraint-section>     : <nil> |
                           <constraint-stmt-list>

<update-section>         : <nil> |
                           <update-stmt-list>

<directive-section>      : <nil> |
                           <directive-stmt-list>

<entity-stmt-list>       : <entity-stmt> |
                           <entity-stmt-list>
                           <entity-stmt>

<initial-stmt-list>      : <initial-stmt> |
                           <initial-stmt-list>
                           <initial-stmt>

<constraint-stmt-list>   : <constraint-stmt> |
                           <constraint-stmt-list>
                           <constraint-stmt>

<update-stmt-list>       : <update-stmt> |
                           <update-stmt-list>
                           <update-stmt>

<directive-stmt-list>    : <directive-stmt> |
                           <directive-stmt-list>
                           <directive-stmt>

<entity-stmt>            : <entity>
                           <entity-declaration>
                           <semicolon>

<entity-declaration>     : <sub-entity-decl> |
                           <obj-entity-decl> |
                           <acc-entity-decl> |
                           <sub-grp-entity-decl> |
                           <obj-grp-entity-decl> |
                           <acc-grp-entity-decl>

<sub-entity-decl>        : <sub-type>
                           <sub-entity-list>

<acc-entity-decl>        : <acc-type>
                           <acc-entity-list>

<obj-entity-decl>        : <obj-type>
                           <obj-entity-list>

<sub-grp-entity-decl>    : <sub-grp-type>
                           <sub-grp-entity-list>

<acc-grp-entity-decl>    : <acc-grp-type>
                           <acc-grp-entity-list>

<obj-grp-entity-decl>    : <obj-grp-type>
                           <obj-grp-entity-list>

<sub-entity-list>        : <identifier> |
                           <sub-entity-list> <comma>
                           <identifier>

<obj-entity-list>        : <identifier> |
                           <obj-entity-list> <comma>
                           <identifier>

<acc-entity-list>        : <identifier> |
                           <acc-entity-list> <comma>
                           <identifier>

<sub-grp-entity-list>    : <identifier> |
                           <sub-grp-entity-list>
                           <comma> <identifier>

<obj-grp-entity-list>    : <identifier> |
                           <obj-grp-entity-list>
                           <comma> <identifier>

<acc-grp-entity-list>    : <identifier> |
                           <acc-grp-entity-list>
                           <comma> <identifier>

<initial-stmt>           : <initially> <expression>
                           <semicolon>

<constraint-stmt>        : <always> <expression>
                           <implied-clause>
                           <with-clause> <semicolon>

<implied-clause>         : <nil> |
                           <implied> <by> <expression>

<with-clause>            : <nil> |
                           <with> <absence>
                           <expression>

<update-stmt>            : <identifier>
                           <update-var-def> <causes>
                           <expression> <if-clause>
                           <semicolon>

<if-clause>              : <nil> |
                           <if> <expression>

<update-var-def>         : <open-parent>
                           <close-parent> |
                           <open-parent>
                           <update-var-list>
                           <close-parent>

<update-var-list>        : <identifier> |
                           <update-var-list>
                           <comma> <identifier>

<directive-stmt>         : <sequence-stmt> |
                           <compute-stmt> |
                           <query-stmt>

<sequence-stmt>          : <sequence>
                           <sequence-cmd-clause>
                           <semicolon>

<compute-stmt>           : <compute> <semicolon>

<query-stmt>             : <query> <expression>
                           <semicolon>

<sequence-cmd-clause>    : <sequence-add-clause> |
                           <sequence-del-clause> |
                           <sequence-lst-clause>

<sequence-add-clause>    : <add> <update-ref-def>

<sequence-del-clause>    : <del> <number>

<sequence-lst-clause>    : <list>

<update-ref-def>         : <identifier> <open-parent>
                           <update-ref-ident-args>
                           <close-parent>

<update-ref-ident-args>  : <nil> |
                           <update-ref-ident-list>

<update-ref-ident-list>  : <identifier> |
                           <update-ref-ident-list>
                           <comma> <identifier>

<expression>             : <expression> <logical-op>
                           <boolean-fact> |
                           <boolean-fact>

<boolean-fact>           : <not> <fact> |
                           <fact>

<fact>                   : <holds-fact> |
                           <subst-fact> |
                           <memb-fact>

<holds-fact>             : <holds> <open-parent>
                           <identifier> <comma>
                           <identifier> <comma>
                           <identifier> <close-parent>

<subst-fact>             : <subset> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<memb-fact>              : <member> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<logical-op>             : <and>

<identifier>             : <alpha> <alphanum>

<and>                    : <comma>

<not>                    : !

<holds>                  : holds

<member>                 : memb

<subset>                 : subst

<initially>              : initially

<causes>                 : causes

<implied>                : implied

<by>                     : by

<with>                   : with

<absence>                : absence

<always>                 : always

<if>                     : if

<query>                  : query

<compute>                : compute

<sequence>               : seq

<entity>                 : entity

<sub-type>               : sub

<obj-type>               : obj

<acc-type>               : acc

<sub-grp-type>           : sub-grp

<obj-grp-type>           : obj-grp

<acc-grp-type>           : acc-grp

<add>                    : add

<del>                    : del

<list>                   : list

<open-parent>            : (

<close-parent>           : )

<comma>                  : ,

<semicolon>              : ;

<underscore>             : _

<digit>                  : [0-9]

<number>                 : <digit> |
                           <number> <digit>

<alpha>                  : [a-zA-Z]

<alphanum>               : <alpha> |
                           <digit> |
                           <underscore>
      \end{vverbatim}

    \section{Language ${\cal L^T}$ in Backus-Naur Form}
      \label{sect-langs-bnflt}

    \begin{vverbatim}
<start>                  : <program>

<program>                : <head> <body> <tail>

<head>                   : <nil>

<body>                   : <identifier-section>
                           <initial-section>
                           <relation-section>
                           <constraint-section>
                           <update-section>
                           <directive-section>

<tail>                   : <nil>

<identifier-section>     : <nil> |
                           <identifier-stmt-list>

<initial-section>        : <nil> |
                           <inital-stmt-list>

<relation-section>       : <nil> |
                           <relation-stmt-list>

<constraint-section>     : <nil> |
                           <constraint-stmt-list>

<update-section>         : <nil> |
                           <update-stmt-list>

<directive-section>      : <nil> |
                           <directive-stmt-list>

<identifier-stmt-list>   : <identifier-stmt> |
                           <identifier-stmt-list>
                           <identifier-stmt>

<initial-stmt-list>      : <initial-stmt> |
                           <initial-stmt-list>
                           <initial-stmt>

<relation-stmt-list>     : <relation-stmt> |
                           <relation-stmt-list>
                           <relation-stmt>

<constraint-stmt-list>   : <constraint-stmt> |
                           <constraint-stmt-list>
                           <constraint-stmt>

<update-stmt-list>       : <update-stmt> |
                           <update-stmt-list>
                           <update-stmt>

<directive-stmt-list>    : <directive-stmt> |
                           <directive-stmt-list>
                           <directive-stmt>

<identifier-stmt>        : <entity>
                           <entity-declaration>
                           <semicolon> |
                           <interval>
                           <interval-declaration>
                           <semicolon>

<entity-declaration>     : <sub-entity-decl> |
                           <obj-entity-decl> |
                           <acc-entity-decl> |
                           <sub-grp-entity-decl> |
                           <obj-grp-entity-decl> |
                           <acc-grp-entity-decl>

<interval-declaration>   : <interval-decl> |
                           <interval-declaration>
                           <comma> <interval-decl>

<sub-entity-decl>        : <sub-type>
                           <sub-entity-list>

<acc-entity-decl>        : <acc-type>
                           <acc-entity-list>

<obj-entity-decl>        : <obj-type>
                           <obj-entity-list>

<sub-grp-entity-decl>    : <sub-grp-type>
                           <sub-grp-entity-list>

<acc-grp-entity-decl>    : <acc-grp-type>
                           <acc-grp-entity-list>

<obj-grp-entity-decl>    : <obj-grp-type>
                           <obj-grp-entity-list>

<sub-entity-list>        : <identifier> |
                           <sub-entity-list> <comma>
                           <identifier>

<obj-entity-list>        : <identifier> |
                           <obj-entity-list> <comma>
                           <identifier>

<acc-entity-list>        : <identifier> |
                           <acc-entity-list> <comma>
                           <identifier>

<sub-grp-entity-list>    : <identifier> |
                           <sub-grp-entity-list>
                           <comma> <identifier>

<obj-grp-entity-list>    : <identifier> |
                           <obj-grp-entity-list>
                           <comma> <identifier>

<acc-grp-entity-list>    : <identifier> |
                           <acc-grp-entity-list>
                           <comma> <identifier>

<interval-decl>          : <identifier>
                           <interval-enpoint-decl> |
                           <identifier>

<interval-endpoint-decl> : <open-bracket> <number>
                           <comma> <number>
                           <close-braket>

<initial-stmt>           : <initially> <expression>
                           <semicolon>

<relation-stmt>          : <relation> <relation-list>
                           <semicolon>

<relation-list>          : <relation-atom> |
                           <relation-list> <comma>
                           <relation-atom>

<relation-atom>          : <rel-eql-atom> |
                           <rel-bef-atom> |
                           <rel-dur-atom> |
                           <rel-ovr-atom> |
                           <rel-met-atom> |
                           <rel-sta-atom> |
                           <rel-fin-atom>

<rel-eql-atom>           : <eql> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<rel-bef-atom>           : <bef> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<rel-dur-atom>           : <dur> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<rel-ovr-atom>           : <ovr> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<rel-met-atom>           : <met> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<rel-sta-atom>           : <sta> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<rel-fin-atom>           : <fin> <open-parent>
                           <identifier> <comma>
                           <identifier> <close-parent>

<constraint-stmt>        : <always> <expression>
                           <implied-clause>
                           <with-clause>
                           <where-clause>
                           <semicolon>

<implied-clause>         : <nil> |
                           <implied> <by> <expression>

<with-clause>            : <nil> |
                           <with> <absence>
                           <expression>

<where-clause>           : <nil> |
                           <where> <relation-list>

<update-stmt>            : <identifier>
                           <update-var-def> <causes>
                           <expression> <if-clause>
                           <where-clause> <semicolon>

<if-clause>              : <nil> |
                           <if> <expression>

<update-var-def>         : <open-parent>
                           <close-parent> |
                           <open-parent>
                           <update-var-list>
                           <close-parent>

<update-var-list>        : <identifier> |
                           <update-var-list> <comma>
                           <identifier>

<directive-stmt>         : <sequence-stmt> |
                           <compute-stmt> |
                           <query-stmt>

<sequence-stmt>          : <sequence>
                           <sequence-cmd-clause>
                           <semicolon>

<compute-stmt>           : <compute> <semicolon>

<query-stmt>             : <query> <expression>
                           <semicolon>

<sequence-cmd-clause>    : <sequence-add-clause> |
                           <sequence-del-clause> |
                           <sequence-lst-clause>

<sequence-add-clause>    : <add> <update-ref-def>

<sequence-del-clause>    : <del> <number>

<sequence-lst-clause>    : <list>

<update-ref-def>         : <identifier> <open-parent>
                           <update-ref-ident-args>
                           <close-parent>

<update-ref-ident-args>  : <nil> |
                           <update-ref-ident-list>

<update-ref-ident-list>  : <identifier> |
                           <update-ref-ident-list>
                           <comma> <identifier>

<expression>             : <expression> <logical-op>
                           <boolean-fact> |
                           <boolean-fact>

<boolean-fact>           : <not> <fact> |
                           <fact>

<fact>                   : <holds-fact> |
                           <subst-fact> |
                           <memb-fact>

<holds-fact>             : <holds> <open-parent>
                           <identifier> <comma>
                           <identifier> <comma>
                           <identifier> <comma>
                           <identifier> <close-parent>

<subst-fact>             : <subset> <open-parent>
                           <identifier> <comma>
                           <identifier> <comma>
                           <identifier> <close-parent>

<memb-fact>              : <member> <open-parent>
                           <identifier> <comma>
                           <identifier> <comma>
                           <identifier> <close-parent>

<logical-op>             : <and>

<identifier>             : <alpha> <alphanum>

<and>                    : <comma>

<not>                    : !

<holds>                  : holds

<member>                 : memb

<subset>                 : subst

<initially>              : initially

<relation>               : relation

<causes>                 : causes

<implied>                : implied

<by>                     : by

<with>                   : with

<absence>                : absence

<where>                  : where

<always>                 : always

<if>                     : if

<query>                  : query

<compute>                : compute

<sequence>               : seq

<entity>                 : entity

<interval>               : interval

<sub-type>               : sub

<obj-type>               : obj

<acc-type>               : acc

<sub-grp-type>           : sub-grp

<obj-grp-type>           : obj-grp

<acc-grp-type>           : acc-grp

<eql>                    : equals

<bef>                    : before

<dur>                    : during

<ovr>                    : overlaps

<met>                    : meets

<sta>                    : starts

<fin>                    : finishes

<add>                    : add

<del>                    : del

<list>                   : list

<open-parent>            : (

<close-parent>           : )

<open-bracket>           : [

<close-bracket>          : ]

<comma>                  : ,

<semicolon>              : ;

<underscore>             : _

<digit>                  : [0-9]

<number>                 : <digit>

<alpha>                  : [a-zA-Z]

<alphanum>               : <alpha> |
                           <digit> |
                           <underscore>
    \end{vverbatim}

  \begin{thebibliography}{III}
    \addcontentsline{toc}{chapter}{Bibliography}

    \bibitem{ABA}
      Abadi M., Burrows M., Lampson B., Plotkin G.,
      A Calculus for Access Control in Distributed Systems.
      {\em ACM Transactions on Programming Languages and Systems},
      Vol. 15, No. 4, pp. 706-734,
      1993.

    \bibitem{ALE}
      Allen J. F.,
      Maintaining Knowledge about Temporal Intervals.
      {\em Communications of the ACM},
      Vol. 26, No. 11, pp. 832-843,
      1983.

    \bibitem{ATL}
      Atluri V., Gal A.,
      An Authorization Model for Temporal and Derived Data: Securing Information Portals.
      {\em ACM Transactions on Information and System Security},
      Vol. 5, No. 1, pp. 62-94,
      2002.

    \bibitem{AP}
      Apache Software Foundation,
      Authentication, Authorization and Access Control.
      Apache HTTP Server Version 2.1 Documentation,
      2004.

      {\tt http://httpd.apache.org/docs-2.1/}

    \bibitem{BAI1}
      Bai Y., Varadharajan V.,
      A Language for Specifying Sequences of Authorization Transformations and Its Applications.
      In {\em Proceedings of the First International Conference on Information and Communication Security},
      pp. 39-49,
      1997.

    \bibitem{BAI2}
      Bai Y., Varadharajan V.,
      On Transformation of Authorization Policies.
      {\em Data and Knowledge Engineering},
      Vol. 45, No. 3, pp. 333-357,
      2003.

    \bibitem{BAI3}
      Bai Y., Zhang Y., Varadharajan V.,
      On the Sequence of Authorization Policy Transformations.
      {\em International Journal of Information Security},
      Vol. 4, No. 1-2, pp. 120-131,
      2005.

    \bibitem{BAR}
      Baral C.,
      Knowledge, Representation, Reasoning and Declarative Problem Solving.
      Cambridge University Press, UK.
      pp. 99-100,
      2003.

    \bibitem{BEL1}
      Bell D. E., LaPadula L. J.,
      Secure Computer Systems: Mathematical Foundations.
      {\em Technical Report MTR-2547},
      Vol. 1,
      Mitre Corporation,
      1973.

    \bibitem{BEL2}
      Bell D. E., LaPadula L. J.,
      Secure Computer Systems: Mathematical Foundations and Model.
      {\em Technical Report M74-244},
      Vol. 1,
      Mitre Corporation,
      1974.

    \bibitem{BER1}
      Bertino E., Bettini C., Samarati P.,
      A Temporal Authorization Model.
      In {\em Proceedings of the 2nd ACM Conference on Computer and Communications Security},
      pp. 26-135,
      1994.

    \bibitem{BER2}
      Bertino E., Bettini C., Ferrari E., Samarati P.,
      An Access Control Model Supporting Periodicity Constraints and Temporal Reasoning.
      {\em ACM Transactions on Database Systems},
      Vol. 23, No. 3, pp. 231-285,
      1999.

    \bibitem{BER3}
      Bertino E., Buccafurri F., Ferrari E., Rullo P.,
      A Logic-Based Approach for Enforcing Access Control.
      {\em Journal of Computer Security},
      Vol. 8, No. 2-3, pp. 109-140,
      2000.

    \bibitem{BER4}
      Bertino E., Mileo A., Provetti A.,
      Policy Monitoring with User-Preferences in PDL.
      In {\em Proceedings of IJCAI-03 Workshop for Nonmonotonic Reasoning, Action and Change},
      pp. 37-44,
      2003.

    \bibitem{BER5}
      Bertino E., Mileo A., Provetti A.,
      PDL with Preferences.
      In {\em Proceedings of the 6th IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY 2005)},
      pp. 213-222,
      2005.

    \bibitem{CAS}
      Castano S., Fugini M., Martella G., Samarati P.,
      Database Security.
      Addison-Wesley Publishing Co.,
      1995.

    \bibitem{CHO}
      Chomicki J., Lobo J., Naqvi S.,
      A Logic Programming Approach to Conflict Resolution in Policy Management.
      In {\em Proceedings of the 7th International Conference on Principles of Knowledge Representation and Reasoning (KR2000)},
      pp. 121-132,
      2000.

    \bibitem{CON}
      Conway R. W., Maxwell W. L., Morgan H. L.,
      On the Implementation of Security Measures in Information Systems.
      {\em Communications of the ACM}
      Vol. 15, No. 4, pp. 211-220,
      1972.

    \bibitem{CRE1}
      Crescini V. F., Zhang Y.,
      A Logic Based Approach for Dynamic Access Control.
      In {\em Proceedings of the 17th Australian Joint Conference on Artificial Intelligence (AI 2004, LNCS/LNAI)}
      Vol. 3339, pp. 623-635,
      2004.

    \bibitem{CRE2}
      Crescini V. F., Zhang Y.,
      PolicyUpdater: A System for Dynamic Access Control.
      {\em International Journal of Information Security},
      DOI 10.1007/s10207-005-0078-8,
      2005.

    \bibitem{CRE3}
      Crescini V. F., Zhang Y.,
      Expressing Temporal Constraints with the PolicyUpdater System.
      (to be submitted),
      2006.

    \bibitem{CRE4}
      Crescini V. F., Zhang Y., Wang W.,
      Web Server Authorisation with the PolicyUpdater Access Control System.
      In {\em Proceedings of the IADIS International Conference (WWW/Internet 2004)},
      Vol. 2, pp. 945-948,
      2004.

    \bibitem{FAR}
      Farby R.,
      Capability-Based Addressing.
      {\em Communications of the ACM},
      Vol. 17, No. 7, pp. 403-412,
      1974.

    \bibitem{FER1}
      Ferraiolo D. F., Kuhn D. R.,
      Role Based Access Controls,
      In {\em Proceedings of the 15th National Computer Security Conference},
      pp. 554-563,
      1992.

    \bibitem{FER2}
      Ferraiolo D. F., Cugini J. Kuhn D. R.,
      Role Based Access Control (RBAC): Features and Motivations.
      In {\em Proceedings of the 11th Annual Computer Security Applications Conference (CSAC-95)},
      pp. 241-248,
      1995.

    \bibitem{FRE}
      Freuder E. C.,
      A Sufficient Condition for Backtrack-Free Search.
      {\em Journal of the ACM},
      Vol. 29, No. 1, pp. 24-32,
      1982.

    \bibitem{GEL1}
      Gelfond M., Lifschitz V.,
      The Stable Model Semantics for Logic Programming.
      In {\em Proceedings of the Fifth International Conference on Logic Programming},
      pp. 1070-1080,
      1988.

    \bibitem{GEL2}
      Gelfond M., Lifschitz V.,
      Classical Negation in Logic Programs and Disjunctive Databases.
      {\em New Generation Computing},
      Vol. 9, No. 3-4, pp. 365-386,
      1991.

    \bibitem{GRA}
      Graham G. S., Denning P. J.,
      Protection - Principles and Practice.
      In {\em Proceedings of the AFIPS Spring Joint Computer Conference},
      Vol. 40, pp. 427-429,
      1972.

    \bibitem{HAR}
      Harrison M. H., Ruzzo W. L., Ullman J. D.,
      Protection in Operating Systems.
      {\em Communications of the ACM},
      Vol. 19, No. 8, pp. 461-471,
      1976.

    \bibitem{JAJ1}
      Jajodia S., Samarati P., Subrahmanian V. S.,
      A Logical Language for Expressing Authorizations.
      In {\em Proceedings of the 1997 IEEE Symposium on Security and Privacy},
      pp. 31-42,
      1997.

    \bibitem{JAJ2}
      Jajodia S., Samarati P., Subrahmanian V. S., Bertino E.,
      A Unified Framework for Enforcing Multiple Access Control Policies.
      In {\em Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data},
      pp. 474-485,
      1997.

    \bibitem{JAJ3}
      Jajodia S., Samarati P., Sapino M. L., Subrahmanian V. S.,
      Flexible Support for Multiple Access Control Policies.
      {\em ACM Transactions on Database Systems},
      Vol. 26, No. 2, pp. 214-260,
      2001.

    \bibitem{KRO}
      Krokhin A., Jeavons P., Jonsson P.,
      Reasoning about Temporal Relations: The Tractable Subalgebras of Allen's Interval Algebra.
      {\em Journal of the ACM},
      Vol. 50, No. 5, pp. 591-640,
      2003.

    \bibitem{LAD}
      Ladkin P. B., Reinefeld A.,
      Fast Algebraic Methods for Interval Constraint Problems.
      {\em Annals of Mathematics and Artificial Intelligence},
      Vol. 19, No. 3-4, pp. 383-411,
      1997.

    \bibitem{LAM}
      Lampson, B. W.,
      Protection.
      In {\em Proceedings of the 5th Princeton Symposium on Information Science and Systems},
      pp. 437-464,
      1971.

    \bibitem{LAU}
      Laurie B., Laurie P.,
      Apache: The Definitive Guide (3rd Edition).
      O'Reilly \& Associates Inc., CA,
      2003.

    \bibitem{LEV}
      Levy, H. M.,
      Capability-Based Computer Systems.
      DEC Press,
      1984.

    \bibitem{LI}
      Li N., Grosof B. N., Feigenbaum J.,
      Delegation Logic: A Logic-Based Approach to Distributed Authorization.
      {\em ACM Transactions on Information and System Security (TISSEC)},
      Vol. 6, No. 1, pp. 128-171,
      2003.

    \bibitem{LIN}
      Lin F., Zhao X.,
      On Odd and Even Cycles in Normal Logic Programs.
      In {\em Proceedings of the 19th National Conference on Artificial Intelligence (AAAI-04)}
      and {\em 16th Conference on Innovative Applications of Artificial Intelligence},
      pp. 80,
      2004.

    \bibitem{LOB}
      Lobo J., Bhatia R., Naqvi S.,
      A Policy Description Language.
      In {\em Proceedings of the 16th AAAI National Conference on Artificial Intelligence and 11th Conference on Innovative Applications of Artificial Intelligence},
      pp. 291-298,
      1999.

    \bibitem{MAC}
      Mackworth, A.K.,
      Consistency in Networks of Relations.
      {\em Artificial Intelligence},
      Vol. 8, No. 1, pp. 99-118,
      1977.

    \bibitem{MEA}
      Meadows C.,
      Policies for Dynamic Upgrading.
      {\em Database Security, IV: Status and Prospects (DBSec)},
      pp. 241-250,
      1990.

    \bibitem{HAL}
      Halpern J. Y., Weissman V.,
      Using First-Order Logic to Reason About Policies.
      In {\em Proceedings of the 16th IEEE Computer Security Foundations Workshop},
      pp. 187-201,
      2003.

    \bibitem{HTTP1}
      Network Working Group,
      HTTP 1.1 (RFC 2616).
      The Internet Society, 1999.

      {\tt ftp://ftp.isi.edu/in-notes/rfc2616.txt}

    \bibitem{HTTP2}
      Network Working Group,
      HTTP Authentication: Basic and Digest Access Authentication (RFC 2617).
      The Internet Society, 1999.

      {\tt ftp://ftp.isi.edu/in-notes/rfc2617.txt}

    \bibitem{NIE}
      Niemel{\"a} I., Simons P.,
      Smodels - An Implementation of the Stable Model and Well-Founded
      Semantics for Normal Logic Programs.
      In {\em Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-97)}
      and {\em Lecture Notes in Computer Science},
      Vol. 1265, pp. 421-430,
      1997.

    \bibitem{RAY}
      Ray I.,
      Real-Time Update of Access Control Policies.
      {\em Data \& Knowledge Engineering},
      Vol. 49, No. 3, pp. 287-309,
      2004.

    \bibitem{REI}
      Reiter R.,
      A Logic for Default Reasoning.
      {\em Artificial Intelligence},
      Vol. 13, No. 1-2, pp. 81-132,
      1980.

    \bibitem{RUA1}
      Ruan C., Varadharajan V., Zhang Y.,
      Logic-Based Reasoning on Delegatable Authorizations.
      In {\em Proceedings of the 13th International Symposium on Foundations of Intelligent Systems (LNCS)},
      Vol. 2366, pp. 185-193,
      2002.

    \bibitem{RUA2}
      Ruan C., Varadharajan V., Zhang Y.,
      Evaluation of Authorization with Delegation and Negation.
      In {\em Proceedings of the International Intelligent Information Processing and Web Mining Conference (IIPWM-03)},
      pp. 547-551,
      2003.

    \bibitem{RUA3}
      Ruan C., Varadharajan V., Zhang Y.,
      A Logic Model for Temporal Authorization Delegation with Negation.
      In {\em Proceedings of the 6th International Conference on Information Security (ISC2003)},
      Vol. 2851, pp. 310-324,
      2003.

    \bibitem{SAN1}
      Sandhu R. S.,
      Transformation of Access Rights.
      In {\em Proceedings of the IEEE Symposium on Research in Security and Privacy},
      pp. 259-268,
      1989.

    \bibitem{SAN2}
      Sandhu R. S., Coyne E. J., Feinstein H. L., Youman C. E.,
      Role-Based Access Control Models.
      {\em IEEE Computer},
      Vol. 29, No. 2, pp. 38-47,
      1996.

    \bibitem{SAN3}
      Sandhu R. S., Ganta S.,
      On the Expressive Power of the Unary Transformation Model.
      In {\em Proceedings of the Third European Symposium on Research in Computer Security},
      pp. 301-318,
      1994.

    \bibitem{SAN4}
      Sandhu R. S., Suri G. S.,
      Non-Monotonic Transformation of Access Rights.
      In {\em Proceedings of the IEEE Symposium on Research in Security and Privacy},
      pp. 148-161,
      1992.

    \bibitem{SIM1}
      Simons P.,
      Efficient Implementation of the Stable Model Semantics for Normal Logic
      Programs.
      Research Reports Number A35, Helsinki University of Technology,
      1995.

      {\tt http://www.tcs.hut.fi/Publications/reports/A35.ps.Z}

    \bibitem{SIM2}
      Simons P., Niemel{\"a} I., Soininen T.,
      Extending and Implementing the Stable Model Semantics.
      {\em Artificial Intelligence},
      Vol. 138, No. 1-2, pp. 181-234,
      2002.

    \bibitem{VAL}
      Valdez-Perez R. E.,
      The Satisfiability of Temporal Constraint Networks.
      In {\em Proceedings of the Sixth National Conference on Artificial Intelligence (AAAI-87)},
      pp. 256-260,
      1987.

    \bibitem{VAN1}
      Van Beek P. G., Cohen, R.,
      Exact and Approximate Reasoning about Temporal Relations.
      {\em Computational Intelligence},
      Vol. 6., No. 3, pp. 132-147,
      1990.

    \bibitem{VAN2}
      Van Beek P. G., Manchak D. W.,
      The Design and Experimental Analysis of Algorithms for Temporal Reasoning.
      {\em Journal of Artificial Intelligence Research},
      Vol. 4, pp. 1-18,
      1996.

    \bibitem{VIL}
      Vilain M. B., Kautz H. A., Van Beek P. G.,
      Constraint Propagation Algorithms for Temporal Reasoning: A Revised Report.
      In {\em Readings in Qualitative Reasoning about Physical Systems},
      pp. 373-381,
      1989.

    \bibitem{WOO1}
      Woo T. Y. C., Lam S. S.,
      Authorization in Distributed Systems: A Formal Approach.
      In {\em Proceedings of the IEEE Symposium on Research in Security and Privacy},
      pp. 33-51,
      1992.

    \bibitem{WOO2}
      Woo T. Y. C., Lam S. S.,
      Authorization in Distributed Systems: A New Approach.
      {\em Journal of Computer Security},
      Vol. 2, No. 2-3, pp. 107-136,
      1993.

    \bibitem{ZHA}
      Zhang Y.,
      Handling Defeasibilities in Action Domains.
      {\em Theory and Practice of Logic Programming},
      Vol. 3, No. 3, pp. 329-376,
      2003.
  \end{thebibliography}

\end{document}
