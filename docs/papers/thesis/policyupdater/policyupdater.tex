\documentclass[11pt]{report}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{alltt}

% a variable margin environment
\newenvironment{vvarmargin}[2]
{
  \begin{list}{}
  {
    \setlength{\topsep}{0pt}
    \setlength{\leftmargin}{0pt}
    \setlength{\rightmargin}{0pt}
    \setlength{\listparindent}{\parindent}
    \setlength{\itemindent}{\parindent}
    \setlength{\parsep}{0pt plus 1pt}
    \addtolength{\leftmargin}{#1}\addtolength{\rightmargin}{#2}
  }
  \item
}
{
  \end{list}
}

% definition environment
\newtheorem{vdefinition}{Definition}

% example environment
\newtheorem{vexample}{Example}

% verbatim environment
\newenvironment{vverbatim}
{
  \begin{alltt}
}
{
  \vspace{-\baselineskip}
  \end{alltt}
}

% create a quote environment without a right-hand margin
\newenvironment{vquote}
{
  \begin{list}{}{\leftmargin 1em}\item[]
}
{
  \end{list}
}

\begin{document}
  \onehalfspacing

  \chapter{Temporal Constraints in Authorisation Policies}

    \section{Introduction}

      An obvious limitation of language ${\cal L}$ is its lack of expressive
      power to represent time-dependent authorisations. Consider the following
      authorisation rule:
  
      \begin{vquote}
        $Bob$ holds $read$ access to file $f$ between $9:00$ $AM$ and $5:00$
        $PM$
      \end{vquote}
  
      The authorisation information above can be broken down into two parts: an
      authorisation part, i.e. "Bob holds read access to file $f$", and a
      temporal part, i.e. "between 9:00 AM and 5:00 PM". As language ${\cal L}$
      can already express authorisations, we focus our attention to the
      temporal part. A naive attempt to extend language ${\cal L}$ to express
      time may involve adding two extra parameters to each authorisation atom
      to represent the starting and ending time points of the interval. For
      example, the authorisation rule above can be represented as:
  
      \begin{vquote}
        $holds$($bob$, $read$, $f$, $900$, $1700$)
      \end{vquote}

      The atom above may be interpreted to mean that the authorisation holds
      for all times between 9:00 AM and 5:00 PM, inclusive. In this example,
      the granularity of time, or the smallest unit of time that can be
      expressed, is one minute. Of course, a more general approach is to use
      the domain of positive integers. With this approach, the system can
      handle different granularities of time, where the choice of what time
      unit each discrete value is interpreted as is left to the application.
      For example, if the temporal values are defined to be the number of
      seconds since 12 midnight, 01 Jan 1970 (i.e. the beginning of the UNIX
      epoch), then the atom below states that the authorisation holds at an
      interval starting at 9:00 AM, 18 March 1976 and ending at 5:00 PM, 18
      March 1976:
 
      \begin{vquote}
        $holds$($bob$, $read$, $f$, $195951600$, $195980400$)
      \end{vquote}

      While this approach gives the language enough expressive power to
      represent authorisations bound by literal time values, it is by no means
      expressive enough to model relationships between the time values
      themselves. This deficiency is shown in the example below:
 
      \begin{vquote}
        $Alice$ holds a $write$ access right to file $f_0$ after $Bob$ holds a
        $read$ access right to file $f_1$
      \end{vquote}
 
      Such authorisation rule might arise in a situation where the access right
      $write$ to file $f_0$ can only be granted at some time after the $read$
      access right to file $f_1$ has been granted and revoked. This example
      shows that the specific times at which authorisations hold are not as
      important as the relationship between the times themselves. This
      authorisation rule may be represented as follows:

      \begin{vquote}
        $holds$($alice$, $write$, $f_0$, $i_{1}$)
 
        $holds$($bob$, $read$, $f_0$, $i_{2}$)
 
        $after$($i_0$, $i_1$)
      \end{vquote}
 
      The example above states that $alice$ holds a $write$ access right to
      file $f_0$ at some time interval $i_0$, $bob$ holds a $read$ access right
      to file $f_1$ at some time interval $i_1$, and that the interval $i_0$
      occurs at some time after the interval $i_1$. As mentioned earlier, the
      actual values of the time intervals $i_0$ and $i_1$ is not as important
      as the fact that the interval $i_0$ occurs after interval $i_1$.

      The rest of this chapter discusses how temporal constraints can be
      incorporated into the authorisation language. The next section introduces
      Allen's temporal interval algebra to express relations between time
      values, followed by a section that outlines extensions to this algebra,
      and finally, the last section gives a detailed formalisation of a new
      authorisation language that utilises the interval algebra to support
      temporal constraints.

    \section{Allen's Temporal Interval Algebra}

      Allen's interval algebra \cite{AL} is based on the fact that for any
      two well defined time intervals, there exists exactly one interval
      relation between them. The strength of the algebra lies not just on
      the formalisation of these relations, but also on its ability to handle
      disjunctive interval relations between undefined time intervals.

      For example, given an interval ${i_0}$, defined as 24th of September,
      1995 to 25th of September, 1995; and interval ${i_1}$, defined as 25th of
      December 1995 to 1st of January 1996. From the definitions of these
      intervals, it is easy to conclude that interval ${i_0}$ is {\em before}
      interval ${i_1}$, since the finishing end point of interval ${i_0}$
      occurs before the starting end point of interval ${i_1}$.

      The strength of the interval algebra can be illustrated by considering
      intervals without endpoint definitions, but rather as having disjunctive
      relations with other intervals. For example, given three intervals
      ${i_0}$, ${i_1}$ and ${i_2}$ whose bounding endpoints are not known. The
      algebra allows us to conclude that if ${i_0}$ occurs either {\em before}
      or {\em during} ${i_1}$ and ${i_2}$ occurs {\em after} ${i_1}$, then the
      interval ${i_0}$ must occur {\em before} ${i_2}$.

      The rest of the section gives a detailed overview of Allen's interval
      algebra.

      \subsection{Time Points and Time Intervals}

        The preceding introduction hinted the difference between a time point and a
        time interval. This sub section aims to give a more formal distinction between
        the two.

        A point in time represents an event with zero duration, or an event that occurs
        instantaneously, such as the switching on of a light bulb, or the moment the sun
        has risen in the morning.

        A time interval, on the other hand, is defined to be the time that has elapsed
        between two given time points. For example, the interval one might call lunch
        hour may be defined as the time elapsed between the time points 1 PM and 2 PM.

        Formally, a time interval $i$ is defined by its starting end point ${i^-}$ and
        a finishing end point ${i^+}$, where ${i^-}$ $<$ ${i^+}$. 

        One might argue that time point events such as the switching on of a light bulb
        are not instantaneous, meaning that time, no matter how small the value, has
        elapsed between the instant that electricity flowed through light bulb's
        filament and the instant the light from the bulb reaches the observer's eyes.
        One can further argue that the "instant" that electricity flowed through the
        bulb's filament is not instantaneous, once we consider that the speed of light
        and electricity is finite. In other words, any given event can always be
        divided into sub-events. This argument is more evident in the sunrise example.

        To solve this problem, Allen's algebra defines time intervals as the most basic
        entities. This means time points are not used to define time intervals, but
        instead, each interval is defined only in terms of its relationship with other
        intervals.

      \subsection{Time Interval Relations}

        As shown in Figure \ref{fig-rels}, the algebra defines 13 disjoint relations
        that can occur between any two intervals. For clarity, we define each temporal
        interval relation below in terms of the relationships of the end points of
        their intervals:

        \begin{figure}[[tbhp]
          \begin{center}
            \includegraphics{rels}
            \caption{Thirteen Temporal Interval Relations}
            \label{fig-rels}
          \end{center}
        \end{figure}

        \begin{itemize}
          \item
            {\em Before}.
            Interval ${i_0}$ is said to be {\em before} interval ${i_1}$ if and
            only if ${i_0^+}$ $<$ ${i_1^-}$.

          \item
            {\em After}.
            Interval ${i_0}$ is said to be {\em after} interval ${i_1}$ if and
            only if ${i_0^-}$ $>$ ${i_1^+}$. Note that this is an inverse of
            the {\em before} relation.

          \item
            {\em Meets}.
            Interval ${i_0}$ is said to {\em meet} interval ${i_1}$ if and only
            if ${i_0^+}$ $=$ ${i_1^-}$.

          \item
            {\em Met By}.
            Interval ${i_0}$ is said to be {\em met by} interval ${i_1}$ if and
            only if ${i_0^-}$ $=$ ${i_1^+}$. Note that this is an inverse of
            the {\em meets} relation.

          \item
            {\em During}.
            Interval ${i_0}$ is said to be {\em during} interval ${i_1}$ if and
            only if ${i_0^-}$ $>$ ${i_1^-}$ and ${i_0^+}$ $<$ ${i_1^+}$.

          \item
            {\em Contains}.
            Interval ${i_0}$ is said to {\em contain} interval ${i_1}$ if and
            only if ${i_0^-}$ $<$ ${i_1^-}$ and ${i_0^+}$ $>$ ${i_1^+}$. Note
            that this is an inverse of the {\em during} relation.

          \item
            {\em Overlaps}.
            Interval ${i_0}$ is said to {\em overlap} interval ${i_1}$ if and
            only if ${i_0^-}$ $<$ ${i_1^-}$, ${i_0^+}$ $>$ ${i_1^-}$ and
            ${i_0^+}$ $<$ ${i_1^+}$.

          \item
            {\em Overlapped By}.
            Interval ${i_0}$ is said to be {\em overlapped by} interval
            ${i_1}$ if and only if ${i_0^-}$ $>$ ${i_1^-}$, ${i_0^-}$ $<$
            ${i_1^+}$ and ${i_0^+}$ $>$ ${i_1^+}$. Note that this is an
            inverse of the {\em overlaps} relation.

          \item
            {\em Starts}.
            Interval ${i_0}$ is said to {\em start} interval ${i_1}$ if and
            only if ${i_0^-}$ $=$ ${i_1^-}$ and ${i_0^+}$ $<$ ${i_1^+}$.

          \item
            {\em Started By}.
            Interval ${i_0}$ is said to be {\em started by} interval ${i_1}$ if
            and only if ${i_0^-}$ $=$ ${i_1^-}$ and ${i_0^+}$ $>$ ${i_1^+}$.
            Note that this is an inverse of the the {\em starts} relation.

          \item
            {\em Finishes}.
            Interval ${i_0}$ is said to {\em finish} interval ${i_1}$ if and
            only if ${i_0^-}$ $>$ ${i_1^-}$ and ${i_0^+}$ $=$ ${i_1^+}$.

          \item
            {\em Finished By}.
            Interval ${i_0}$ is said to be {\em finished by} interval ${i_1}$
            if and only if ${i_0^-}$ $<$ ${i_1^-}$ and ${i_0^+}$ $=$ ${i_1^+}$.
            Note that this is an inverse of the {\em finishes} relation.

          \item
            {\em Equals}.
            Interval ${i_0}$ {\em equals} interval ${i_1}$ if and only if ${i_0^-}$
            $=$ ${i_1^-}$ and ${i_0^+}$ $=$ ${i_1^+}$.
        \end{itemize}

        For example, given intervals {\em lunch hour} and {\em work hours},
        defined as 1 PM to 2 PM and 9 AM to 5 PM, respectively. Since 1 PM
        (1300 hours) is greater than 9 AM (0900 hours) and 2 PM (1400 hours) is
        less than 5 PM (1700 hours), then the interval {\em lunch hour} is
        {\em during} the interval {\em work hours}.

      \subsection{Inferring New Relations}

        As mentioned earlier, the strength of the algebra is its ability to infer new
        relations from existing ones. This is achieved by taking advantage of the
        transitive properties of relations. For example, given that interval ${i_0}$ is
        {\em before} interval ${i_1}$ and interval ${i_1}$ is {\em before} interval
        ${i_2}$. Regardless of what the end points are, interval ${i_0}$ is 
        {\em before} interval ${i_2}$.

        While simple relations like the one shown in the above example may seem
        intuitive, we quickly realise that it may not be so if we consider that
        a relation that exists between any two intervals may be given as a
        disjunctive set of possible relations. For example, the relation
        between interval ${i_0}$ and interval ${i_1}$ may be given as a set
        of possible relations \{{\em before}, {\em after}, {\em during}\}.

        Another issue is propagation. Given that the temporal knowledge base
        is populated by these disjunctive interval relations, adding new
        pieces of information may narrow down the set of possible relations
        between two intervals. This in turn may lead to the trimming down of
        other relations between other interval pairs. In fact, as new and more
        specific information are added into the knowledge base, its effects may
        propagate to other relations.

        \subsubsection{Interval Relation Network}

          The temporal interval relation knowledge base is represented as a network
          whose nodes represent intervals and the arcs between them represent a set
          of possible relations that hold between the two intervals. Note that although
          this representation allows the assignment of a set of relations between any
          two intervals, because the relations are mutually exclusive, we know that
          only one of these relations actually holds. The fact that some interval
          pairs have a set of relations between them only suggests that the information
          given is insufficient to define the exact relation that holds between the
          intervals.

          The interval relation network is maintained in such a way that each node
          is connected to every other node in the network. In cases where no
          information is given to define an arc, we use the default arc which contains
          a set of all 13 relations. As a matter of convention in the notation, we only
          show one arc between two nodes. The reverse arc, composed of the inverses of
          the relations represented by the first arc, is omitted.

          Figure \ref{fig-net-ex-01} gives an example of a network with three nodes:
          $i_0$, $i_1$ and $i_2$ and the following relations:

          \begin{itemize}
            \item Interval ${i_0}$ is {\em before} or {\em during} interval ${i_1}$.
            \item Interval ${i_1}$ {\em overlaps} interval $i_2$.
          \end{itemize}

          In this example, note that because no relation is defined for intervals
          ${i_0}$ and ${i_2}$, the corresponding arc between these nodes in Figure
          \ref{fig-net-ex-01} is labelled {\em All}, meaning the relation set contains
          all 13 possible relations.

          \begin{figure}[tbhp]
            \begin{center}
              \includegraphics{net-01}
              \caption{Network Representation Example}
              \label{fig-net-ex-01}
            \end{center}
          \end{figure}

        \begin{table}[p]
          \begin{vvarmargin}{-4cm}{-4cm}
            \begin{center}
              \tiny
              \begin{tabular}[t]{|r|l|l|l|l|l|l|l|l|l|l|l|l|}
                \hline
                                        & \textbf{Before}         & \textbf{After}          & \textbf{During}         & \textbf{Contains}       & \textbf{Overlaps}       & \textbf{Overlapped By}  & \textbf{Meets}          & \textbf{Met}            & \textbf{Starts}         & \textbf{Started By}     & \textbf{Finishes}       & \textbf{Finished By}    \\
                                        & (BEF)                   & (BEI)                   & (DUR)                   & (DUI)                   & (OVR)                   & (OVI)                   & (MET)                   & (MEI)                   & (STA)                   & (STI)                   & (FIN)                   & (FII)                   \\
                \hline                                                                                                                                                                                                                                                                                                                                          
                \textbf{Before}         & BEF                     & ALL                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     & BEF                     \\
                (BEF)                   &                         &                         & OVR                     &                         &                         & OVR                     &                         & OVR                     &                         &                         & OVR                     &                         \\ 
                                        &                         &                         & MET                     &                         &                         & MET                     &                         & MET                     &                         &                         & MET                     &                         \\ 
                                        &                         &                         & DUR                     &                         &                         & DUR                     &                         & DUR                     &                         &                         & DUR                     &                         \\
                                        &                         &                         & STA                     &                         &                         & STA                     &                         & STA                     &                         &                         & STA                     &                         \\
                \hline                                                                                                                                                                                                                                                                                                                                         
                \textbf{After}          & ALL                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     & BEI                     \\
                (BEI)                   &                         &                         & OVI                     &                         & OVI                     &                         & OVI                     &                         & OVI                     &                         &                         &                         \\
                                        &                         &                         & MEI                     &                         & MEI                     &                         & MEI                     &                         & MEI                     &                         &                         &                         \\
                                        &                         &                         & DUR                     &                         & DUR                     &                         & DUR                     &                         & DUR                     &                         &                         &                         \\
                                        &                         &                         & FIN                     &                         & FIN                     &                         & FIN                     &                         & FIN                     &                         &                         &                         \\
                \hline                                                                                                                                                                                                                                                                                                                                         
                \textbf{During}         & BEF                     & BEI                     & DUR                     & ALL                     & BEF                     & BEI                     & BEF                     & BEI                     & DUR                     & BEI                     & DUR                     & BEF                     \\
                (DUR)                   &                         &                         &                         &                         & OVI                     & OVI                     &                         &                         &                         & OVI                     &                         & OVR                     \\
                                        &                         &                         &                         &                         & MET                     & MEI                     &                         &                         &                         & MEI                     &                         & MET                     \\
                                        &                         &                         &                         &                         & DUR                     & DUR                     &                         &                         &                         & DUR                     &                         & DUR                     \\
                                        &                         &                         &                         &                         & STI                     & FIN                     &                         &                         &                         & FIN                     &                         & STA                     \\
                \hline
                \textbf{Contains}       & BEF                     & BEI                     & OVR                     & DUI                     & OVR                     & OVI                     & OVR                     & OVI                     & DUI                     & DUI                     & DUI                     & DUI                     \\
                (DUI)                   & MET                     & DUI                     & DUR                     &                         & DUI                     & DUI                     & DUI                     & DUI                     & FII                     &                         & STI                     &                         \\
                                        & DUI                     & MEI                     & STA                     &                         & FII                     & STI                     & FII                     & STI                     & OVR                     &                         & OVI                     &                         \\
                                        & FII                     & STI                     & FIN                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                \hline
                \textbf{Overlaps}       & BEF                     & BEI                     & OVR                     & BEF                     & BEF                     & OVR                     & BEF                     & OVI                     & OVR                     & DUI                     & DUR                     & BEF                     \\
                (OVR)                   &                         & OVI                     & DUR                     & OVR                     & OVR                     & OVI                     &                         & DUI                     &                         & FII                     & STA                     & OVR                     \\
                                        &                         & DUI                     & STA                     & MET                     & MET                     & DUR                     &                         & STI                     &                         & OVR                     & OVR                     & MET                     \\
                                        &                         & MEI                     &                         & DUI                     &                         & STA                     &                         &                         &                         &                         &                         &                         \\
                                        &                         & STI                     &                         & FII                     &                         & FIN                     &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         \\
                \hline
                \textbf{Overlapped By}  & BEF                     & BEI                     & OVI                     & BEI                     & OVR                     & BEI                     & OVR                     & BEI                     & OVI                     & OVI                     & OVI                     & OVI                     \\
                (OVI)                   & OVR                     &                         & DUR                     & OVI                     & OVI                     & OVI                     & DUI                     &                         & DUR                     & BEI                     &                         & DUI                     \\
                                        & MET                     &                         & FIN                     & MEI                     & DUR                     & MEI                     & FII                     &                         & FIN                     & MEI                     &                         & STI                     \\
                                        & DUI                     &                         &                         & DUI                     & STA                     &                         &                         &                         &                         &                         &                         &                         \\
                                        & FII                     &                         &                         & STI                     & FIN                     &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         &                         & EQL                     &                         &                         &                         &                         &                         &                         &                         \\
                \hline
                \textbf{Meets}          & BEF                     & BEI                     & OVR                     & BEF                     & BEF                     & OVR                     & BEF                     & FIN                     & MET                     & MET                     & DUR                     & BEF                     \\  
                (MET)                   &                         & OVI                     & DUR                     &                         &                         & DUR                     &                         & FII                     &                         &                         & STA                     &                         \\
                                        &                         & MEI                     & STA                     &                         &                         & STA                     &                         & EQL                     &                         &                         & OVR                     &                         \\
                                        &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                \hline
                \textbf{Met By}         & BEF                     & BEI                     & OVI                     & BEI                     & OVI                     & BEI                     & STA                     & BEI                     & DUR                     & BEI                     & MEI                     & MEI                     \\
                (MEI)                   & OVR                     &                         & DUR                     &                         & DUR                     &                         & STI                     &                         & FIN                     &                         &                         &                         \\
                                        & MET                     &                         & FIN                     &                         & FIN                     &                         & EQL                     &                         & OVI                     &                         &                         &                         \\
                                        & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                \hline
                \textbf{Starts}         & BEF                     & BEI                     & DUR                     & BEF                     & BEF                     & OVI                     & BEF                     & MEI                     & STA                     & STA                     & DUR                     & BEF                     \\
                (STA)                   &                         &                         &                         & OVR                     & OVR                     & DUR                     &                         &                         &                         & STI                     &                         & MET                     \\
                                        &                         &                         &                         & MET                     & MET                     & FIN                     &                         &                         &                         & EQL                     &                         & OVR                     \\
                                        &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         & FII                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                \hline
                \textbf{Started By}     & BEF                     & BEI                     & OVI                     & DUI                     & OVR                     & OVI                     & OVR                     & MEI                     & STA                     & STI                     & OVI                     & DUI                     \\
                (STI)                   & OVR                     &                         & DUR                     &                         & DUI                     &                         & DUI                     &                         & STI                     &                         &                         &                         \\
                                        & MET                     &                         & FIN                     &                         & FII                     &                         & FII       y             &                         & EQL                     &                         &                         &                         \\
                                        & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        & FII                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                \hline
                \textbf{Finishes}       & BEF                     & BEI                     & DUR                     & BEI                     & OVR                     & BEI                     & MET                     & BEI                     & DUR                     & BEI                     & FIN                     & FIN                     \\
                (FIN)                   &                         &                         &                         & OVI                     & DUR                     & OVI                     &                         &                         &                         & OVI                     &                         & FII                     \\
                                        &                         &                         &                         & MEI                     & STA                     & MEI                     &                         &                         &                         & MEI                     &                         & EQL                     \\
                                        &                         &                         &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         &                         &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         \\
                \hline                                                                                                                                                                                                                                                                                                                                          
                \textbf{Finished By}    & BEF                     & BEI                     & OVR                     & DUI                     & OVR                     & OVI                     & MET                     & STI                     & OVR                     & DUI                     & FIN                     & FII                     \\
                (FII)                   &                         & OVI                     & DUR                     &                         &                         & DUI                     &                         & OVI                     &                         &                         & FII                     &                         \\
                                        &                         & MEI                     & STA                     &                         &                         & STI                     &                         & DUI                     &                         &                         & EQL                     &                         \\
                                        &                         & DUI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                                        &                         & STI                     &                         &                         &                         &                         &                         &                         &                         &                         &                         &                         \\
                \hline
              \end{tabular}
            \end{center}
            \caption[]{Transitivity Table}
            \label{table-trans}
          \end{vvarmargin}
        \end{table}

        \subsubsection{Propagation Algorithm}

          The algorithm works as follows. As a starting point, we assume that the
          network contains complete interval relation information, i.e. at each node,
          there is an arc that connects it to every other node. Where there is no
          defined relationship between two nodes, the default arc is used to connect
          these two nodes. The algorithm is invoked whenever new information is to be
          added into the network. Whenever a new relation is added into the network,
          all consequences of this new relation are also added into the network. These
          consequences are computed through the transitive closure of the network. The
          following example illustrates this procedure.

          Given 3 intervals $i_0$, $i_1$ and $i_2$, and the relation $i_0$ is
          {\em before} $i_1$. Suppose the new relation $i_2$ is {\em during} $i_1$ is
          added into the network. The algorithm then infers that $i_0$ is {\em before}
          $i_2$. This new relation is again added into the network in a similar way,
          possibly inferring other new relations as it is added. This procedure is
          repeated until no new information is yielded.

          Table \ref{table-trans} shows the basic transitivity rules. For any 3
          intervals $i_0$, $i_1$ and $i_2$, the relation(s) between intervals
          $i_0$ and $i_2$ is shown in the intersection of the row that contains the
          the relation between $i_0$ and $i_1$, and the column that contains the
          relation between $i_1$ and $i_2$.

          Before we can define the actual algorithm, we must first define a few
          notational constructs.

          For any single relations $r_0$ and $r_1$, the function $Trans_1$($r_0$, $r_1$)
          returns the relation set $RS$ that corresponds to the intersection of $r_0$
          and $r_1$ in Table \ref{table-trans}.

          Using this function, we can then define the extended function
          $Trans_2$($RS_0$, $RS_1$), which takes a pair of relation sets $RS_0$ and
          $RS_1$ as input, and returns the relation set $RS$ which contains all the
          possible relations inferred from the two given relation sets using the
          $Trans_1$() function.

          \begin{vverbatim}
  FUNCTION \(Trans\sb{2}\)(\(RS\sb{0}\), \(RS\sb{1}\))
    \(RS\) = \(\emptyset\)
    FOR each \(r\sb{0}\) \(\in\) \(RS\sb{0}\) DO
      FOR each \(r\sb{1}\) \(\in\) \(RS\sb{1}\) DO
        \(RS\) = \(RS\) \(\cup\) \(Trans\sb{1}\)(\(r\sb{0}\), \(r\sb{1}\))
      ENDDO
    ENDDO
    RETURN \(RS\)
  ENDFUNCTION
          \end{vverbatim}

          We now define some network operators. The first operator,
          $NET.Get$($I_0$, $I_1$), returns the relation set on the arc between
          interval $I_0$ and interval $I_1$. The function $NET.Replace$($I_0$, $I_1$,
          $RS$) blindly replaces the relation set of the arc between $I_0$ and $I_1$
          with the given relation set $RS$. In addition to these network operators,
          we also define a standard queue structure $Q$ which stores a network arc,
          i.e. a pair of intervals and a relation set that holds between the two
          intervals. Thus, we have three operators for the queue structure:
          $Q.Enqueue$($I_0$, $I_1$, $RS$), which enqueues the given arc; and
          $Q.Dequeue$() which returns and removes the oldest arc stored in the queue
          $Q$; and $Q.IsEmpty$() which returns true if the queue is empty and false
          otherwise.

          With these operators, we can now define the network operator to add new
          relations to the network and propagate its effects.

          \begin{vverbatim}
  FUNCTION \(NET.Add\)(\(I\sb{0}\), \(I\sb{1}\), \(RS\))
    \(Q.Enqueue\)(\(I\sb{0}\), \(I\sb{1}\), \(RS\))
    WHILE NOT \(Q.IsEmpty\)() DO
      \(I\sb{0}'\), \(I\sb{1}'\), \(RS'\) = \(Q.Dequeue\)()
      \(NET.Replace\)(\(I\sb{0}'\), \(I\sb{1}'\), \(RS'\)) 
      FOR each interval \(I''\) \(\in\) \(NET\) DO
        IF \(I''\) != \(I\sb{0}'\) AND \(I''\) != \(I\sb{1}'\) THEN
          \(RS''\) =  \(Trans\sb{2}\)(\(NET.Get\)(\(I''\), \(I\sb{0}'\)), \(RS'\)) 
          \(RS'''\) = \(NET.Get\)(\(I''\), \(I\sb{1}'\)) \(\cap\) \(RS''\)
          IF \(RS'''\) \(\subset\) \(NET.Get\)(\(I''\), \(I\sb{1}'\)) THEN
            \(Q.Add\)(\(I''\), \(I\sb{1}'\), \(RS'''\))
          ENDIF 
        ENDIF
      ENDDO
      FOR each interval \(I''\) \(\in\) \(NET\) DO
        IF \(I''\) != \(I\sb{0}'\) AND \(I''\) != \(I\sb{1}'\) THEN
          \(RS''\) =  \(Trans\sb{2}\)(\(RS'\), \(NET.Get\)(\(I\sb{1}'\), \(I''\)))
          \(RS'''\) = \(NET.Get\)(\(I\sb{0}'\), \(I''\)) \(\cap\) \(RS''\)
          IF \(RS'''\) \(\subset\) \(NET.Get\)(\(I''\), \(I\sb{0}'\)) THEN
            \(Q.Add\)(\(I\sb{0}'\), \(I''\), \(RS'''\))
          ENDIF 
        ENDIF
      ENDDO
    ENDDO
  ENDFUNCTION
          \end{vverbatim}

          The $NET.Add()$ algorithm works as follows. Every time a new arc
          $i_0$, $i_1$ and $rs$ is added, the algorithm finds the transitive
          relation set $RS$ between each of these intervals and every other
          interval $I$ in the network, i.e. the algorithm finds $RS$ =
          $Trans_2$($NET.Get$($I$, $i_0$), $rs$) for every other interval $I$
          in the network. If this new relation set $RS$ contains more specific
          information than what is already in the network, i.e. $RS$ $\subset$
          $NET.Get$($I$, $i_1$), then this new arc between $I$ and $i_1$ (as
          shown in Figure \ref{fig-net-ex-02}) is again put through the same
          algorithm, as it might yield more relation changes.

          \begin{figure}[[tbhp]
            \begin{center}
              \includegraphics{net-02}
              \caption{A new relation $RS$ from interval $I$ and interval $i_1$}
              \label{fig-net-ex-02}
            \end{center}
          \end{figure}

          Note that as shown in Figure \ref{fig-net-ex-03}, the algorithm also
          attempts to form new transitive relations between the given intervals
          $i_0$ and $i_1$ and all other intervals $I$ in the network such that
          interval $I$ is to the right of the other two intervals.

          \begin{figure}[[tbhp]
            \begin{center}
              \includegraphics{net-03}
              \caption{A new relation $RS$ from interval $i_0$ and interval $I$}
              \label{fig-net-ex-03}
            \end{center}
          \end{figure}

          \begin{vexample}
            Given a network with three intervals $i_0$, $i_1$ and $i_2$ where
            no relation between any of the intervals are known. As no relations
            are given, each arc in the network as shown in Figure
            \ref{fig-net-ex-04} is the default arc.

            \begin{figure}[[tbhp]
              \begin{center}
                \includegraphics{net-04}
                \caption{Network with 3 default arcs}
                \label{fig-net-ex-04}
              \end{center}
            \end{figure}

            Now, suppose the relation between interval $i_0$ and interval $i_1$
            is narrowed down to the relation set \{$before$, $meets$,
            $overlaps$\}, i.e., the operation $NET.Add$($i_0$, $i_1$, \{$BEF$,
            $MET$, $OVR$\}) is executed. This operation will yield the network
            shown in Figure \ref{fig-net-ex-05}. Note that because every arc
            in the network contains all relations, the effects of the
            $NET.ADD$() operation are limited to one arc.

            \begin{figure}[[tbhp]
              \begin{center}
                \includegraphics{net-05}
                \caption{Network after $NET.Add$($i_0$, $i_1$, \{$BEF$, $MET$, $OVR$\})}
                \label{fig-net-ex-05}
              \end{center}
            \end{figure}

            Now, if the relation set \{$starts$, $finishes$\} is added to the
            arc between interval $i_1$ and interval $i_2$, the $NET.Add$($i_1$,
            $i_2$, \{$STA$, $FIN$\}) algorithm will also compute the relation
            set $rs_2$ between interval $i_0$ and interval $i_2$ by using the
            relation set $rs_0$ between intervals $i_0$ and interval $i_1$, and
            relation set $rs_1$ between intervals $i_1$ and interval $i_2$ to
            complete the transitivity. In other words, the algorithm computes
            the following:

            \begin{vquote}
              $rs_2$ = $Trans_2$($rs_0$, $rs_1$)

              $rs_2$ = $Trans_2$(\{$BEF$, $MET$, $OVR$\}, \{$STA$, $FIN$\})
            \end{vquote}

            By referring to the transitivity table in Table \ref{table-trans},
            we note the following:

            \begin{vquote}
              $Trans_1$($BEF$, $STA$) = \{$BEF$\}

              $Trans_1$($BEF$, $FIN$) = \{$BEF$, $OVR$, $MET$, $DUR$, $STA$\}

              $Trans_1$($MET$, $STA$) = \{$MET$\}

              $Trans_1$($MET$, $FIN$) = \{$DUR$, $STA$, $OVR$\}

              $Trans_1$($OVR$, $STA$) = \{$OVR$\}

              $Trans_1$($OVR$, $FIN$) = \{$DUR$, $STA$, $OVR$\}
            \end{vquote}

            Therefore, as $Trans_2$() takes the union of all the relation sets
            returned by $Trans_1$(), we have:

            \begin{vquote}
              $rs_2$ = \{$BEF$, $OVR$, $MET$, $DUR$, $STA$\}
            \end{vquote}

            Finally, because $rs_2$ is a subset of $NET.Get$($i_0$, $i_2$), the
            algorithm replaces the arc between $i_0$ and $i_2$ with $rs_2$, as
            shown in Figure \ref{fig-net-ex-06}.

            \begin{figure}[[tbhp]
              \begin{center}
                \includegraphics{net-06}
                \caption{Network after $NET.Add$($i_1$, $i_2$, \{$STA$, $FIN$\})}
                \label{fig-net-ex-06}
              \end{center}
            \end{figure}
          \end{vexample}

    \section{Extensions to Allen's Interval Algebra}

      In an authorisation system, an agent that enforces an authorisation
      policy must be able to match the policy's entities to objects observable
      by the agent, e.g. a subject in the policy is mapped to a user that logs
      in, or an object in the policy is mapped to a certain file in the
      filesystem. Similarly, an agent must also be able to map time intervals
      in a policy to events that are observable by the agent. For example,
      the interval {\em logged\_on} in the policy may be mapped to the time
      between a certain user logs in and out of the system.

      In certain situations, however, it is convenient to map intervals in the
      policy to a particular time scale, such as the agent's real time clock.
      These situations might arise when certain authorisations need to be
      granted or revoked at a certain time, instead of being triggered by
      observable events. To map policy intervals to real time, it is necessary
      to define them in terms of points in real time.

      In the previous section, we have shown that Allen's algebra defines
      temporal intervals as the primitive, where each interval is defined not
      by time points, but by their relationships with other intervals. In this
      section, we will attempt to show the extensions to the interval algebra
      to allow it to express intervals in terms of time points.

      \subsection{Time Points Revisited}

        By allowing time point definitions to be expressed in the algebra, we must
        formally define time points.

        Disregarding the relativistic effects of gravitation and velocity, we make the
        assumption that time is linear, absolute and universal. That is, time always
        flows in one direction: from past to future; that the passage of time as seen
        by one system is the same for any other system; and that all systems define
        time against a universal frame of reference. For simplicity, we further assume
        that time is not a continuous line, but is instead made up of discrete time
        points.

        As this definition goes against the more intuitive notion of continuous time
        lines, one might see the problem of events falling through the gaps between
        the discrete time points in the non-continuous time line.

        To go around this problem, we allow the time point granularity to be chosen
        arbitrarily. Ideally, for a specific application, one would choose a
        granularity that is at least as small as the smallest interval in that
        application. In practice, however, such choices are limited by implementing
        system's clock and other hardware and software latencies.

        In the light bulb and sunrise example in the previous section, if we
        choose a granularity of 1 second, then the switching on of a light bulb is an
        event that occurs at a specific time point. A granularity of 1 second,
        however, means that a sunrise is not an event but an interval, given the fact
        that in most parts of the world, the sun takes a few minutes to rise above the
        horizon. However, if we choose a granularity of 1 hour (and we do not
        live in the polar regions), a sunrise becomes an event that occurs at a single
        point in our chosen time scale. We can therefore argue that given a specific
        time granularity, some events can be treated as instantaneously occurring at a
        specific time point.

        Regardless of the granularity chosen, the domain of time points is the set of
        positive integers ${\mathbb Z}^{+}$.

      \subsection{Defining Intervals in Terms of Time Points}

        \begin{vdefinition}
          \label{def-interval}
          A {\em well-defined interval} $i$ is an interval whose end points $i^{-}$
          $\in$ ${\mathbb Z}^{+}$ and $i^{+}$ $\in$ ${\mathbb Z}^{+}$ are defined,
          where $i^{-}$ $<$ $i^{+}$. A {\em regular interval} is an interval whose
          end points are not known.
        \end{vdefinition}

        Under this definition, we can conclude that for any two well-defined
        intervals there is exactly one interval relation that holds between
        them. We now define a function that will calculate this relation given
        the end points of two well-defined intervals.

        \begin{vverbatim}
  FUNCTION \(Compute\)(\(i\sb{0}\sp{-}\), \(i\sb{0}\sp{+}\), \(i\sb{1}\sp{-}\), \(i\sb{1}\sp{+}\))
    IF \(i\sb{0}\sp{-}\) == \(i\sb{1}\sp{-}\) THEN
      IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{+}\) THEN
        RETURN \{\(equals\}\)
      ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{+}\) THEN
        RETURN \{\(starts\}\)
      ELSE
        RETURN \{\(started by\}\)
      ENDIF 
    ELSE IF \(i\sb{0}\sp{-}\) < \(i\sb{1}\sp{-}\) THEN
      IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{+}\) THEN
        RETURN \{\(finished by\}\)
      ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{+}\) THEN
        IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{-}\) THEN
          RETURN \{\(meets\}\)
        ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{-}\) THEN
          RETURN \{\(before\}\)
        ELSE
          RETURN \{\(overlaps\}\)
        ENDIF
      ELSE
        RETURN \{\(contains\}\)
      ENDIF
    ELSE
      IF \(i\sb{0}\sp{+}\) == \(i\sb{1}\sp{+}\) THEN
        RETURN \{\(finishes\}\)
      ELSE IF \(i\sb{0}\sp{+}\) < \(i\sb{1}\sp{+}\) THEN
        RETURN \{\(during\}\)
      ELSE
        IF \(i\sb{0}\sp{-}\) == \(i\sb{1}\sp{+}\) THEN 
          RETURN \{\(met by\}\)
        ELSE IF \(i\sb{0}\sp{-}\) < \(i\sb{1}\sp{+}\) THEN  
          RETURN \{\(overlapped by\}\)
        ELSE
          RETURN \{\(after\}\)
        ENDIF
      ENDIF
    ENDIF
  ENDFUNCTION
        \end{vverbatim}

        By using the above algorithm, we can now define a new network operator
        $NET.Bind$($I$, $I^-$, $I^+$) that assigns the end points $I^-$ and
        $I^+$ to the existing interval $I$ in the network. By allowing such
        end points to be defined for any interval, thereby making them
        well-defined intervals, we are also allowing the possibility of
        introducing new relations with this interval. Furthermore, any new
        relations gathered by comparing the end points of well-defined
        intervals are subject to the same propagation algorithms shown in the
        previous section. The algorithm below shows how the $NET.Bind$()
        operator achieves this.

        \begin{vverbatim}
  FUNCTION \(NET.Bind\)(\(I\), \(I\sp{-}\), \(I\sp{+}\))
    FOR each interval \(I'\) \(\in\) \(NET\) DO
      IF \(I'\) != \(I\) THEN
        IF \(I'\) is well-defined THEN
          \(RS\) = \(Compute\)(\(I\sp{-}\), \(I\sp{+}\), \(I'\sp{-}\), \(I'\sp{+}\))
          \(NET.Add\)(\(I\), \(I'\), \(RS\))
        ENDIF
      ENDIF
    ENDDO
  ENDFUNCTION
        \end{vverbatim}

      \subsection{Additional Network Operators}

        For the sake of completeness, we also define two additional network
        operators:

        \begin{itemize}
          \item
            $NET.Init$()

            The $NET.Init$() operator initialises or re-initialises the
            network. When executed, the operator causes all intervals and
            relations to be removed from the network.

          \item
            $NET.New$($I$)

            The $NET.New$() operator causes the given interval identifier $I$
            to be added to the network. As the network maintains complete
            information and since the new interval $I$ does not have any known
            relations with any interval in the network, the operator assigns
            the default relation between $I$ and every other interval in the
            network.
        \end{itemize}

    \section{Formalisation}

      In this section, we attempt to formalise a new language, ${\cal L^T}$,
      with the same expressive power as language ${\cal L}$ to represent
      authorisation policies, but with extensions to also express temporal
      constraints.

      \subsection{Syntax}

        \subsubsection{Components of Language ${\cal L^T}$}

          \begin{itemize}

            \item
              {\bf Entity Identifiers}

              As with language ${\cal L}$, language ${\cal L^T}$ includes six
              disjoint entity sorts: subject, access rights, objects, subject
              groups, access right groups and object groups. The syntax for
              each entity type is a single lower case alpha character followed
              by zero or more alphanumeric or underscore characters:

              \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
              \end{vverbatim}

            \item
              {\bf Interval Identifiers}

              The main difference between language ${\cal L}$ and language
              ${\cal L^T}$ is that in addition to the six entity sorts, 
              language ${\cal L^T}$ also includes an additional time interval
              sort. As it occupies a different name space from the other sorts,
              interval identifiers share the same syntax:

              \begin{vverbatim}
  [a-z][a-zA-Z0-9\_]
              \end{vverbatim}

            \item
              {\bf Variable Identifiers}

              In language ${\cal L}$, variable identifiers are used to
              represent entity identifiers. On the other hand, language
              ${\cal L^T}$ variable identifiers are used to represent both
              entity and interval identifiers. To distinguish from entity and
              interval identifiers, the first character of a variable
              identifier is capitalised. Furthermore, the first character of
              a variable identifier indicates its type. For entity variable
              identifiers, the second character may also indicate whether the
              variable represents a single or group entity. The following is a
              list of different variable types and their syntax:

              \begin{itemize}
                \item
                  Subject Variables

                  \begin{vverbatim}
  S[SG][a-zA-Z0-9\_]
                  \end{vverbatim}

                \item
                  Access Right Variables

                  \begin{vverbatim}
  A[SG][a-zA-Z0-9\_]
                  \end{vverbatim}

                \item
                  Object Variables

                  \begin{vverbatim}
  O[SG][a-zA-Z0-9\_]
                  \end{vverbatim}

                \item
                  Interval Variables

                  \begin{vverbatim}
  I[a-zA-Z0-9\_]
                  \end{vverbatim}

              \end{itemize}

            \item
              {\bf Authorisation Atoms, Facts and Expressions}

              Authorisation atoms of language ${\cal L^T}$ are similar to the
              to the atoms of language ${\cal L}$, except each atom includes
              an interval parameter that indicates the time at which that atom
              holds. As with language ${\cal L}$, there are three types of
              atoms:

              \begin{itemize}
                \item
                  Holds Atom. The syntax below shows an atom that states that
                  subject $sub$-$id$ holds the access right $acc$-$id$ for
                  object $obj$-$id$ at time interval $int$-$id$.

                  \begin{vverbatim}
  holds(<sub-id>,
        <acc-id>,
        <obj-id>,
        <int-id>)
                  \end{vverbatim}

                \item
                  Member Atom. The syntax shown below is that of an atom that
                  states that the single entity $single$-$id$ is a member of
                  the group entity $group$-$id$ for the duration specified by
                  interval $int$-$id$.

                  \begin{vverbatim}
  memb(<single-id>, <group-id>, <int-id>)
                  \end{vverbatim}

                \item
                  Subset Atom. Below is the syntax of an atom that states that 
                  the group entity $group$-$id$-$0$ is a subset of the group
                  entity $group$-$id-$-$1$ at time interval $int$-$id$.

                  \begin{vverbatim}
  subst(<group-id-0>, <group-id-1>, <int-id>)
                  \end{vverbatim}

              \end{itemize}

              Like language ${\cal L}$, language ${\cal L^T}$ facts state
              that relationship represented by the corresponding atom its
              negation (as indicated by the "!" character prefix) holds.

              An expression is either a fact or a conjunction of facts
              separated by the comma "," character. An atom, fact or expression
              composed entirely of entity and interval identifiers (no
              variables) are called ground atoms, facts or expressions,
              respectively.

            \item
              {\bf Interval Atoms and Expressions}

              Noting the fact that the inverse relation between any intervals
              $i_0$ and $i_1$ is equal to the relation between intervals
              $i_1$ and $i_0$, for the sake of brevity, language ${\cal L^T}$
              defines only 7 out of the 13 interval relations in the algebra.
              These relations, together with two interval identifiers make up
              the language's interval atoms:

              \begin{vverbatim}
  <rel-id>(<int-id-0>, <int-id-1>)
              \end{vverbatim}

              where $rel$-$id$ indicates the relation between interval
              $int$-$id$-$0$ and interval $int$-$id$-$1$, and is one of the
              following: $equals$, $before$, $during$, $overlaps$, $meets$,
              $starts$ or $finishes$.

              An interval expression in language ${\cal L^T}$ is a group
              of interval atoms separated by the comma "," character. As the
              interval algebra allows disjunctions, the meaning of the comma
              within an interval expression may be conjunctive or disjunctive.
              If an interval expression contains two atoms that differ only by
              their relation (meaning the interval pairs are the same), then
              the comma between these atoms indicates a logical {\em or}.
              Commas between other interval atoms indicate a logical {\em and}.
              For example, the following interval expression is interpreted as
              "interval $i_0$ is before or after interval $i_1$ and interval
              $i_2$ is during interval $i_0$":

              \begin{vverbatim}
  before(i0, i1), before(i1, i0), during(i2, i0)
              \end{vverbatim}

              Like their authorisation counterparts, interval atoms and
              expressions that do not have variable identifiers are called
              ground interval atoms and expressions.

          \end{itemize}

        \subsubsection{Identifier Declarations}

          In language ${\cal L^T}$, both entity and interval identifiers must
          be declared before they are used anywhere in the program. The syntax
          for declaring entity identifiers in language ${\cal L^T}$ is the same
          as the syntax in language ${\cal L}$:

          \begin{vverbatim}
  entity sub|acc|obj[-grp] <ent-id>[, ...];
          \end{vverbatim}

          Interval identifiers may be declared with or without end points. Note
          that once intervals are assigned end points, they are bound to those
          end points for the lifetime of the program. End points, if declared
          with an interval identifier, must be a positive integer as indicated
          in the following syntax:

          \begin{vverbatim}
  interval <int-id> [\(\backslash\)[ep0, ep1\(\backslash\)]][, ... ];
          \end{vverbatim}

          \noindent
          where $ep_0$ $\in$ ${\mathbb Z}^+$, $ep_1$ $\in$ ${\mathbb Z}^+$ and
          $ep_0$ $<$ $ep_1$.

        \subsubsection{Initial Fact Declarations}

          Like language ${\cal L}$, language ${\cal L^T}$ allows the
          declaration of initial state facts. Ground facts declared in this
          manner hold until a policy update causes them to be otherwise. Syntax
          is as follows:

          \begin{vverbatim}
  initially <gnd-auth-exp>;
          \end{vverbatim}

        \subsubsection{Interval Constraint Declarations}

          Relations between intervals are expressed in language ${\cal L^T}$
          through interval constraints. Interval relations defined by interval
          constraints hold for the entire lifetime of the program. Such
          relations in the form of a ground interval expression may be declared
          in the following manner:

          \begin{vverbatim}
  relation <gnd-int-exp>;
          \end{vverbatim}

          The example below declares an interval constraint that states that
          interval $i_0$ is $before$ or $starts$ interval $i_1$, interval $i_1$
          is $during$ or $meets$ interval $i_2$, and interval $i_2$ $meets$
          interval $i_3$:

          \begin{vverbatim}
  relation
    before(i0, i1),
    starts(i0, i1),
    during(i1, i2),
    meets(i1, i2),
    meets(i2, i3);
          \end{vverbatim}

        \subsubsection{Authorisation Constraint Declarations}

          Like the constraint declarations in language ${\cal L}$,
          authorisation constraint declarations in language ${\cal L^T}$ are
          used to define logical rules that always holds, even after a policy
          update is applied. The difference, as shown by the syntax below, is 
          the addition of the {\em where} clause.

          \begin{vverbatim}
  always <auth-exp-0>
    [implied by <auth-exp-1>]
    [with absence <auth-exp-2>]
    [where <int-exp>];
          \end{vverbatim}

          The meaning of the statement is essentially the same as its language
          ${\cal L}$ counterpart: expression $auth$-$exp$-$0$ holds if
          expression $auth$-$exp$-$1$ holds and there is no evidence that
          expression $auth$-$exp$-$2$ holds. Any variables occurring in
          any of these expressions are grounded to all defined entities and
          interval identifiers.

          The {\em where} clause is used to define an interval expression
          $int$-$exp$ which is used to place a restriction on the interval
          identifiers used to ground interval variables occurring in the
          authorisation expressions. Only those sets of interval identifiers
          that satisfy the expresssion $int$-$exp$ is used to replace the
          set of interval variables in the authorisation expressions. As the
          {\em where} clause is used in the grounding of variables, it is
          important to note that it does not make sense to have a ground
          interval expression in the {\em where} clause. Furthermore, not only
          does the expression $int$-$exp$ need to be non-ground, but every atom
          in this expression must also be non-ground.

          For example, given the following authorisation constraint
          declaration:

          \begin{vverbatim}
  always holds(SS, a, o, I0)
    implied by memb(SS, SG0, I1)
    with absence !memb(SS, SG1, I1)
    where starts(I0, I1);
          \end{vverbatim}

          \noindent
          Assuming that \{$ss_0$, $ss_1$\} is the set of single subjects,
          \{$sg_0$, $sg_1$\} is the set of group subjects and \{$i_0$, $i_1$,
          $i_2$\} is the set of intervals defined, with interval $i_0$ $during$
          interval $i_1$ and interval $i_1$ $start$ing interval $i_2$, the
          statement is equivalent to the following statements:

          \begin{vverbatim}
  always holds(ss0, a, o, i1)
    implied by memb(ss0, sg0, i2)
    with absence !memb(ss0, sg1, i2);

  always holds(ss1, a, o, i1)
    implied by memb(ss1, sg0, i2)
    with absence !memb(ss1, sg1, i2);

  always holds(ss0, a, o, i1)
    implied by memb(ss0, sg1, i2)
    with absence !memb(ss0, sg0, i2);

  always holds(ss1, a, o, i1)
    implied by memb(ss1, sg1, i2)
    with absence !memb(ss1, sg0, i2);
          \end{vverbatim}

          Although the entity variables $SS$, $SG_0$ and $SG_1$ are grounded
          to every entity that matches their respective types, the interval
          variables $I_0$ and $I_1$ are restricted to the intervals $i_1$ and
          $i_2$, respectively, because they are the only interval pair that
          satisfies the restriction placed by the {\em where} clause.
        
        \subsubsection{Policy Update Declarations}

          Like the authorisation constraint definition, policy update
          definitions of language ${\cal L^T}$ are similar to those of language
          ${\cal L}$, but with the extra {\em where} clause to limit the
          interval identifiers that are used to ground interval variables that
          may occur in authorisation expressions.

          The syntax below describes the declaration of a policy update
          $update$-$id$ which, when applied, causes the expression
          $auth$-$exp$-$0$ to hold if the expression $auth$-$exp$-$1$ already
          holds.

          \begin{vverbatim}
  <update-id>([<ent-var-0>[, ...]])
    causes <auth-exp-0>
    [if <auth-exp-1>]
    [where <int-exp>];
          \end{vverbatim}

          When a policy update is applied, entity identifiers are supplied for
          each entity variable $ent$-$var$-$n$. These entity identifiers are
          used to ground any matching entity variables that may occur in either
          authorisation expressions $auth$-$exp$-$0$ or $auth$-$exp$-$1$.
          Entity variables occurring in these expressions that do not match
          the variables in the variable list $ent$-$var$-$n$ are replaced by
          all defined entity identifiers that match the variable types.
          Interval variables occurring in the authorisation expressions are
          grounded to sets of interval identifiers that satisfy the interval
          expression $int$-$exp$.

        \subsubsection{Policy Update Directives}

          The policy update directives in language ${\cal L^T}$, like those
          in language ${\cal L}$, are used to manipulate the policy update
          sequence list.

          The three directives below are for adding a policy update into the
          update sequence list, removing an update from the update sequence
          list, and showing the contents of the update sequence list,
          respectively.

          \begin{vverbatim}
  seq add <upd-id>([<id-0>[, ...]]);
  seq del <n>;
  seq list;
          \end{vverbatim}

          The directive is used to apply policy updates one at a time in the
          order in which they appear in the update sequence list.

          \begin{vverbatim}
  compute;
          \end{vverbatim}

        \subsubsection{Query Directives}

          A ground query expression may be given to the system for evaluation.
          The syntax is as follows:

          \begin{vverbatim}
  query <gnd-auth-exp>;
          \end{vverbatim}

          Queries are evaluated against the policy base state derived from the
          application of policy updates in the update sequence list. The system
          response for each query directive either {\em true}, {\em false} or
          {\em unknown}.

      \subsection{Semantics}

        The domain description ${\cal D_{L^T}}$ of language ${\cal L^T}$ is
        a finite set of intervals with end points, initial state facts,
        temporal constraint rules, authorisation constraint rules, policy
        update definitions and an ordered set $\psi$ of policy update
        references.

        Like language ${\cal L}$, the semantics of language ${\cal L^T}$ is
        best described by its translation into an extended logic program,
        language ${\cal L^{T^*}}$. Formally, given a domain description
        ${\cal D_{L^T}}$ of language ${\cal L^T}$, the translation is denoted
        by $Trans$(${\cal D_{L^T}}$).

        The main difference between language ${\cal L^T}$ and language
        ${\cal L^{T^*}}$ is that each atom of the latter also specifies the
        policy update state in which it holds. Another difference between the
        two languages is that the temporal constraints of language ${\cal L^T}$
        is not directly expressed in language ${\cal L^{T^*}}$. Instead, the
        interval algebra discussed at the beginning of this chapter is used by
        the translation process to generate the appropriate authorisation rules
        with respect to the given temporal constraints.

        Before the translation process can be shown, we must first provide
        a formal definition of langauge ${\cal L^{T^*}}$.

        \subsubsection{Language ${\cal L^{T^*}}$}

          As hinted above, language ${\cal L^{T^*}}$ is an extended logic
          program which is composed of facts and rules that expresses an
          authorisation policy. The following are the components of the
          language:

          \begin{itemize}
            \item
              {\bf Entities}

              Like language ${\cal L^*}$, language ${\cal L^{T^*}}$ defines
              a set ${\cal E}$ that contains all the defined subject, access
              right and object (both singles and groups) entities. In addition
              to this set, we also define all its subsets: single subject
              ${\cal E}_{ss}$, single access right ${\cal E}_{as}$, single
              object ${\cal E}_{os}$, group subject ${\cal E}_{sg}$, group
              access right ${\cal E}_{ag}$, group object ${\cal E}_{og}$,
              single and group subjects ${\cal E}_{s}$, single and group access
              rights ${\cal E}_{a}$, and single and group objects
              ${\cal E}_{o}$.

            \item
              {\bf Intervals}

              Language ${\cal L^{T^*}}$ defines a set ${\cal I}$ that contains
              all the defined time intervals from ${\cal D_{L^T}}$.

            \item
              {\bf Atoms}

              A language ${\cal L^{T^*}}$ atom is a binding of a set of
              entities, a temporal interval and a state. The set
              ${\cal A}^\sigma$ contains all the atoms of state $\sigma$.
              The sets ${\cal A}^{\sigma}_{h}$, ${\cal A}^{\sigma}_{m}$ and
              ${\cal A}^{\sigma}_{h}$ denotes all $holds$, $member$ and
              $subset$ atoms of state $\sigma$, respectively, where
              ${\cal A}^\sigma$ = ${\cal A}^{\sigma}_{h}$ $\cup$
              ${\cal A}^{\sigma}_{m}$ $\cup$ ${\cal A}^{\sigma}_{s}$. The
              definitions of these subsets are shown below. To distinguish
              between the atoms of the two languages, atoms of language
              ${\cal L^{T^*}}$ are written with the hat character.

              \begin{vquote}
                ${\cal A}^{\sigma}_{h}$ =
                  $\{\hat{holds}$($s$, $a$, $o$, $\iota$, $\sigma$) $\mid$
                  $s$ $\in$ ${\cal E}_{s}$,
                  $a$ $\in$ ${\cal E}_{a}$,
                  $o$ $\in$ ${\cal E}_{o}$, 
                  $\iota$ $\in$ ${\cal I}\}$ 
    
                ${\cal A}^{\sigma}_{m}$ =
                  ${\cal A}^{\sigma}_{ms}$ $\cup$
                  ${\cal A}^{\sigma}_{ma}$ $\cup$
                  ${\cal A}^{\sigma}_{mo}$
    
                ${\cal A}^{\sigma}_{s}$ =
                  ${\cal A}^{\sigma}_{ss}$ $\cup$
                  ${\cal A}^{\sigma}_{sa}$ $\cup$
                  ${\cal A}^{\sigma}_{so}$
    
                ${\cal A}^{\sigma}_{ms}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{ss}$,
                  $g$ $\in$ ${\cal E}_{sg}$,
                  $\iota$ $\in$ ${\cal I}\}$
    
                ${\cal A}^{\sigma}_{ma}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{as}$,
                  $g$ $\in$ ${\cal E}_{ag}$,
                  $\iota$ $\in$ ${\cal I}\}$
    
                ${\cal A}^{\sigma}_{mo}$ =
                  $\{\hat{memb}$($e$, $g$, $\iota$, $\sigma$) $\mid$
                  $e$ $\in$ ${\cal E}_{os}$,
                  $g$ $\in$ ${\cal E}_{og}$,
                  $\iota$ $\in$ ${\cal I}\}$
    
                ${\cal A}^{\sigma}_{ss}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{sg}$,
                  $\iota$ $\in$ ${\cal I}\}$
    
                ${\cal A}^{\sigma}_{sa}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{ag}$,
                  $\iota$ $\in$ ${\cal I}\}$
    
                ${\cal A}^{\sigma}_{so}$ =
                  $\{\hat{subst}$($g_{1}$, $g_{2}$, $\iota$, $\sigma$) $\mid$
                  $g_{1}$, $g_{2}$ $\in$ ${\cal E}_{og}$,
                  $\iota$ $\in$ ${\cal I}\}$
              \end{vquote}
          
            \item
              {\bf Facts}

              The definition below states that a fact $\hat{\rho}^\sigma$ is a
              logical statement that asserts that an atom $\hat{\alpha}$ either
              holds or does not hold at a given state $\sigma$.

              \begin{vquote}
                $\hat{\rho}^{\sigma}$ =
                  $[\lnot]$$\hat{\alpha}$

                where
                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$
              \end{vquote}

            \item
              {\bf Expressions}

              A language ${\cal L^{T^*}}$ expression is a conjunction of
              facts separated by the comma character. The expression below
              asserts that where $0$ $\leq$ $i$ $\leq$ $n$, each fact
              $\hat{\rho}_i$ holds:

              \begin{vquote}
                $\hat{\rho}_0$, 
                $\hat{\rho}_1$, 
                $\ldots$,
                $\hat{\rho}_n$, 
              \end{vquote}

          \end{itemize}

        \subsubsection{Translating Language ${\cal L^T}$ to Language ${\cal L^{T^*}}$}

          Unlike the translation of language ${\cal L}$ to language
          ${\cal L^*}$, not all statements of language ${\cal L^T}$ is
          translated to language ${\cal L^{T^*}}$. In particular, as language
          ${\cal L^{T^*}}$ does not express relationships between temporal
          intervals, all language ${\cal L^T}$ statements that denote these
          relationships are not directly translated. Through the use of Allen's
          interval algebra, the authorisation rules that result from the
          consequences of these temporal relations are generated instead.

          To describe the details of the translation $Trans$(${\cal D_{L^T}}$),
          we first define some translation functions similar to
          [XXX ref to ${\cal L}$].

          \begin{itemize}

            \item
              The $Res$($u$, $\sigma$) function takes as input a policy update
              $u$ $\in$ $\psi$ and a policy state $\sigma$, and returns the
              policy state that results from applying the update $u$ upon
              state $\sigma$.

            \item
              The $CopyAtom$($\hat{\alpha}$, $\sigma$) function takes as input
              an atom $\hat{\alpha}$ of language ${\cal L^{T^*}}$ and some
              state $\sigma$, then returns an atom with the same type and with
              the same entities and interval as atom $\hat{\alpha}$, but with
              state $\sigma$ instead of the original state specified by
              $\hat{\alpha}$.

            \item
              The $TransAtom$($\alpha$, $\sigma$) function takes as input an
              atom $\alpha$ of language ${\cal L^T}$ and some state $\sigma$,
              then returns an equivalent atom of language ${\cal L^{T^*}}$
              with the same entities and interval specified by $\alpha$.

            \item
              The $TransFact$($\rho$, $\sigma$) function is similar to the
              $TransAtom$ function, but instead of translating an atom, it
              takes a language ${\cal L^T}$ fact $\rho$ and some state $\sigma$
              then returns the equivalent language ${\cal L}^{T^*}$ fact.
          \end{itemize}

          With these functions defined, we can now outline the translation
          process:

          \begin{itemize}

            \item
              {\bf Initialising the Temporal Interval Relation Network}

              The first step in the translation is to initialise the interval
              relation network with all the temporal intervals and all the
              given end points defined in language ${\cal L^T}$. Recall that
              there are two ways a temporal interval may be declared in
              language ${\cal L^T}$:

              \begin{vverbatim}
  interval \(\iota\);
  interval \(\iota\) [\(ep\sb{0}\), \(ep\sb{1}\)];
              \end{vverbatim}

              All intervals $\iota$ declared by using the first form are added
              to the interval network through a call to the following function:

              \begin{vquote}
                $NET.New$($\iota$)
              \end{vquote}

              All intervals $\iota$ declared by using the second form, i.e.,
              with end points $ep_0$ and $ep_1$, are added to the network
              through the following functions:

              \begin{vquote}
                $NET.New$($\iota$)

                $NET.Bind$($\iota$, $ep_0$, $ep_1$)
              \end{vquote}

            \item
              {\bf Populating the Temporal Interval Relation Network}

              The next step is to encode all temporal constraints in
              language ${\cal L^T}$ as interval relations in the interval
              relation network. Temporal constraints are declared in language
              ${\cal L^T}$ in the following way:

              \begin{vverbatim}
  relation \(\alpha\sb{0}\), \(\ldots\), \(\alpha\sb{n}\);
              \end{vverbatim}

              Note that each interval atom ${\alpha}_i$ above is in the form
              $r_i$(${\iota}0_i$, ${\iota}1_i$), where $r_i$ $\in$ \{$equals$,
              $before$, $\ldots$\}, ${\iota}0_i$, ${\iota}1_i$ $\in$
              ${\cal I}$ and $0$ $\leq$ $i$ $\leq$ $n$. We further note that
              under this notation, it is possible to encounter a situation
              where two different interval atoms ${\alpha}_i$ and ${\alpha}_j$
              can both contain the same pair of intervals:

              \begin{vquote}
                ${\alpha}_i$ $=$ $r_i$(${\iota}0_i$, ${\iota}1_i$) 

                ${\alpha}_j$ $=$ $r_j$(${\iota}0_j$, ${\iota}1_j$)

                where

                \hspace{1em}
                $i$ $\neq$ $j$,

                \hspace{1em}
                $r_i$ $\neq$ $r_j$,

                \hspace{1em}
                ${\iota}0_i$ $=$ ${\iota}0_j$,

                \hspace{1em}
                ${\iota}1_i$ $=$ ${\iota}1_j$
              \end{vquote}

              According to the syntax definition of interval atoms in the
              previous section, in any given interval expression, all interval
              atom pairs that satisfies the above condition are to be treated
              as disjunctions in that expression, while those that do not are
              to be treated as conjunctions.

              For simplicity, we introduce a normalised notation for interval
              expressions where each interval atom in the expression contains a 
              unique pair of intervals and a set of relations that hold between
              those intervals. Formally, a normalised interval expression is
              in the following form:

              \begin{vquote}
                ${\alpha}_0$, $\ldots$, ${\alpha}_n$
              \end{vquote}

              \noindent
              where each interval atom ${\alpha}_i$ ($0$ $\leq$ $i$ $\leq$ $n$)
              in the form:

              \begin{vquote}
                ${\alpha}_i$ =
                  (${\iota}0_i$, ${\iota}1_i$, \{$r0_i$, $\ldots$, $rx_i$\})
              \end{vquote}

              \noindent
              satisfies the following condition:

              \begin{vquote}
                $\lnot$$\exists$${\alpha}_j$,

                where 

                \hspace{1em}
                ${\alpha}_j$ =
                  (${\iota}0_j$, ${\iota}1_j$, \{$r0_j$, $\ldots$, $ry_j$\})

                \hspace{1em}
                $0$ $\leq$ $j$ $\leq$ $n$,

                \hspace{1em}
                $i$ $\neq$ $j$

                such that

                \hspace{1em}
                ${\iota}0_i$ $=$ ${\iota}0_j$,

                \hspace{1em}
                ${\iota}1_i$ $=$ ${\iota}1_j$
              \end{vquote}

              Now, we define a function $Normalise$($\varepsilon$) that takes
              a language ${\cal L^T}$ interval expression $\varepsilon$ as
              input and returns the normalised equivalent of that expression in
              the form shown above. Formally, we have:

              \begin{vquote}
                ${\varepsilon}'$ $=$ $Normalise$($\varepsilon$)
              \end{vquote}

              \noindent
              For each
              (${\iota}0_i$, ${\iota}1_i$, \{$r0_i$, $\ldots$, $rx_i$\})
              $\in$ ${\varepsilon}'$,
              where $0$ $\leq$ $i$ $<$ $|{\varepsilon}'|$, the following
              conditions are satisfied:

              \begin{itemize}
                \item
                  For each $r_j$ $\in$ \{$r0_i$, $\ldots$, $rx_i$\}, where $0$
                  $\leq$ $j$ $\leq$ $i$, there exists an
                  $r_j$(${\iota}0_i$, ${\iota}1_i$) $\in$ $\varepsilon$

                \item
                  For each 
                  (${\iota}0_j$, ${\iota}1_j$, \{$r0_j$, $\ldots$, $ry_j$\})
                  $\in$ ${\varepsilon}'$, where $0$ $\leq$ $j$ $<$
                  $|{\varepsilon}'|$ and $i$ $\neq$ $j$, 
                  (
                    ${\iota}0_i$ $\neq$ ${\iota}0_j$ $\lor$
                    ${\iota}1_i$ $\neq$ ${\iota}1_j$
                  )
              \end{itemize}

              With the $Normalise$() function defined, we can now populate the
              interval relation network with relations expressed in language
              ${\cal L^T}$ interval constraint statements. The steps involved
              to achieve this is as follows. For each interval constraint
              statement in language ${\cal L^T}$:

              \begin{vverbatim}
  relation \(\alpha\sb{0}\), \(\ldots\), \(\alpha\sb{n}\);
              \end{vverbatim}

              Now, by using the $Normalise$() function, we obtain a normalised
              expression $\varepsilon$:

              \begin{vquote}
                $\varepsilon$ $=$
                  $Normalise$(\{${\alpha}_0$, $\ldots$, ${\alpha}_n$\})
              \end{vquote}

              Finally, to register the interval constraint to the interval
              relation network, we make a call to the following operator
              for each (${\iota}0_i$, ${\iota}1_i$, $rs_i$) $\in$
              $\varepsilon$, where $0$ $\leq$ $i$ $<$ $|\varepsilon|$:

              \begin{vverbatim}
  \(NET.Add\)(\({\iota}0\sb{i}\), \({\iota}1\sb{i}\), \(rs\sb{i}\))
              \end{vverbatim}

            \item
              {\bf Variable Grounding}

              As language ${\cal L^{T^*}}$ does not allow variables, all
	      language ${\cal L^T}$ expressions containing entity or interval
              variables must be grounded in the translation process. Although
              the task of grounding entity variables is a relatively
              straightforward procedure, grounding interval variables involves
              additional steps due to the {\em where} clause of the language.
              After generating the tuples to replace the variables, each of
              these tuples must also be checked to ensure that they satisfy
              any given temporal constraints.

              Before we can describe the grounding process in greater detail,
              we first define the following three functions:

              \begin{itemize}
                \item
                  $Type$($ev$)

                  The $Type$($ev$) function returns the type of the given
                  entity or variable $ev$: $interval$, $single$-$subject$,
                  $group$-$subject$, $single$-$access$-$right$, etc.

                \item
                  $Var$($\varepsilon$)

                  Given a non-ground language ${\cal L^T}$ authorisation or
                  interval expression $\varepsilon$, this function returns
                  a set of unique variables that occurs in $\varepsilon$. If
                  $\varepsilon$ is ground, the function returns $\emptyset$.

                \item
                  $Replace$($\varepsilon$, $V$, $t$)

                  The function takes the following as input: a non-ground
                  language ${\cal L^T}$ authorisation or interval expression
                  $\varepsilon$, a set of variables $V$ that occur in
                  $\varepsilon$, and a tuple $t$ containing entities and
                  intervals that correspond to the variables in $V$ ($|V|$ $=$
                  $|t|$ and $\forall$$i$, $0$ $\leq$ $i$ $<$ $|V|$,
                  $Type$($V_i$) $=$ $Type$($t_i$)). The function returns
                  $\varepsilon$ with all variable occurences replaced with the
                  corresponding entities or intervals from $t$. If
                  $\varepsilon$ is a ground expression, $\varepsilon$ is
                  returned.
              \end{itemize}

              With these functions defined, we can now generalise the process
              of grounding both entity and interval variables. Given a set $V$
              of unique entity and interval variables, the function below
              returns a set of all possible $|V|$-tuples that can be used to
              replace the variables in $V$:

              \begin{vquote}
                $GenTuples_1$($V$) $=$
                $R_0$ $\times$ $\ldots$ $\times$ $R_{|V|-1}$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\forall$ $i$, $0$ $\leq$ $i$ $<$ $|V|$,

                \hspace{1em}
                $R_i$ $=$
                \begin{math}
                  \begin{cases}
                    \mbox{${\cal E}_s$, if $Type$($V_i$) $=$ {\em subject}} \\
                    \mbox{${\cal E}_a$, if $Type$($V_i$) $=$ {\em access right}} \\
                    \vdots \\
                    \mbox{${\cal I}$, if $Type$($V_i$) $=$ {\em interval}}
                  \end{cases}
                \end{math}
              \end{vquote}

              A variation of this function, shown below, generates tuples
              with respect to a given temporal constraint. Given a language
              ${\cal L^T}$ {\em where} clause with an interval expression
              $\varepsilon$ and a set $V$ of variables that occur in
              $\varepsilon$, the following function returns a set of
              $|V|$-tuples, where each tuple satisfies the condition given
              in $\varepsilon$:

              \begin{vquote}
                $GenTuples_2$($\varepsilon$, $V$)
                $=$ \{$t_0$, $\ldots$, $t_{|V|-1}$\}
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\forall$ $i$, $0$ $\leq$ $i$ $<$ $|V|$,
                $t_i$ $\in$ $GenTuples_1$($V$),

                \hspace{1em}
                $\varepsilon'$ $=$
                $Normalise$($Replace$($\varepsilon$, $V$, $t_i$)),

                \hspace{1em}
                $\forall$ (${\iota}_0$, ${\iota}_1$, $rs$) $\in$
                $\varepsilon'$,
                $NET.Get$(${\iota}_0$, ${\iota}_1$) $\subseteq$ $rs$
              \end{vquote}

            \item
              {\bf Initial Fact Rules}

              The initial fact rules are obtained directly from initial fact
              declaration statements of languague ${\cal L^T}$:

              \begin{vverbatim}
  initially \(\rho\sb{0}\), \(\ldots\), \(\rho\sb{n}\);
              \end{vverbatim}

              Each initial fact declaration statement of language ${\cal L^T}$
              in the form above corresponds to the following language
              ${\cal L^{T^*}}$ rules:

              \begin{vquote}
                $\hat{\rho_i}$ $\leftarrow$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{\rho_i}$ $=$ $TransFact$($\rho_i$, $S_0$),

                \hspace{1em}
                $0$ $\leq$ $i$ $\leq$ $n$
              \end{vquote}

            \item
              {\bf Authorisation Constraint Rules}

              An authorisation constraint statement in language ${\cal L^T}$
              is in the form:

              \begin{vverbatim}
  always \(a\sb{0}\), \(\ldots\), \(a\sb{m}\)
    implied by \(b\sb{0}\), \(\ldots\), \(b\sb{n}\)
    with absence \(c\sb{0}\), \(\ldots\), \(c\sb{o}\)
    where \(d\sb{0}\), \(\ldots\), \(d\sb{p}\);
              \end{vverbatim}

              The first step is to gather all the entity and interval
              variables that occur in all the expressions above into a set $V$:

              \begin{vquote}
                $V$ $=$

                \hspace{1em}
                $Var$(($a_0$, $\ldots$, $a_m$)) $\cup$

                \hspace{1em}
                $Var$(($b_0$, $\ldots$, $b_n$)) $\cup$

                \hspace{1em}
                $Var$(($c_0$, $\ldots$, $c_o$)) $\cup$

                \hspace{1em}
                $Var$(($d_0$, $\ldots$, $d_p$))
              \end{vquote}

              \noindent
              Using the set $V$, we generate a set of tuples $T$ that satisfies
              the temporal constraint specified by the {\em where} clause:

              \begin{vquote}
                $T$ $=$ $GenTuples_2$(($d_0$, $\ldots$, $d_p$), $V$)
              \end{vquote}

              \noindent
              Finally, the language ${\cal L^{T^*}}$ equivalent of the
              authorisation constraint rule is the following rules:

              \begin{vquote}
                $\forall$ ($t$, $\sigma$),
              \end{vquote}

              \begin{vquote}
                $\hat{a}^{\sigma}_{0}$ $\leftarrow$
                $\hat{b}^{\sigma}_{0}$, \ldots, $\hat{b}^{\sigma}_{n}$,
                $not$ $\hat{c}^{\sigma}_{0}$, \ldots, $not$ $\hat{c}^{\sigma}_{o}$

                $\vdots$

                $\hat{a}^{\sigma}_{m}$ $\leftarrow$
                $\hat{b}^{\sigma}_{0}$, \ldots, $\hat{b}^{\sigma}_{n}$,
                $not$ $\hat{c}^{\sigma}_{0}$, \ldots, $not$ $\hat{c}^{\sigma}_{o}$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{a}^{\sigma}_{i}$ = $TransFact$($Replace$($a_{i}$, $V$, $t$), $\sigma$),
                $0$ $\leq$ $i$ $\leq$ $m$,
    
                \hspace{1em}
                $\hat{b}^{\sigma}_{j}$ = $TransFact$($Replace$($b_{j}$, $V$, $t$), $\sigma$),
                $0$ $\leq$ $j$ $\leq$ $n$,
    
                \hspace{1em}
                $\hat{c}^{\sigma}_{k}$ = $TransFact$($Replace$($c_{k}$, $V$, $t$), $\sigma$),
                $0$ $\leq$ $k$ $\leq$ $o$,
    
                \hspace{1em}
                $t$ $\in$ $T$,

                \hspace{1em}
                $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
              \end{vquote}
            
            \item
              {\bf Policy Update Rules}

              Obviously, only language ${\cal L^T}$ policy update statements
              that are applied to the policy are actually translated to
              language ${\cal L^{T^*}}$ rules. The translation process for
              these rules are again similar to that of language ${\cal L^*}$,
              except this time, the variable grounding is subject to the
              constraints specified by the {\em where} clause. A language
              ${\cal L^T}$ policy update statement is shown below:

              \begin{vverbatim}
  \(u\) causes \(a\sb{0}\), \(\ldots\), \(a\sb{m}\)
  if \(b\sb{0}\), \(\ldots\), \(b\sb{n}\)
  where \(c\sb{0}\), \(\ldots\), \(c\sb{o}\);
              \end{vverbatim}

              \noindent
              Like the authorisation constraint rules, the first step in the
              translation process is to generate a set $V$ of entity and
              interval variables that occur in all the expressions:

              \begin{vquote}
                $V$ $=$
                $Var$($a_0$, $\ldots$, $a_m$) $\cup$
                $Var$($b_0$, $\ldots$, $b_n$)
              \end{vquote}

              \noindent
              With the variable set $V$ and a {\em where} clause expression
              ($c_0$, $\ldots$, $c_o$), a set of tuples $T$ can be generated
              such that each tuple $t$ $\in$ $T$ satisfies the {\em where}
              clause constraint:
            
              \begin{vquote}
                $T$ $=$
                $GenTuples_2$(($c_0$, $\ldots$, $c_o$), $V$)
              \end{vquote}

              \noindent
              By using the entities and intervals in each tuple in set $T$
              to ground all the variables, we can now define the policy
              update rules in language ${\cal L^{T^*}}$:
              
              \begin{vquote}
                $\forall$ $t$,
              \end{vquote}

              \begin{vquote}
                $\hat{a_0}$ $\leftarrow$ $\hat{b_0}$, $\ldots$, $\hat{b_n}$

                $\vdots$

                $\hat{a_m}$ $\leftarrow$ $\hat{b_0}$, $\ldots$, $\hat{b_n}$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{a_i}$ $=$ $TransFact$($Replace$($a_i$, $V$, $t$), $Res$($u$, $\sigma$)), $0$ $\leq$ $i$ $\leq$ $m$,

                \hspace{1em}
                $\hat{b_j}$ $=$ $TransFact$($Replace$($b_j$, $V$, $t$), $\sigma$), $0$ $\leq$ $j$ $\leq$ $n$,

                \hspace{1em}
                $t$ $\in$ $T$,

                \hspace{1em}
                $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
              \end{vquote}

            \item
              {\bf Inheritance Rules}

                As with language ${\cal L^*}$, a set of language
                ${\cal L^{T^*}}$ rules are needed to express the inheritance
                properties of members and subsets. While these rules are
                similar to their respective language ${\cal L^*}$ counterparts,
                the definitions are slightly different due to the
                representation of temporal intervals.

                \begin{itemize}
                  \item
                    {\bf Subject Group Member Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($ss$, $sg$, $a$, $o$, $\iota$ $\sigma$),
                    \end{vquote}
                   
                    \begin{vquote}
                      $\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($sg$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($ss$, $sg$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                    \end{vquote}
                   
                    \begin{vquote}
                      $\lnot\hat{holds}$($ss$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($sg$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($ss$, $sg$, $\iota$, $\sigma$)
                    \end{vquote}
                   
                    \begin{vquote}
                      where
                   
                      \hspace{1em}
                      $ss$ $\in$ ${\cal E}_{ss}$,

                      \hspace{1em}
                      $sg$ $\in$ ${\cal E}_{sg}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}
                   
                  \item
                    {\bf Access Right Group Member Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $as$, $ag$, $o$, $\iota$ $\sigma$),
                    \end{vquote} 
                   
                    \begin{vquote}
                      $\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $ag$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($as$, $ag$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                    \end{vquote} 
                   
                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $as$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $ag$, $o$, $\iota$, $\sigma$),
                      $\hat{memb}$($as$, $ag$, $\iota$, $\sigma$)
                    \end{vquote} 
                   
                    \begin{vquote}
                      where
                   
                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $as$ $\in$ ${\cal E}_{as}$,

                      \hspace{1em}
                      $ag$ $\in$ ${\cal E}_{ag}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote} 

                  \item
                    {\bf Object Group Member Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $a$, $os$, $og$, $\iota$ $\sigma$),
                    \end{vquote}
                   
                    \begin{vquote}
                      $\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\hat{holds}$($s$, $a$, $og$, $\iota$, $\sigma$),
                      $\hat{memb}$($os$, $og$, $\iota$, $\sigma$),

                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                    \end{vquote}
                   
                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a$, $os$, $\iota$, $\sigma$)
                      $\leftarrow$

                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a$, $og$, $\iota$, $\sigma$),
                      $\hat{memb}$($os$, $og$, $\iota$, $\sigma$)
                    \end{vquote}
                   
                    \begin{vquote}
                      where
                   
                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $os$ $\in$ ${\cal E}_{os}$,

                      \hspace{1em}
                      $og$ $\in$ ${\cal E}_{og}$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    {\bf Subject Group Subset Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($sg_1$, $sg_2$, $a$, $o$, $\iota$, $\sigma$),
                    \end{vquote}
                    
                    \begin{vquote}
                      $\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$
                    
                      \hspace{1em}
                      $\hat{holds}$($sg_2$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($sg_1$, $sg_2$, $\iota$, $\sigma$),
                    
                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$)
                    \end{vquote}
                    
                    \begin{vquote}
                      $\lnot\hat{holds}$($sg_1$, $a$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$
                    
                      \hspace{1em}
                      $\lnot\hat{holds}$($sg_2$, $a$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($sg_1$, $sg_2$, $\iota$, $\sigma$)
                    \end{vquote}
                    
                    \begin{vquote}
                      where
                    
                      \hspace{1em}
                      $sg_1$, $sg_2$ $\in$ ${\cal E}_{sg}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $sg_1$ $\neq$ $sg_2$,

                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,
                    
                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                  \item
                    {\bf Access Right Group Subset Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $ag_1$, $ag_2$, $o$, $\iota$, $\sigma$),
                    \end{vquote}
                    
                    \begin{vquote}
                      $\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$
                    
                      \hspace{1em}
                      $\hat{holds}$($s$, $ag_2$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($ag_1$, $ag_2$, $\iota$, $\sigma$),
                    
                      \hspace{1em}
                      $not$ $\lnot$ $\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$)
                    \end{vquote}
                    
                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $ag_1$, $o$, $\iota$, $\sigma$)
                      $\leftarrow$
                    
                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $ag_2$, $o$, $\iota$, $\sigma$),
                      $\hat{subst}$($ag_1$, $ag_2$, $\iota$, $\sigma$)
                    \end{vquote}
                    
                    \begin{vquote}
                      where
                    
                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $ag_1$, $ag_2$ $\in$ ${\cal E}_{ag}$,

                      \hspace{1em}
                      $o$ $\in$ ${\cal E}_{o}$,

                      \hspace{1em}
                      $ag_1$ $\neq$ $ag_2$,
                    
                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                  \item
                    {\bf Object Group Subset Inheritance Rules}

                    \begin{vquote}
                      $\forall$ ($s$, $a$, $og_1$, $og_2$, $\iota$, $\sigma$),
                    \end{vquote}
                    
                    \begin{vquote}
                      $\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$)
                      $\leftarrow$
                    
                      \hspace{1em}
                      $\hat{holds}$($s$, $a$, $og_2$, $\iota$, $\sigma$),
                      $\hat{subst}$($og_1$, $og_2$, $\iota$, $\sigma$),
                    
                      \hspace{1em}
                      $not$ $\lnot\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$)
                    \end{vquote}
                    
                    \begin{vquote}
                      $\lnot\hat{holds}$($s$, $a$, $og_1$, $\iota$, $\sigma$)
                      $\leftarrow$
                    
                      \hspace{1em}
                      $\lnot\hat{holds}$($s$, $a$, $og_2$, $\iota$, $\sigma$),
                      $\hat{subst}$($og_1$, $og_2$, $\iota$, $\sigma$)
                    \end{vquote}
                    
                    \begin{vquote}
                      where
                    
                      \hspace{1em}
                      $s$ $\in$ ${\cal E}_{s}$,

                      \hspace{1em}
                      $a$ $\in$ ${\cal E}_{a}$,

                      \hspace{1em}
                      $og_1$, $og_2$ $\in$ ${\cal E}_{og}$,

                      \hspace{1em}
                      $og_1$ $\neq$ $og_2$,
                    
                      \hspace{1em}
                      $\iota$ $\in$ ${\cal I}$,

                      \hspace{1em}
                      $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                    \end{vquote}

                \end{itemize}
            
            \item
              {\bf Transitivity Rules}

              Like their language ${\cal L^*}$ counterparts, these rules ensure
              that for any three distinct groups $g_0$, $g_1$ and $g_2$, if
              $g_0$ is a subset of $g_1$ and $g_1$ is a subset of $g_2$, then
              $g_0$ is also a subset of $g_2$.

              \begin{itemize}
                \item
                  {\bf Subject Group Transitivity Rules}

                  \begin{vquote}
                    $\forall$ ($sg_{1}$, $sg_{2}$, $sg_{3}$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($sg_{1}$, $sg_{3}$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{subst}$($sg_{1}$, $sg_{2}$, $\iota$, $\sigma$),
                    $\hat{subst}$($sg_{2}$, $sg_{3}$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $sg_{1}$, $sg_{2}$, $sg_{3}$ $\in$ ${\cal E}_{sg}$,

                    \hspace{1em}
                    $sg_{1}$ $\neq$ $sg_{2}$ $\neq$ $sg_{3}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}

                \item
                  {\bf Access Right Group Transitivity Rules}

                  \begin{vquote}
                    $\forall$ ($ag_{1}$, $ag_{2}$, $ag_{3}$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($ag_{1}$, $ag_{3}$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{subst}$($ag_{1}$, $ag_{2}$, $\iota$, $\sigma$),
                    $\hat{subst}$($ag_{2}$, $ag_{3}$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $ag_{1}$, $ag_{2}$, $ag_{3}$ $\in$ ${\cal E}_{ag}$,

                    \hspace{1em}
                    $ag_{1}$ $\neq$ $ag_{2}$ $\neq$ $ag_{3}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}
                \item
                  {\bf Object Group Transitivity Rules}

                  \begin{vquote}
                    $\forall$ ($og_{1}$, $og_{2}$, $og_{3}$, $\iota$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{subst}$($og_{1}$, $og_{3}$, $\iota$, $\sigma$)
                    $\leftarrow$

                    \hspace{1em}
                    $\hat{subst}$($og_{1}$, $og_{2}$, $\iota$, $\sigma$),
                    $\hat{subst}$($og_{2}$, $og_{3}$, $\iota$, $\sigma$)
                  \end{vquote}

                  \begin{vquote}
                    where

                    \hspace{1em}
                    $og_{1}$, $og_{2}$, $og_{3}$ $\in$ ${\cal E}_{og}$,

                    \hspace{1em}
                    $og_{1}$ $\neq$ $og_{2}$ $\neq$ $og_{3}$,

                    \hspace{1em}
                    $\iota$ $\in$ ${\cal I}$,

                    \hspace{1em}
                    $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
                  \end{vquote}
              \end{itemize}
            
            \item
              {\bf Inertial Rules}

              The same rules of inertia expressed in language ${\cal L^*}$
              applies to language ${\cal L^{T^*}}$: every fact $\hat{\rho}$
              that holds in state $\sigma$ must also hold in state
              $Res$($u$, $\sigma$) after policy update $u$ is applied,
              provided that update $u$ does not cause the fact
              $\lnot\hat{\rho}$ to hold.

              \begin{vquote}
                $\forall$ ($\hat{\alpha}$,$u$),
              \end{vquote}

              \begin{vquote}
                $\hat{\alpha}'$
                $\leftarrow$
                $\hat{\alpha}$,
                $not$ $\lnot$ $\hat{\alpha}'$
              \end{vquote}

              \begin{vquote}
                $\lnot$ $\hat{\alpha}'$
                $\leftarrow$ $\lnot$
                $\hat{\alpha}$,
                $not$ $\hat{\alpha}'$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $\hat{\alpha}$ $\in$ ${\cal A}^{\sigma}$,

                \hspace{1em}
                $u$ $\in$ $\psi$,

                \hspace{1em}
                $\hat{\alpha}'$ = $CopyAtom$($\hat{\alpha}$, $Res$($u$, $\sigma$))
              \end{vquote}
            
            \item
              {\bf Reflexivity Rules}

              These rules ensure that the reflexive property of sets are
              preserved: every set is a subset of itself.

              \begin{vquote}
                $\forall$ ($g$, $\iota$, $\sigma$),
              \end{vquote}

              \begin{vquote}
                $\hat{subst}$($g$, $g$, $\iota$, $\sigma$) $\leftarrow$
              \end{vquote}

              \begin{vquote}
                where

                \hspace{1em}
                $g$ $\in$ (${\cal E}_{sg}$ $\cup$ ${\cal E}_{ag}$ $\cup$ ${\cal E}_{og}$),

                \hspace{1em}
                $\iota$ $\in$ ${\cal I}$,

                \hspace{1em}
                $S_{0}$ $\leq$ $\sigma$ $\leq$ $S_{|\psi|}$
              \end{vquote}
            
            \item
              {\bf Temporal Rules}

              The temporal rules are based on the fact that if a fact
              $\hat{\rho}$ holds at interval $\iota$, then the same fact
              $\hat{\rho}$ must also hold at all intervals $\iota'$ where
              the relation between intervals $\iota$ and $\iota'$ is
              {\em Equals}, {\em During}, {\em Starts} or {\em Finishes}.

              \begin{itemize}
              
                \item
                  {\bf Holds Temporal Rules}

                  \begin{vquote}
                    $\forall$($s$, $a$, $o$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}
                  
                  \begin{vquote}
                    $\hat{holds}$($s$, $a$, $o$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                    
                    $\hat{holds}$($s$, $a$, $o$, $\iota_0$, $\sigma$)
                  \end{vquote}
                  
                  \begin{vquote}
                    $\lnot$ $\hat{holds}$($s$, $a$, $o$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                            
                    $\lnot$ $\hat{holds}$($s$, $a$, $o$, $\iota_0$, $\sigma$)
                  \end{vquote}
                  
                  \begin{vquote}
                    where
                  
                    \hspace{1em}
                    $s$ $\in$ ${\cal E}_s$,
                  
                    \hspace{1em}
                    $a$ $\in$ ${\cal E}_a$,
                  
                    \hspace{1em}
                    $0$ $\in$ ${\cal E}_o$,
                  
                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,
                  
                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},
                  
                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}
              
                \item
                  {\bf Membership Temporal Rules}
              
                  \begin{vquote}
                    $\forall$($ss$, $sg$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}

                  \begin{vquote}
                    $\hat{memb}$($ss$, $sg$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                
                    $\hat{memb}$($ss$, $sg$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    $\lnot$ $\hat{memb}$($ss$, $sg$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                        
                    $\lnot$ $\hat{memb}$($ss$, $sg$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    where
                  
                    \hspace{1em}
                    $ss$ $\in$ ${\cal E}_{ss}$,
                  
                    \hspace{1em}
                    $sg$ $\in$ ${\cal E}_{sg}$,
                  
                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,
                  
                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},
                  
                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                  \vspace{0.5em}
              
                  \begin{vquote}
                    $\forall$($as$, $ag$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}
              
                  \begin{vquote}
                    $\hat{memb}$($as$, $ag$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                
                    $\hat{memb}$($as$, $ag$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    $\lnot$ $\hat{memb}$($as$, $ag$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                        
                    $\lnot$ $\hat{memb}$($as$, $ag$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    where
                  
                    \hspace{1em}
                    $as$ $\in$ ${\cal E}_{as}$,
                  
                    \hspace{1em}
                    $ag$ $\in$ ${\cal E}_{ag}$,
                  
                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,
                  
                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},
                  
                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}

                  \vspace{0.5em}
              
                  \begin{vquote}
                    $\forall$($os$, $og$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}
              
                  \begin{vquote}
                    $\hat{memb}$($os$, $og$, $\iota_1$, $\sigma$)
                    $\leftarrow$
                    $\hat{memb}$($os$, $og$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    $\lnot$ $\hat{memb}$($os$, $og$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                        
                    $\lnot$ $\hat{memb}$($os$, $og$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    where
                  
                    \hspace{1em}
                    $os$ $\in$ ${\cal E}_{os}$,
                  
                    \hspace{1em}
                    $og$ $\in$ ${\cal E}_{og}$,
                  
                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,
                  
                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},
                  
                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}
              
                \item
                  {\bf Subset Temporal Rules}
              
                  \begin{vquote}
                    $\forall$($sg_0$, $sg_1$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}
              
                  \begin{vquote}
                    $\hat{subst}$($sg_0$, $sg_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                     
                    $\hat{subst}$($sg_0$, $sg_1$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    $\lnot$ $\hat{subst}$($sg_0$, $sg_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                             
                    $\lnot$ $\hat{subst}$($sg_0$, $sg_1$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    where
                  
                    \hspace{1em}
                    $sg_0$, $sg_1$ $\in$ ${\cal E}_{sg}$,
                  
                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,
                  
                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},
                  
                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}
              
                  \vspace{0.5em}

                  \begin{vquote}
                    $\forall$($ag_0$, $ag_1$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}
              
                  \begin{vquote}
                    $\hat{subst}$($ag_0$, $ag_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                     
                    $\hat{subst}$($ag_0$, $ag_1$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    $\lnot$ $\hat{subst}$($ag_0$, $ag_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                             
                    $\lnot$ $\hat{subst}$($ag_0$, $ag_1$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    where
                  
                    \hspace{1em}
                    $ag_0$, $ag_1$ $\in$ ${\cal E}_{ag}$,
                  
                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,
                  
                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},
                  
                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}
              
                  \vspace{0.5em}

                  \begin{vquote}
                    $\forall$($og_0$, $og_1$, $\iota_0$, $\iota_1$, $\sigma$),
                  \end{vquote}
              
                  \begin{vquote}
                    $\hat{subst}$($og_0$, $og_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                     
                    $\hat{subst}$($og_0$, $og_1$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    $\lnot$ $\hat{subst}$($og_0$, $og_1$, $\iota_1$, $\sigma$)
                    $\leftarrow$                                             
                    $\lnot$ $\hat{subst}$($og_0$, $og_1$, $\iota_0$, $\sigma$)
                  \end{vquote}
              
                  \begin{vquote}
                    where
                  
                    \hspace{1em}
                    $og_0$, $og_1$ $\in$ ${\cal E}_{og}$,
                  
                    \hspace{1em}
                    $\iota_0$, $\iota_1$ $\in$ ${\cal I}$,
                  
                    \hspace{1em}
                    $NET.Get$($\iota_0$, $\iota_1$) $\subseteq$
                    \{{\em During}, {\em Starts}, {\em Finishes}, {\em Equals}\},
                  
                    \hspace{1em}
                    $S_0$ $\leq$ $\sigma$ $\leq$ $S_{|V|}$
                  \end{vquote}
              
              \end{itemize}

            \end{itemize}

    \section{Discussion}

  \chapter{Implementation}

    \section{Algorithms}

    \section{Variable Grounding}

  \begin{thebibliography}{00}
    \bibitem{AL}
      Allen J. F.,
      Maintaining Knowledge about Temporal Intervals.
      {\em Communications of the ACM},
      Vol. 26, No.11, pp. 832-843,
      1983.
  \end{thebibliography}

\end{document}
