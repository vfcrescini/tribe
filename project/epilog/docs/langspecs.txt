Vino Crescini
2002 July 08

Language Specifications

1. Expressions

   1.1. Atoms

     1.1.1. Relational Atoms

       A single logical fact stating a relation between a subject and an object. There
       is no distiction between the subject/object relation and the subject-group/object-
       group relation. This implies that any given access-right can be used for both
       subject/object relations and subject-group/object-group relations.

         holds(subject, access-right, object)

       where

        subject can be a singular subject or a group of subjects.
        object can be a singular object or a group of objects.

     1.1.2. Containment Atoms

       A single logical fact describing a set containment relationship to another set.

         cont(subject-group-1, subject-group-2) 

       is read as

         "subject-group-1 is contained in subject-group-2"

     1.1.3. Membership Atoms

       A single logical fact describing the membership of a singular subject/object
       to a subject/object group.

         elt(subject-1, subject-group-1)

       is read as

         "subject-1 is an element of subject-group-1"

   1.2. Compound Statements

     1.2.1. Conjuction

     Atoms can be grouped together with the logical conjunction AND. Note that
     DISJUNCTIONS are not allowed in this language. The symbol for this conjuction
     is && (double ampersand, as it is in C).

       <atom> && <atom> && ...

     1.2.2. Negation

       Atoms can be negated with the ! symbol (exclamation-point, as it is in C).
     
         ! <atom>

     1.2.3. Operator Precedence

       The negation operator has higher precedence than the conjunction operator.

         ! holds(a1, b1, c1) && ! holds(a2, b2, c2)

       is evaluated as

         (! holds(a1, b1, c1)) && (! holds(a2, b2, c2))

       Compound statements are always evaluated from left to right. This means the left-
       most operator (conjuction or negation) is evaluated first. This can be safely
       ignored since the language contains only 2 operators with different precedence
       levels.

         ! holds(a1, b1, c1) && holds(a2, b2, c2) && holds(a3, b3, c3)

       is evaluated as

         ((! holds(a1, b1, c1)) && holds(a2, b2, c2)) && holds(a3, b3, c3)


  1.3. Constant Expressions

    The following symbols may be used:

      true

      false

  1.4. Variables

    No variables are allowed to occur on any atom.

2. Definition Statements

  2.1. Initial State Defintion

    The initial state can be defined by the following statement

      initially <expression>

    Note that <expression> may be a conjuction of many atoms. Also, the
    initially clause may be defined more than once.

  2.2. Transformation Definition Statement

    A transformation definition statement must be defined in the following
    syntax:

      trans <trans-identifier> 
      causes <post-condition-expression>
      if <pre-condition-expression>

    where:

      <trans-identifier> is the identifier of this transformation

      <post-condition-expression> an expression that will be true in the
        resulting state after the transformation is the identifier of this
        transformation.

      <pre-condition-expression> an expression that must be true in the
        current state before the transformation may be applied.

    Note that a transformation definition statement may have variables:

      trans delete-write(SUBJECT, OBJECT)
      causes !holds(SUBJECT, read, OBJECT)
      if holds(SUBJECT, read, OBJECT)

    this means 

      delete-write(subject1, object1)

    and

      delete-write(subject2, object2)

    will cause

      !holds(subject1, write, object1)

    and

      !holds(subject2, write, object2)

    if subject1 and subject2 had write access rights to object1 and object2,
    respectivley.

    The case where the pre-condition is an empty-set (ie. the transformation
    has no pre-condition) does not have to be a special case:

      trans <trans-identifier> 
      causes <post-condition-expression> 
      if true

    The constant expression "true" can be used to indicate that there are no
    pre-conditions required for this transformation.


  2.3. Policy Proposition

    
