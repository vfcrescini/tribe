Vino Crescini
2002 July 08

Language Specifications

1. Expressions

   1.1. Identifiers

     Identifiers are case-sensitive. Must be prefixed by a single character 
     that specifies the type of the identifier. The first character must then
     be followed by 0 or more alphanumeric characters plus an underscore (_).

     1.1.1. Subjects

       The first character of the identifier must be a lower-case "s".

         s[a-zA-Z0-9_]*

     1.1.2. Access-Rights

       The first character of the identifier must be a lower-case "a".

         a[a-zA-Z0-9_]*

     1.1.3. Objects

       The first character of the identifier must be a lower-case "o".

         o[a-zA-Z0-9_]*

     1.1.4. Groups

       Groups are identified by shifting the first character of the identifier
       to uppercase.

       S[a-zA-Z0-9_]* for subject-groups
       A[a-zA-Z0-9_]* for access-right-groups
       O[a-zA-Z0-9_]* for object-groups

   1.2. Atoms

     1.2.1. Relational Atoms

       A single logical fact stating a relation between a subject and an object.
       There is no distinction between singular entities and group entities.

         holds(subject, access_right, object)

     1.2.2. Containment Atoms

       A single logical fact describing a set containment relationship to
       another set.

         cont(Subject_1, Subject_2) 

       is read as

         "group Subject_1 is contained in group Subject_2"

     1.2.3. Membership Atoms

       A single logical fact describing the membership of a singular 
       subject/access-right/object to a subject/access-right/object group.

         elt(subject_1, Subject_1)

       is read as

         "subject_1 is an element of group Subject_1"

   1.3. Compound Statements

     1.3.1. Conjuction

     Atoms can be grouped together with the logical conjunction AND. Note that
     DISJUNCTIONS are not allowed in this language. The symbol for this
     conjuction is && (double ampersand, as it is in C).

       <atom> && <atom> && ...

     1.3.2. Negation

       Atoms can be negated with the ! symbol (exclamation-point, as it is
       in C).
     
         ! <atom>

     1.3.3. Operator Precedence

       The negation operator has higher precedence than the conjunction
       operator.

         ! holds(sub1, acc1, obj1) && ! holds(sub2, acc2, obj2)

       is evaluated as

         (! holds(sub1, acc1, obj1)) && (! holds(sub2, acc2, obj2))

       Compound statements are always evaluated from left to right. This means
       the left-most operator (conjuction or negation) is evaluated first. This
       can be safely ignored since the language contains only 2 operators with 
       different precedence levels.

         ! holds(sub1, acc1, obj1) && 
         holds(sub2, acc2, obj2) && 
         holds(sub3, acc3, obj3)

       is evaluated as

         ((! holds(sub1, acc1, obj1)) && 
         holds(sub2, acc2, obj2)) &&
         holds(sub3, acc3, obj3)

  1.4. Constant Expressions

    The following symbols may be used:

      true

      false

  1.5. Variables

   Variables are only permitted to occur on transformation proposition
   statements. They must be in the form:

     v[a-zA-Z0-9]*

2. Definition Statements

  2.1. Initial State Defintion

    The initial state can be defined by the following statement

      initially <expression>

    Note that <expression> may be a conjuction of many atoms. Also, the
    initially clause may be defined more than once.

  2.2. Transformation Definition Statement

    A transformation definition statement must be defined in the following
    syntax:

      trans <trans-identifier> 
      causes <post-condition-expression>
      if <pre-condition-expression>

    where:

      <trans-identifier> is the identifier of this transformation

      <post-condition-expression> an expression that will be true in the
        resulting state after the transformation is the identifier of this
        transformation.

      <pre-condition-expression> an expression that must be true in the
        current state before the transformation may be applied.

    Note that a transformation definition statement may have variables:

      trans delete-write(vSUBJECT, vOBJECT)
      causes !holds(vSUBJECT, a_write, vOBJECT)
      if holds(vSUBJECT, a_write, vOBJECT)

    this means 

      delete-write(subject1, object1)

    and

      delete-write(subject2, object2)

    will cause

      !holds(subject1, a_write, object1)

    and

      !holds(subject2, a_write, object2)

    if subject1 and subject2 had write access rights to object1 and object2,
    respectively.

    The case where the pre-condition is an empty-set (ie. the transformation
    has no pre-condition) does not have to be a special case:

      trans <trans-identifier> 
      causes <post-condition-expression> 
      if true

    The constant expression "true" can be used to indicate that there are no
    pre-conditions required for this transformation.

  2.3. Policy Proposition Definition Statement

    This statement is used for queries.

      is <policy-expression> 
      after <trans-identifier-1>, <trans-identifier-2>, ...

    Or, to query the initial state:

      is <policy-expression> 

    The statement will return one of the following: true, false or ?

